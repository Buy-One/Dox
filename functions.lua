--[[

**** M **** E **** N **** U ****

U N D O

M A T H

S T R I N G S

T A B L E S

M I D I

(R E) S T O R E

O B J E C T S

T R A C K S

S E N D S / R E C E I V E S

F O L D E R S

E N V E L O P E S

A U T O M A T I O N  I T E M S

C H U N K

R A Z O R  E D I T

F X

I T E M S

C O L O R

C L O S U R E S

M A R K E R S  &  R E G I O N S

G F X

W I N D O W S

T H E M E

F I L E S

M E A S U R E M E N T S / C A L C U L A T I O N S

U T I L I T Y

C O N V E R S I O N S

R E A S C R I P T  F U N C T I O N S  F O R  V A R I O U S  T A S K S

F U N C T I O N   L I S T



]]




--========================= U N D O  S T A R T =========================

do return r.defer(function() end) end

do r.defer(function() if not bla then return end end) end -- to avoid defer being stuck and display ReaScrpt task control dialogue on successive runs
--OR
do r.defer(function() do return end end) end
-- neither works if a shortcut is held continuously


function no_undo()
do return end
end
-- USE:
-- do return r.defer(no_undo) end
-- OR
-- if ... then return r.defer(no_undo) end


function no_undo() end
do return r.defer(no_undo) end -- 'return' isn't required

local function nothing() end; local function bla() r.defer(nothing) end -- nofish; ARCHIE
bla() return


-- in some situation must be placed after
-- 'return r.defer(function() do return end end) end'
-- to make it prevent creation of a generic undo point (ReaScript: Run) or one generated by a native action when such is used upstream in the routine
r.Undo_BeginBlock()
r.Undo_EndBlock('', -1)

-- also when undo condition isn't satisfied, e.g.

if undo then
r.Undo_EndBlock(undo, -1)
else r.Undo_EndBlock('', -1) end


function undo_block(undo) -- undo arg is a string, which isn't used at the beginning of the block and only used at its end
	if not undo then r.Undo_BeginBlock()
	else r.Undo_EndBlock(undo, -1)
	end
end


-- Undo with only the script name
r.Undo_EndBlock(({r.get_action_context()})[2]:match('([^\\/_]+)%.%w+$'), -1)


r.Undo_EndBlock(r.Undo_CanUndo2(0) or '', -1) -- prevent display of the generic 'ReaScript: Run' message in the Undo readout generated when the script is aborted following Undo_BeginBlock() (to display an error for example), this is done by getting the name of the last undo point to keep displaying it, if empty space is used instead the undo point name disappears from the readout in the main menu bar; must be followed by 'return r.defer(no_undo)' to exit script


function Force_MIDI_Undo_Point1(take)
-- a trick shared by juliansader to force MIDI API to register undo point; Undo_OnStateChange() works too but with native actions it may create extra undo points, therefore Undo_Begin/EndBlock() functions must stay
-- https://forum.cockos.com/showpost.php?p=1925555
local item = take and r.GetMediaItemTake_Item(take) or r.GetMediaItemTake_Item(r.MIDIEditor_GetTake(r.MIDIEditor_GetActive()))
--r.SetMediaItemSelected(item, false)
--r.SetMediaItemSelected(item, true)
local is_item_sel = r.IsMediaItemSelected(item)
r.SetMediaItemSelected(item, not is_item_sel)
r.SetMediaItemSelected(item, is_item_sel)
end


function Force_MIDI_Undo_Point2(take) -- may or may not work, the above version is more reliable
local item = r.GetMediaItemTake_Item(take)
local tr = r.GetMediaItemTrack(item)
r.MarkTrackItemsDirty(tr, item)
end


function Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, pass, want_chain)
-- Due to REAPER bug https://forum.cockos.com/showthread.php?t=281778, which was fixed in build 7.01
-- undo point for all RS5k instances is only created with open FX chain window
-- to create an undo point for a single instance it suffices to open it in a floating window
-- the function must be run in two passes within the Undo blocks
-- 1st pass before the action for which undo point needs to be created, 2nd pass after it
-- if flag -1 doesn't work in Undo block flag 2 must be used
-- ARGS:
-- targ_fx_idx is the single target fx to be affected by the script and to be opened in the floating window, must only be valid if want_chain is false, to be used in both function passes;
-- targ_fx_floats isn't needed in the 1st pass, only needed in the second if want_chain is false;
-- last_sel_idx and last_sel_fx_floats in the 1st pass aren't needed, only needed in the 2nd pass if want_chain is true;
-- pass is integer, 1 or 2;
-- want_chain is boolean if the entire chain has to be opened because multiple RS5k instances are affected, in this case relies on GetObjChunk() function
-- to evaluate build: tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.01

	if pass == 1 then
	local chain_vis = r.TrackFX_GetChainVisible(tr) ~= -1
	local targ_fx_floats = r.TrackFX_GetFloatingWindow(tr, targ_fx_idx)
		if (want_chain and not chain_vis or not want_chain and not chain_vis and targ_fx_idx and not targ_fx_floats)
		then -- open
		local last_sel_idx = 0
			if want_chain then
			local ret, chunk = GetObjChunk(tr)
				if ret then -- if chunk was successfully retrieved
					for line in tr_chunk:gmatch('[^\n\r]+') do
						if line:match('LASTSEL') then last_sel_idx = line:match('%d+') break end -- extract the index of fx selected in fx chain so that if the chain is closed it could be opened with this fx visible to make REAPER register change in the undo history
					end
				end
			end
		local last_sel_fx_floats = want_chain and r.TrackFX_GetFloatingWindow(tr, last_sel_idx) -- if last selected fx window floats while the fx chain is closed, after toggling open-close the fx chain below the floating window will be closed because the function will use its index to keep it selected in the chain, so find if it floats to re-float it after toggling the fx chain open-close
		local open = want_chain and r.TrackFX_SetOpen(tr, last_sel_idx, true) -- open arg true - open fx chain with last selected fx shown
		or fx_idx and not targ_fx_floats and r.TrackFX_Show(tr, fx_idx, 3) -- or open target fx in a floating window, flag 3
		return last_sel_idx, last_sel_fx_floats, r.TrackFX_GetFloatingWindow(tr, fx_idx)
		end
	elseif pass == 2 then -- close
	local clse = last_sel_idx and r.TrackFX_SetOpen(tr, last_sel_idx, false) -- close fx chain if was closed originally, open arg is false
	or fx_idx and targ_fx_floats and r.TrackFX_Show(tr, fx_idx, 2) -- or close the target fx floating window if was closed originally, flag 2 close floating window
	local re_float = last_sel_fx_floats and r.TrackFX_Show(tr, last_sel_idx, 3) -- show in a floating window, flag 3, re-float fx last selected in the fx chain if it was floating prior to toggling the fx chain open-close, because it will end up being closed as a result
	end

end
-- USE (WORKING WITH A SINGLE RS5k INSTANCE):
-- Undo_BeginBlock()
-- local last_sel_idx, last_sel_fx_floats, targ_fx_floats = Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 1, false) -- targ_fx_floats, last_sel_idx, last_sel_fx_floats are nil, pass is 1, want_chain false
-- DO STUFF
-- Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 2, false) -- last_sel_idx, last_sel_fx_floats are nil, pass is 2, want_chain false
-- Undo_EndBlock()

-- (WORKING WITH MULTIPLE RS5k INSTANCES):
-- Undo_BeginBlock()
-- local last_sel_idx, last_sel_fx_floats, targ_fx_floats = Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 1, true) -- targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats are nil, pass is 1, want_chain true
-- DO STUFF
-- Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 2, false) -- targ_fx_idx, targ_fx_floats and nil, last_sel_idx is integer, last_sel_fx_floats is boolean, pass is 2, want_chain true
-- Undo_EndBlock()


function GetUndoSettings()
-- Checking settings at Preferences -> General -> Undo settings -> Include selection:
-- thanks to Mespotine https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
-- https://github.com/mespotine/ultraschall-and-reaper-docs/blob/master/Docs/Reaper-ConfigVariables-Documentation.txt
-- as of 7.22 undomask bitfield only includes 'Include in selection:' flags
-- and "When approaching full undo memory ..." setting

-- get_config_var_string() can be used instead of io.open()
-- which is advantageous because at certain configuration the
-- key is removed from reaper.ini but it of course stays in RAM
--[[
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local undoflags = cont:match('undomask=(%d+)')+0 -- +0 is accommodating for Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
]]
local retval, undoflags = r.get_config_var_string('undomask')
undoflags = undoflags+0 -- converting into integer with +0 to accommodate Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
local t = {
1, -- item selection
2, -- time selection
4, -- full undo, keep the newest state
8, -- cursor pos
16, -- track selection
32, -- env point selection
128 -- MIDI events (the bit is set when the option is UNchecked)
}
	for k, bit in ipairs(t) do
	t[k] = bit ~= 128 and undoflags&bit == bit or undoflags&bit ~= bit
	end
return t
end



function Toggle_Undo_Settings1(undoflags)
-- undoflags value is returned at setting stage
-- and is passed as arg at the restoration stage

	local function all_undo_sett_ON(undoflags)
		for k, bit in ipairs({1,2,8,16,32,128}) do
			if bit~=128 and undoflags&bit ~= bit
			or bit==128 and undoflags&bit == bit then
			return
			end
		end
	return true
	end

	if not undoflags -- and not r.HasExtState(scr_cmdID, 'UNDO FLAGS') 
	then -- enable and optionally store the original value
	local retval, undoflags = r.get_config_var_string('undomask')
	undoflags = undoflags+0 -- converting into integer with +0 to accommodate Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
		if not all_undo_sett_ON(undoflags) then
		local val = (undoflags|1|2|8|16|32)&~128 -- setting all bits besides 'When approaching full undo ...'; bit 128 MIDI events is set when the option is UNchecked therefore to enable the setting the bit must be cleared
		r.SNM_SetIntConfigVar('undomask', val)
		-- r.SetExtState(scr_cmdID, 'UNDO FLAGS', undoflags, false) -- persist false
		end
	return undoflags
	else -- restore
	local retval, undoflags_cur = r.get_config_var_string('undomask')
		if undoflags_cur+0 ~= undoflags then
		r.SNM_SetIntConfigVar('undomask', undoflags)
		end
	end
end
-- USE:
-- local undoflags = Toggle_Undo_Settings1()
-- Toggle_Undo_Settings1(undoflags)



function Toggle_Undo_Settings2(scr_cmdID, restore)
-- undoflags value is stored as extended state
-- rather than being returned at the setting stage
-- as in Toggle_Undo_Settings1() above
-- restore is boolean

	local function all_undo_sett_ON(undoflags)
		for k, bit in ipairs({1,2,8,16,32,128}) do
			if bit~=128 and undoflags&bit ~= bit
			or bit==128 and undoflags&bit == bit then
			return
			end
		end
	return true
	end

local stored = r.HasExtState(scr_cmdID, 'UNDO_FLAGS')

	if not restore and not stored then -- enable and store the original value
	-- this part is run before the menu is (re)opened while RUN ACTIONS is enabled
	local retval, undoflags = r.get_config_var_string('undomask')
	undoflags = undoflags+0 -- converting into integer with +0 to accommodate Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
		if not all_undo_sett_ON(undoflags) then
		local val = (undoflags|1|2|8|16|32)&~128 -- setting all bits besides 'When approaching full undo ...'; bit 128 MIDI events is set when the option is UNchecked therefore to enable the setting the bit must be cleared
		r.SNM_SetIntConfigVar('undomask', val)
		r.SetExtState(scr_cmdID, 'UNDO_FLAGS', undoflags, false) -- persist false // store original flags
		end
	elseif restore and stored then -- restore
	-- this part is run when ADD ARMED ACTION is disabled and the menu or the script is exited
	local retval, undoflags = r.get_config_var_string('undomask')
	local undoflags_stored = r.GetExtState(scr_cmdID, 'UNDO_FLAGS')
		if undoflags ~= undoflags_stored then
		r.SNM_SetIntConfigVar('undomask', undoflags_stored) -- string is supported as well as the 2nd argument
		r.DeleteExtState(scr_cmdID, 'UNDO_FLAGS', true) -- persist true
		end
	end

end



function insert_get_delete_bckgrnd_track(scr_cmdID, delete)
-- scr_cmdID comes from r.get_action_context(), delete is boolean
-- used inside force_create_undo_point() below
local take_GUID = r.GetExtState(scr_cmdID, 'TAKE_GUID')
local take = #take_GUID > 0 and r.GetMediaItemTakeByGUID(0, take_GUID) -- if take isn't found returns nil
local tr = take and r.GetMediaItemTake_Track(take)
	if (not take or not tr) and not delete then -- create if not yet created or deleted // take is evaluated first because track can exist without take
	local SET = r.SetMediaTrackInfo_Value
	r.PreventUIRefresh(1)
		if not tr then
		local SET = r.SetMediaTrackInfo_Value		
		r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false
		local idx = r.GetNumTracks()-1
		tr = r.GetTrack(0, idx)
		SET(tr, 'B_SHOWINTCP', 0); SET(tr, 'B_SHOWINMIXER', 0);	SET(tr, 'B_MAINSEND', 0)
		end
		if not take then
		local item = r.AddMediaItemToTrack(tr) -- length is 0 so will be invisible
		take = r.AddTakeToMediaItem(item) -- add take to be able to find track via the take and dispense with iterating over all tracks in the project
		local retval, take_GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
		r.SetExtState(scr_cmdID, 'TAKE_GUID', take_GUID, false) -- persist false
		end
	r.PreventUIRefresh(-1)
	elseif tr and delete then
	r.DeleteTrack(tr) return
	elseif tr then -- if track has been unhidden by the user or its master/parent send was enabled, restore
		for k, attr in ipairs({'B_SHOWINMIXER','B_SHOWINTCP','B_MAINSEND'}) do
			if r.GetMediaTrackInfo_Value(tr, attr) == 1 then
			SET(tr, 0)
			end
		end
	end
return tr, take
end


function force_create_undo_point(scr_cmdID)
-- scr_cmdID comes from r.get_action_context()
-- relies on insert_get_delete_bckgrnd_track() above

-- REAPER doesn't create undo points for changes
-- which don't affect project, such as toggles, action arming,
-- acton types exclusive to custom actions which only modify
-- their behavior, or if identical actions follow each other
-- the undo point is only created for the first one, 
-- which makes it difficult to create a complete undo sequence
-- for the tested custom actions
-- the solution is in making inconsequential changes in the background
-- so REAPER registers a change to the project, such as setting 
-- and clearing the label of a background track
local tr, take = insert_get_delete_bckgrnd_track(scr_cmdID)
local GETSET = r.GetSetMediaTrackInfo_String
local retval, tr_name = GETSET(tr, 'P_NAME', '', false) -- setNewValue false
local is_set = #tr_name:gsub(' ','') > 0
local set = GETSET(tr, 'P_NAME', is_set and '' or 'name', true) -- setNewValue true
end


-- see also Force_MIDI_Undo_Point1, Force_MIDI_Undo_Point1 in  M I D I
-- Force_RS5k_Undo_With_Closed_Chain() in FX


--========================= U N D O  E N D =======================================


--================================ M A T H  S T A R T ===================================

-- find if number is integer
function is_integer(num)
return math.floor(num) == num -- integer is true, fraction is false
-- or math.ceil(num) == num
end

function is_decimal(num) -- flipped version of the above
return math.floor(num) ~= num -- or math.ceil(num) ~= num
end


function is_even1(num)
return num%2 == 0 -- can be divided by 2 without a remainder
end

function is_even2(num)
return num&1 == 0
end


function is_odd1(num)
return num%2 ~= 0 -- cannot be divided by 2 without a remainder
end


function is_odd2(num)
return num&1 == 1
end


-- only works for numbers above 0
function round1(num) -- if decimal part is greater than or equal to 0.5 round up else round down; rounds to the closest integer
	if math.floor(num) == num then return num end -- if number isn't decimal
return math.ceil(num) - num <= num - math.floor(num) and math.ceil(num) or math.floor(num)
end

-- only works for numbers above 0
function round2(num) -- if decimal part is smaller than 0.5 round down else round up; rounds to the closest integer
local rounded = math.floor(num)
	if rounded == num then return num end -- if number isn't decimal
return rounded+0.5 > num and rounded or math.ceil(num)
end


-- OR SIMPLY
-- only works for numbers above 0
function round3(num)
return math.floor(num+0.5)
end

-- OR
-- num = tonumber(string.format('%.f', num))

-- ???????? doubtfully correct
function round4(num) -- works with all numbers negative and positive above 1 and below -1
-- with negative values math.floor rounds towards the lesser value, i.e. -4.5 to -5 hence math.ceil instead
return num >= 0 and math.floor(num+0.5) or math.ceil(num-0.5)
end


function round(num, idp) -- idp = number of decimal places, 0 means rounding to integer
-- http://lua-users.org/wiki/SimpleRound
-- round to N decimal places
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end


function truncate_decimal(num, num_decimal_places) -- number, integer
local dec = num_decimal_places
local dec = tonumber(dec) and 10^math.floor(dec) -- preventing non-numbers and decimal numbers
	if not dec and num then return num, 'Error: missing argument'
	elseif not num then return 'Error: missing arguments' end
return math.floor(num*dec+0.5)/dec
end
-- OR simply
-- math.floor(num*(10^5)+0.5)/10^5 -- truncating down to 5 (10^5) dec places



function truncate(num, dec_places)
return math.floor(num*(10^dec_places)+0.5)/10^dec_places
end



function trim_trail_zero(num)
return math.floor(num) == num and math.floor(num) or num
end



math.randomseed(math.floor(r.time_precise()*1000)) -- seems to facilitate greater randomization at fast rate thanks to milliseconds count; math.floor() because the seeding number must be integer


function Get_Closest_Prev_Whole_Multiple(dividend, int_divisor)
-- https://math.stackexchange.com/questions/2179579/how-can-i-find-a-mod-with-negative-number modulo of negative numbers
-- charactertic of Lua in particular https://torstencurdt.com/tech/posts/modulo-of-negative-numbers/
-- not in all languages modulo of a negative number differs from its positive countepart; in Lua to have the same modulo for negative numbers the divisor must be negative as well
-- the formula is to get the modulo and then subtract it from the dividend
	if math.abs(dividend) >= 1 and -- allowing for numbers smaller than 1
	( math.abs(dividend) < math.abs(int_divisor) -- accounting for negative values
	or dividend ~= math.floor(dividend) ) -- dividend is a decimal number
	or dividend == 0
	or int_divisor ~= math.floor(int_divisor) -- divisor is a decimal number
	or int_divisor == 0
	then return false
	else
		if math.abs(dividend) < 1 then
		local dec_places = 10^#tostring(dividend):match('%.(%d+)')
		return (dividend*dec_places - dividend*dec_places%int_divisor)/dec_places
		-- return (dividend*dec_places - (dividend < 0 and math.abs(dividend)*dec_places%int_divisor*-1 or dividend*dec_places%int_divisor))/dec_places -- to get the multiple mirroring positive dividend, that is one closer to 0, otherwise the multiple is the next value smaller than the dividend which for negative numbers is farther from 0
		else return dividend - dividend%int_divisor
		-- return dividend - (dividend < 0 and math.abs(dividend)%int_divisor*-1 or dividend%int_divisor) -- to get the multiple mirroring positive dividend, that is one closer to 0, otherwise the multiple is the next value smaller than the dividend which for negative numbers is farther from 0
		end
	end
end


function Get_Closest_Multiple_Of_Divisor1(number, divisor) 
-- number is some number, decimal arguments and arguments < 1 are supported;
-- the closest meaning the closest to the number, on either side;
-- math.floor for negative numbers rounds closer to 0, i.e. -4.5 is rounded to 4
-- rather than to -5
	local function round(num) -- if decimal part is greater than or equal to 0.5 round up else round down; rounds to the closest integer
		if math.floor(num) == num then return num end -- if number isn't decimal
	return math.ceil(num) - num <= num - math.floor(num) and math.ceil(num) or math.floor(num)
-- OR
-- return math.floor(num+0.5) -- only numbers > 1 are supported
	end
local dec_places = math.abs(number) < 1 and 10^#tostring(number):match('%.(%d+)')
number = number*(dec_places or 1)	
return round(number/divisor)*divisor/(dec_places and dec_places or 1)
end



function Get_Closest_Multiple_Of_Divisor2(number, divisor, want_next)
-- number is some number, decimal arguments and arguments < 1 are supported;
-- if want_next is false/nil returns closest previous multiple, otherwise closest next
-- math.floor for negative numbers rounds closer to 0, i.e. -4.5 is rounded to 4
-- rather than to -5
local dec_places = math.abs(number) < 1 and 10^#tostring(number):match('%.(%d+)')
number = number*(dec_places or 1)
return (math.floor(number/divisor)*divisor+(want_next and divisor or 0))/(dec_places and dec_places or 1)
end


function Get_Closest_Multiple_Of_Divisor3(int, int_divisor, want_next)
-- only integers are supported
local modulo = int%int_divisor
local prev_mult = int - modulo
return prev_mult and (want_next and prev_mult + int_divisor or 0)
end


local function nmb(...) -- abbreviation
return tonumber(...)
end
-- OR simply
-- nmb = tonumber


function split_integer_to_1s_and_10s(integer)
local tens, ones
	if integer then
	tens, ones = math.modf(integer/10) -- ones return as a decimal number whose decimal value represent whole ones, e.g. 0.3
	ones = ones*10 -- convert decimal number with whole part being 0, to integer
	-- OR
	-- ones = math.floor(ones*10+0.1) -- ro get rid of the decimal 0 in case ones is 0.0
	end
return tens, ones
end


function range_to_sequence(start, fin) -- integers only
local start = tonumber(start)
local fin = tonumber(fin)
	if not start or not fin then return end
local start_int = math.floor(start) == tonumber(start)
local fin_int = math.floor(start) == tonumber(start)
	if not start_int or not fin_int then return end
local t = {}
	for i = start, fin do
	t[#t+1] = i
	end
return t
end


function gener_numer_seq(start, fin)
local t = {}
	for i = start, fin do
	t[#t+1] = i
	end
return t
end


function mod(a, b) -- same as math.fmod(a,b) since Lua 5.1 and math.mod in Lua 5.0 or % operator
-- https://stackoverflow.com/a/20858039/8883033
    return a - (math.floor(a/b)*b)
end


function get_integral_1(num, divisor) -- get intergal part of the quotient after division of num by divisor
return math.modf(num/divisor)
end

function get_integral_2(num, divisor) -- same as the 1st return value of math.modf(num/divisor)
return math.floor((num - num%divisor)/divisor) -- previous multiple divided by the divisor so the intergal value is obtained
end

function get_fractional_1(num, divisor) -- get fractional part of the quotient after division of num by divisor
return select(2, math.modf(num/divisor)) -- or ({math.modf(num/diviser)})[2]
end

function get_fractional_2(num, divisor) -- same as the 2nd return value of math.modf(num/divisor)
return num/divisor - math.floor((num - num%divisor)/divisor) -- quotient minus the integral part
end


function get_prev_multiple(num, divisor) -- a multiple of the divisor lesser than the num
return num - num%divisor
end


function get_base2_log(number) -- the power to which 2 must be raised to get number
-- https://www.gammon.com.au/scripts/doc.php?lua=math.log
return math.log(number)/math.log(2)
end


function truncate_all_dec_places1(num, wantString) -- wantString is boolean to convert to string
local num = math.floor(num)
return wantString and num..'' or num
end


function truncate_all_dec_places2(num, wantString) -- wantString is boolean to convert to string
return wantString and (num..''):match('(.+)%.') or math.floor(num)
end


function toBits1(num) -- represent integer as binary
-- returns a table of bits, least significant first
-- https://stackoverflow.com/questions/9079853/lua-print-integer-as-a-binary
local t={} -- will contain the bits
local num = num
	while num > 0 do
	local rest = math.fmod(num,2)
	t[#t+1]= rest
	num = (num-rest)/2
	end
return t
end
--bits = toBits(num)


function toBits2(num, bits) -- represent integer as binary // bits is the number of required bits
-- returns a table of bits, most significant first
-- https://stackoverflow.com/questions/9079853/lua-print-integer-as-a-binary
local num = num
local bits = bits or math.max(1, select(2, math.frexp(num)))
local t = {} -- will contain the bits
	for b = bits, 1, -1 do
	t[b] = math.fmod(num, 2)
	num = math.floor((num - t[b]) / 2)
	end
return t
end


function toBits3(num, bits)
-- returns a table of bits
local t={} -- will contain the bits
    for b=bits,1,-1 do
	rest=math.fmod(num,2)
	t[b]=rest
	num=(num-rest)/2
    end
	if num == 0 then return t else return {'Not enough bits to represent this number'} end
end
--num=255
--bits=8
--bits=toBits(num, bits)


function count_bits_in_number(integer)
local integer = tonumber(integer)
local base = 1
local bit_cnt = 0
  while base < integer do
  base = base*2
  bit_cnt = bit_cnt+1
  end
return bit_cnt
end


function hex2dec(str)
-- https://stackoverflow.com/questions/27294310/convert-hexadecimal-to-decimal-number
return str:match('0x') and tonumber(str) or tonumber(str,16)
end


function dec2hex(dec_int)
-- https://www.rapidtables.com/convert/number/decimal-to-hex.html algo

	if not dec_int then return end
	
local dec_int2

	if dec_int > 0xfffffffffffff then  -- 2^52
	-- math.maxinteger is supported from Lua 5.3
		if tonumber(_VERSION:match('[%.%d]+')) < 5.3 or math.maxinteger == 0x7fffffff then -- either Lua older than 5.3 or 32 bit system, 0x7fffffff == 2147483647
		return dec_int -- on a 32 bit system integers above 2^31 Lua encodes as double floating point numbers while in older Lua versions all integers are encoded as double floating point numbers; in all versions of Lua floating point precision limit is 2^53-1 (about 15 - 17 decimal places) after which rounding errors start to occur, so in these two cases no point to convert a number above 2^53-1 (in practical terms above 2^52, because in division and modulo operations employed for conversion into hex this is the limit of accuracy) because it will be fed in with rounding erros from the outset
		end
	-- the following assumes that integers up to 2^53-1 are represented natively rather than as floating point numbers, 
	-- which is good for REAPER since native integer representaion is supported in Lua 5.3+
	-- run by all REAPER versions with Lua support
	local diff = math.floor(math.log(dec_int)/math.log(2))-52 -- find by how much the input exponent exceeds the Lua max floating point number precision limit which is 53 bit i.e. ~15-17 decimal places, because numbers whose decimal places exceed this limit lose precision and cause wrong calculation result, this workround is needed because the employed conversion method to hex relies on division and modulo operaions which produce decimal numbers for which precision is important; using value 52 instead of 53 because in division and modulo operations the limit of accuracy is 52 bit; formula to calculate exponend of the value by specific base comes from  https://www.gammon.com.au/scripts/doc.php?lua=math.log
	dec_int, dec_int2 = dec_int >> diff, dec_int >> 52 -- shift the input value right by the difference to only leave bits whose total doesn't affect precision, then shift the input value right by 52 bits to isolate the remaining upper bits, those which have been discarted in shifting right by the difference // this is the correct splitting method for subsequent string concatenaton because it produces parts with different bit width just as would occur in splitting a string for example '256' into '56' and '2', because maintaining original width i.e. '056' and '200' would not allow accurate concatenation resulting in 200056
	end

local hex = ''
local t  = {[0]=0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e','f'}
	repeat
	local quotient = math.modf(dec_int/16) -- OR math.floor(dec_int/16)
	hex = t[dec_int%16]..hex
-- OR
--	hex = t[dec_int-16*quotient] and t[dec_int-16*quotient]..hex or hex
	dec_int = quotient
	until quotient == 0

local hex2
	if dec_int2 then -- if the input number exponent exceeds the Lua floating point number max precision limit, convert the remaining upper bits, those which exceed 52 bits and concatenate the results placing the upper bits conversion result at the front as that's where they're placed in the bitfield
	hex2 = dec2hex(dec_int2)
	hex = hex2:sub(3)..hex
	end
	
return '0x'..hex
end
-- for inverse operation: hex 2 dec
-- dec = tonumber(hex:match('0x(%x+)'), 16) -- OR hex:sub(3) // hex string sans 0x


-- a % b == a - math.floor(a/b)*b


function get_integer_length(int)
	if not int or not tonumber(int) then return 0 end
local int = math.abs(tonumber(int)) -- rectify negative	
	for i = 0, math.huge do
		if int == 0 or int >= 10^i and int < 10^(i+1)
		then return i+1 end
	end
end
-- OR #(integer..'') -- convert to string and measure string length


function un_pack_integers(t, length, packed_int)
-- ONLY ABLE TO ACCURATELY UNPACK A TOTAL NUMBER OF 16 DIGITS
-- DUE Lua FLOATING POINT PRECISION LIMIT OF 10^15
-- i.e. 16 single digit integers at length 1, 
-- 8 two digit integers at length 2, 
-- 4 four digit integers at length 4
-- and a mix of those, however the length used to accommodate
-- longer integers will affect the limit because shorter integers
-- will use it as well, i.e. at length 2 single digit integers 
-- will be treated as two digit therefore their total count
-- which can be packed alongside two digit integers will be reduced
-- to (16 - length of all two digit integers)/2 
-- OR to 8 (the max count of two digit integers) - the total count of 
-- two digit integers in array;
-- 0 cannot be packed;
-- t is an array containing integers to be packed into a single integer
-- length is the max number of digits allowed in the integer set for packing
-- i.e. if length is 2 the function will only be able to accurately pack
-- and unpack integers consisting of no more than two digits, that is exlcuding
-- integers from 100 upwards, it can exceed the length of the longest
-- integer but not fall short of it
-- the length can be determined dinamically based on the longest integer in the array
-- but then it must be returned along with the packed integer to allow accurate
-- unpacking, in this case pass it as nil/false;
-- packed_int is the resulting integer to be passed at the unpacking stage;
-- if packed_int is invalid, packing routine is activated, otherwise unpacking;
-- relies on get_integer_length() function if length arg isn't supplied;
-- the function uses fixed base exponent method which is increased by 1
-- for each next integer, i.e.
-- a*10^(length*0) + a*10^(length*1) + c*10^(length*2) etc.
-- length is the fixed component
-- this allows easy unpacking without having to know 
-- the length of original integers as required in other methods
-- but it comes at the cost of wasting much more space;
-- the employed method isn't described in the below links, so they're only
-- for general reference
-- https://clivesyabb.com/2021/10/01/encoding-multiple-values-in-a-single-number/ +
-- https://www.quora.com/How-do-you-combine-two-numbers-into-one-and-extract-them-back-integers-compression-math
-- https://stackoverflow.com/questions/5302562/packing-4-integers-as-one-integer
-- https://stackoverflow.com/a/5302596/8883033
-- https://stackoverflow.com/questions/4550891/packing-values-into-a-single-int

local length = length

	if not length then
		for k, int in ipairs(t) do
		local int_length = get_integer_length(int)
		length = (not length or length < int_length) and int_length or length
		end
	end

	if not packed_int then
	local packed = 0
		for k, int in ipairs(t) do
		packed = packed + int*10^((k-1)*length)
			if packed > 10^15 then
			r.ReaScriptError('Storage limit has been exceeded: '..packed)
			return end
		end
	return packed, length
	else
		if not length then return packed end
	local unpacked_t = {}
	local floor = math.floor
	local mult = 10^length
		repeat
		unpacked_t[#unpacked_t+1] = floor(packed_int%mult)
		packed_int = floor(packed_int/mult) -- reduce for the next cycle by the unpacked integer
		until packed_int < 1
	return unpacked_t
	end

end
--[[ USE:
local packed = un_pack_integers(t, 2) -- t contains the integers, storing 2 digit integers
local unpacked_t = local packed = un_pack_integers(t, 2, packed) -- t arg is irrelevant, unpacking 2 digit integers
OR
local packed, length = un_pack_integers(t) -- t contains the integers
local unpacked_t = local packed = un_pack_integers(t, length, packed) -- t arg is irrelevant
]]



function calculate_median_value(array_t)
-- array_t is array of values
local val

table.sort(array_t, function(a,b) return a < b end) -- make sure that the sequence is sorted in ascending order
local idx = (#array_t+1)/2 -- adding 1 allows dividing odd length (number of values) without remainder and thus figuring out the center index, e.g. in table 1,2,3 the center index is 2 which will be calculated by dividing 4 (3+1) by 2
-- if the length (number of values) is even, e.g. 1,2,3,4, dividing 5 (4+1) by 2 will produce 2.5
-- which in turn will point at two incices 2 and 3 which share the center
	
	if (#array_t+1)%2 == 0 then -- OR math.floor(idx) == idx // divided without remainder, i.e. odd number sequence
	val = array_t[idx]
	else -- even number sequence, calculate between two cenral values
	val = (array_t[math.floor(idx)] + array_t[math.ceil(idx)])/2
	end

return val

end


function split_combine_64bit_integer(hi, lo)
	if not lo then
	local hi = math.floor(num / 2^32)  -- Extract upper 32 bits
	local lo = num%2^32              -- Extract lower 32 bits
	return hi, lo
	else
	return hi * 2^32 + lo  -- Combine back into a 64-bit integer
	end
end


function floats_are_equal(numA, numB)
-- due to floating point rounding errors and long fractional parts
-- it's impossible to reliably evaluate equality by direct comparison between 
-- two floating point numbers because numbers functionally the same 
-- will differ in minute fraction, 
-- this is always an ussue with notes length, which seems to be related 
-- to their measurement in quarter note units, and value in quarter notes
-- ends up being slightly larger than the value it's supposed to be equal to
-- so a way to compare them is by converting them into strings, tostring()
-- function automatically rounds long floating point numbers of up to about
-- 15 decimal places which seems enough for reliable comparison because the
-- difference is much smaller
return tostring(numA/numB) == '1.0' -- the fractional part of the quotient of the division is so small that after being rounded by conversion into string all which remains of it is decimal zeros
-- OR
-- local numA, numB = numA..'', numB..''
-- numA == numB or numA == numB:gsub('%.0','') or numA:gsub('%.0','') == numB -- simple comparison works BUT craps out at whole numbers if there's a trailing decimal zero in one of them, hence the gsub
end



function get_greatest_smallest_value1(want_smallest, field, ...)
-- if vararg is a list of tables, nested tables aren't supported;
-- field is either integer representing index in an indexed table
-- or string represending field in an associative array;
-- to evaluate values in nested tables inside several indexed tables
-- this function must be first applied to nested tables, 
-- then to the resulting values of all tables;
-- also useful for determining the longest indexed table as well out of several,
-- to make the function return table pointer along with the value
-- embed the table length in its field, see embed_table_length functions
local t = {...}
Msg(t,'t')
	local function select_source(s,field)
	return field and type(s) == 'table' and s[field] or s
	end
table.sort(t, function(a,b) local a, b = select_source(a,field), select_source(b,field)
return want_smallest and a < b or not want_smallest and a > b end)
local tbl = type(t[1]) == 'table'
return field and tbl and t[1][field] or t[1], field and tbl and t[1] -- return value and the table it belongs to if table values were sorted
end

function get_greatest_smallest_value2(want_smallest, field, ...)
-- if vararg is a list of tables, nested tables aren't supported;
-- field is either integer representing index in an indexed table
-- or string represending field in an associative array;
-- to evaluate values in nested tables inside several indexed tables
-- this function must be first applied to nested tables, 
-- then to the resulting values of all tables;
-- also useful for determining the longest indexed table as well out of several,
-- to make the function return table pointer along with the value
-- embed the table length in its field, see embed_table_length functions
local t = {...}
local compare = want_smallest and math.min or math.max
local value = want_smallest and math.huge or math.huge*-1
local index
	for k, v in ipairs(t) do
	local v = field and v[field] or v
	value = (want_smallest and v < value or not want_smallest and v > value) and v or value
-- OR
--	value = compare(v, value)
	index = value == v and k or index
	end
return value, type(t[index]) == 'table' and t[index] -- return value and the table it belongs to if table values were sorted
end



--================================ M A T H  E N D ===================================


--=========================== S T R I N G S  S T A R T ==============================

'✘ ✗ ✔ ✓'

--[[

CHARACTERS WHICH CAN BE USED TO DELIMIT MENU ITEMS

-- empty space, dot . , underscore _ , hyphen - , horiz line ─ ,
-- double oblique hyphen ⸗ , colons :, ꞉, ⁞,
-- equal sign/double horizontal line = or ꞊ or ═ ,
-- almost equal ≈ , identical to ≡ , ellipsis … , double dot ‥ ,
-- light vertical │ , double vertical line ‖ , broken bar ¦ ,
-- asterisk *, tilde ~, Greek ῀, multiply × , primes ′ , ″ , ‴ ,
-- single quote ' , double angle quote », slash ⁄ or / , sharp ♯ ,
-- right arrowhead ˃ (U+02C3), Greek capical Xi Ξ ,
-- any of ░ ▒ ▓ ;

]]


local function str(...)
return tostring(...)
end


-- add spaces
function space(n) -- number of repeats, integer
local n = not n and 0 or tonumber(n) and math.abs(math.floor(n)) or 0
return string.rep(' ',n)
-- OR
-- return (' '):rep(n)
end

-- same
function Rep(x) -- repeat space x times, to be added to the Message box text
local x = not n and 0 or tonumber(x) and math.abs(math.floor(x)) or 0
return string.rep(' ', x)
-- OR
-- return (' '):rep(x)
end


function Esc(str)
	if not str then return end -- prevents error
-- isolating the 1st return value so that if vars are initialized in a row outside of the function the next var isn't assigned the 2nd return value
local str = str:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0')
return str
end


function literalize(str) -- same as Esc()
    return str:gsub(
      "[%(%)%.%%%+%-%*%?%[%]%^%$]",
      function(c)
        return "%" .. c
      end
    )
end



-- alternative to string.gmatch if all captures are identical
function captures_to_table(str, patt, count)
-- patt is regular expression
-- preverably with lenient reapeat operators -, ?, *, which allow capture of empty string
-- because if one capture is nil all the rest will be nil as well
	if count > 32 then return end -- string lib only supports up to 32 captures
return {str:match(Esc(patt):rep(count))}
end



function replace(str, what, with)
-- https://stackoverflow.com/a/29379912/8883033
    what = string.gsub(what, "[%(%)%.%+%-%*%?%[%]%^%$%%]", "%%%1") -- escape pattern
    with = string.gsub(with, "[%%]", "%%%%") -- escape replacement
    return string.gsub(str, what, with)
end


function remove_all_bar_some(str, ...)
-- the elipsis represents both literals and char classes
-- mind special characters which must be escaped as arguments
local keep = {...}
local str = str:gsub('.',
			function(c)
				for _, char in ipairs(keep) do
					if c:match(char) or c == char
					then return c end
				end
			return '' end
			)
--[[ OR
-- the table doesn't have to be passed as argument
-- because gsub doesn't seem to support functions with more than 1 argument
	local function thin_out(c)
		return function(c)
			for _, char in ipairs(keep) do
				if c == char or c:match(char)
				then return c end
			end
		return ''
		end
	end
local str =	str:gsub('.', thin_out(c))
]]
return str
end
--[[USE:
remove_remove_all_bar_some(str, '%.', '%d+') -- remove all bar dots and numerals
]]


function spaceout(str)
return str:gsub('.', '%0 '):match('(.+) ') -- space out text, trimming trailing space
end
-- OR
local name = name:gsub('.', '%0 '):match('(.+) ') -- space out text, trimming trailing space


function starts_with(str, start)
-- http://lua-users.org/wiki/StringRecipes
   return str:sub(1, #start) == start
end

function ends_with(str, ending)
-- http://lua-users.org/wiki/StringRecipes
   return str:sub(-#ending) == ending
end


function strip_spaces(str) -- keeps chars and punctuation, strips leading and trailing spaces and control chars
--return str:match('[%w%p]?.*[%w%p]*') -- accommodating both mutlti- and single char string
-- OR
-- return str:match('[%w%p]*[%w%p]') -- accounting for a single character in the string
return str:match('^%s*(.-)%s*$') -- seems more reliable
-- OR
-- return str:match('(%S.-)%s*$')
-- OR
-- return str:match('%S.+%S') -- returns nil if empty string
end



function trunc_hanging_dec_zero(num)
-- in integers represented as floats, i.e. 0.0
-- for convertion into string
local trunc = math.floor(num)
	if trunc == num then return trunc
	else return num
	end
-- OR
-- return num:match('(.+)%.) -- less reliable in case num is genuine float
-- OR
-- string.format('%d',num) // string.format('%i',num) -- less reliable in case num is genuine float, in which case the function will error out
end



function split_into_lines(input, want_empty_lines)
-- add trailing line break otherwise the last line
-- won't be captured with the pattern in the gmatch loop below
--local input = input:match('.+\n%s*$') or input..'\n' -- VERY EXPENSIVE WITH HUGE STRINGS
local input = input:sub(-1):match('\n') and input..'\n' or input -- OR input:sub(-1) ~= '\n'
local t = {}
	for line in input:gmatch('(.-)\n') do -- respects empty lines; '[^\n]+' to skip empty lines
		if want_empty_lines and #line:gsub(' ','') == 0 -- OR not line:gsub['[^%s]+'] / not line:gsub['%S']
		or not want_empty_lines then
		t[#t+1] = line
		end
	end
return t
end



-- split string to multi-line by character count represented with line_len
function split_into_multiple_lines(str, line_len) -- str is string, line_len is integer
local line_len = math.floor(line_len) -- prevent decimals
local w_cntr = 0
local i = 0
local split_str = ''
local linebreak
	for w in str:gmatch('([^%s]+)') do -- only complete words
		if w_cntr >= line_len then linebreak, w_cntr = '\n', 0 -- reset counter
		else linebreak, w_cntr = ' ', w_cntr + #w end
	i = i + 1 -- just to prevent adding leading space to the very 1st line
	linebreak = i == 1 and '' or linebreak -- same
	split_str = split_str..linebreak..w
	end
return split_str
end



function split_line_by_capture_count(line, pattern, count, backwards)
-- pattern can be lireral string or regular expression, if it's literal
-- make sure to escape it with Esc()
-- splits the line as soon as the number of found captures equals count arg
-- returns nil if count arg value exceeds the total of found captures
-- relies on Esc() function
-- if backards is true counting and line parsing is done from the end
local counter = 0
local start = backwards and #line or 1
local fin = start
	repeat
	local window = line:sub(start, fin)
	local capt = window:match(pattern)
		if capt then
		counter = counter+1
			if counter == count then
				if backwards then
				return start == 1 and line or line:sub(1, start-1), -- accounting for cases when the number of captures on the line is equal to count arg to begin with
				start == 1 and '' or start <= #line and line:sub(start, #line)
				else
				return line:sub(1, fin), fin < #line and line:sub(fin+1, #line)
				end
			end
		start = backwards and start-#capt-1 or start+#capt+1
		fin = backwards and fin-#capt-1 or fin+#capt+1
		else -- advance or retreat by one position
		start = backwards and start-1 or start
		fin = backwards and fin or fin+1
		end
	until backwards and start <= 0 or fin >= #line
end



function split_lines_by_length(max_len, lines_t)
	for i = #list_t, 1, -1 do -- can be done in direct loop as well, in which case the index for new entries would be calculates as follows 'idx = not idx and i or idx+1'
	local line = list_t[i]
		if #line:gsub('[\128-\191]','') > max_len then -- accounting for non-ANSI characters
		local collected, idx
			for char in line:gmatch('.') do
				if collected and #collected:gsub('[\128-\191]','') == max_len then
				idx = not idx and i+1 or idx+1 -- insert each next line chunk at next table index, i.e. downstream of the original line index
				table.insert(list_t, idx, collected)
				collected = nil -- reset, to be able to start collecting next line chunk
				end
			collected = collected and collected..char or char
			end
			if collected then -- if after splitting there's outstanding chunk shorter than max_len, add it to the table
			table.insert(list_t, idx+1, collected)
			end
		table.remove(list_t, i) -- remove the old non-split entry
		end		
	end
return lines_t
end




function Are_Multiple_Captures(chunk, str) -- relies on Esc() function
local cnt = 0
	for w in chunk:gmatch(Esc(str)) do
		if w then cnt = cnt+1 end
	end
return cnt > 1, cnt > 1 and cnt -- boolean and integer
end



function count_captures(str,capt) -- capt is a pattern or a literal string
local cntr = str
local cntr = {cntr:gsub(capt, '%0')}
return cntr[2] -- 2nd return value of gsub is the number of replaced captures
-- OR
-- local _, cnt = str:gsub(capt,'')
-- return cnt
end
-- OR
-- select(2, str:gsub(capt,''))



function collect_captures(source_str, pattern, capture_idx)
-- same as string.gmatch
-- if capture at specific index is required specify capture_idx,
-- if specified, the gsub loop will only run up to such index
-- and the table will only include captures up to and including
-- the target capture
local t = {}
local i = 0
local source_str = source_str:gsub(pattern, 
function(c) i=i+1; t[i] = c end, capture_idx or #source_str)
return t, t[#t] -- or t[i], the 2nd return value is the caprure at index
end



function insert_string_at_specific_position1(src_str, insert_str, pos_idx, move)
-- relies on Esc() function
-- returns nil if pos_idx is greater than src_str length
-- move is boolean to delete the insert_str from its current location in the src_str,
-- only reliable if there's single instance of the insert_str
	for i = 1, #src_str do
	local str = src_str:sub(1,i)
		if i == pos_idx-1 then
		local insert_str_esc = Esc(insert_str)
		return (move and str:gsub(insert_str_esc, '',1) or str)..insert_str
		..(move and src_str:sub(i+1):gsub(insert_str_esc, '',1)	or src_str:sub(i+1) )
		end
	end
end
-- EXAMPLE:
-- insert_string_after_specific_position1('You see dogs and cats', ', humans', 13)
-- returns 'You see dogs, humans and cats'


function insert_string_at_specific_position2(src_str, insert_str, pos_idx, move)
-- relies on Esc() function
local insert_str_esc = Esc(insert_str)
local str1, str2 = src_str:sub(1,pos_idx-1), src_str:sub(pos_idx,#src_str)
return (move and str1:gsub(insert_str_esc, '',1) or str1)..insert_str
..(move and str2:gsub(insert_str_esc, '',1) or str2)
end



function count_specific_chars(str, char) -- or clusters
-- doesn't account for multibyte characters
local i, cnt = 0, 0
	while i < #str do -- reverse loop
		if str:sub(#str-i,#str-i) == char then
		cnt = cnt+1 end
	i=i+1
	end
	--[[ -- forward loop
	while i <= #str do
		if str:sub(i,i) == char then
		cnt = cnt+1 end
	i=i+1
	end
	]]
return cnt
end


function remove_Nth_capture(str,capt,N) -- removes with adjacent punctuation marks
-- 1. if not N then N is 1
-- 2. if no captures or N is 0 or greater than the number of captures returns original string
local N = N and tonumber(N) and math.abs(math.floor(N)) -- validate N
	if not N then N = 1 end
local cntr = 0
local str_new = ''
	for w1, w2 in str:gmatch('(%w*)([%p%s%c]*)') do -- the patterns are a word/number followed by space/punctuation/special characters
	cntr = (N ~= cntr and w1 == capt or N == cntr) and cntr+1 or cntr
		if N ~= cntr then str_new = str_new..w1..w2 end
	end
return str_new, str ~= str_new -- 2nd val is boolean showing if any changes were made
end
-- see advanced USE CASES after replace_Nth_capture2() function below


function replace_Nth_capture1(src_str,capt,repl_str,N)
-- 1. if not N then N is 1
-- 2. if no captures or N is 0 or greater than the number of captures returns original string
-- if the 3d arg (repl_str) isn't a string then returns orig string and boolean to indicate no changes
local N = N and tonumber(N) and math.abs(math.floor(N)) -- validate N
	if not N then N = 1 end
local cntr = 0
local str_new = ''
	if repl_str and not type(repl_str) then return str, false end
	for w1, w2 in src_str:gmatch('(%w*)([%p%s%c]*)') do -- the patterns are a word/number followed by space/punctuation/special characters
	cntr = (N ~= cntr and w1 == capt or N == cntr) and cntr+1 or cntr
		if N == cntr then w1, w2 = repl_str..w2, '' end
	str_new = str_new..w1..w2
	end
return str_new, str ~= str_new -- 2nd val is boolean showing if any changes were made
end
-- see advanced USE CASES after replace_Nth_capture2() function below


function remove_replace_Nth_capture(src_str,capt,N,repl_str)
-- if the last arg is omitted or isn't a string then works for removal
-- 1. if not N then N is 1
-- 2. if no captures or N is 0 or greater than the number of captures returns original string
local N = N and tonumber(N) and math.abs(math.floor(N)) -- validate N
	if not N then N = 1 end
local repl_str = repl_str and type(repl_str) == 'string' and repl_str
local cntr = 0
local str_new = ''
	for w1, w2 in src_str:gmatch('(%w*)([%p%s%c]*)') do -- the patterns are a word/number followed by space/punctuation/special characters
	cntr = (N ~= cntr and w1 == capt or N == cntr) and cntr+1 or cntr
		if repl_str then
			if N == cntr then w1, w2 = repl_str..w2, '' end
		str_new = str_new..w1..w2
		elseif N ~= cntr then
		str_new = str_new..w1..w2
		end
	end
return str_new, str ~= str_new -- 2nd val is boolean showing if any changes were made
end
-- see advanced USE CASES after replace_Nth_capture2() function below


function replace_Nth_capture2(src_str, patt, repl_str, N) -- patt is either a literal string or a pattern; N is ordinal number of the capture to be replaced, if not N or 0 then N is 1
local N = N and tonumber(N) and math.abs(math.floor(N))
	if not N or N == 0 then N = 1 end
local i = 1
local st, fin, capt
local capt_cnt = 0
	while i < #src_str do
	-- OR
	--repeat
	st, fin, capt = src_str:find('('..patt..')', i) -- in order to return the capture string.find requires explicit formatting of the pattern or literal string as a capture
		if capt then capt_cnt = capt_cnt + 1 end
		if capt_cnt == N then break end
	i = fin + 1
	--OR
	--until i > #src_str -- > because of fin + 1, doesn't happen with 'while' operator
	end
return N > capt_cnt and src_str or src_str:sub(1, fin-#capt)..repl_str..src_str:sub(fin+1) -- if N is greater than the number of captrures the original string is returned otherwise the one with substitutions
end

-- USE CASES
local src_str = 'test one test one one test'
local repl_str = 'ffsds'

	--1)
	for _, v in ipairs({1,6}) do -- replaces 1st and 6th captures of any word
	src_str = replace_Nth_capture(src_str, '%a+', repl_str, v)
	end
	-- result: 'ffsds one test one one ffsds'

	--2)
	for _, v in ipairs({{1,2}}) do -- replaces 1st and 3d instances of the word 'test' // every next instance number must be 1 less (2 instead of 3) because their number is being reduced as replacement continues, e.g. to replace 1st and 2nd instances {1,1} must be used
	src_str = replace_Nth_capture(src_str, 'test', repl_str, v)
	end
	-- result: 'ffsds one test one one ffsds'

	--3)
	for patt, repl_str in pairs({test = 'test1', one = 'one1'}) do -- replaces 3d instance of 'test' with 'test1' and 3d instance of 'one' with 'one1'
	src_str = replace_Nth_capture(src_str, patt, repl_str, 3)
	end
	-- result: 'test one test one one1 test1'

	--4)
	for patt, v in pairs({test = {[2] = 'test1'}, one = {[3] = 'one1'}}) do -- replaces 2d instance of 'test' with 'test1' and 3d instance of 'one' with 'one1'
		for N, repl_str in pairs(v) do
		src_str = replace_Nth_capture(src_str, patt, repl_str, N)
		end
	end
	-- result: 'test one test1 one one1 test'

	--5)
	for _, t in ipairs({ {one1 = 1}, {one2 = 1} }) do -- raplaces 1st instance of 'test' with 'one1' and 2nd instance of 'test' with 'one2'; for N values see use case 2) above
		for repl_str, N in pairs(t) do
		src_str = replace_Nth_capture(src_str, 'test', repl_str, N)
		end
	end
	-- result: 'one1 one one2 one one test'


function replace_capture_by_capture_number1(str, what, with, ...)
-- OVERKILL, see versions 2 and 3 below
-- the elipsis (vararg) represents a list of integers
-- denoting the number of the what instance in the str
-- the number is not global for the string but
-- if the what instance number is out of scope or it isn't found,
-- returns the original str
-- this type of replacement is impossible with string.gsub() --- WRONG, see versions 2 and 3 below
local inst_t = {...}
local t = {}
local i = 1
	while i < #str do -- collect indices at which the what instances start
	local s, e = str:find(what, i)
		if s then t[#t+1] = s
		i = e+1
		else
		i = i+1
		end
	end
table.sort(inst_t) -- in case the what instance numbers weren't passed in ascending order
	for i = inst_t[#inst_t], 1, -1 do -- iterating backwards from the greatest ordinal number
	local idx = inst_t[i]
		if t[idx] then -- instance number from the arguments matches key in the table holding indices of the what instances
		str = str:sub(1,t[idx]-1)..with..str:sub(t[idx]+#what)
		end
	end
return str
end
-- EXAMPLE
-- local str = 'one two one two one two, two'
-- local str = replace_capture_by_capture_number(str, 'two', 'three', 1, 3, 4) -- replaces 1st, 2nd and 4th instances of 'two' with 'three'


function replace_capture_by_capture_number2(str, what, with, ...)
-- the elipsis (vararg) represents a list of integers
-- denoting the number of the what instance in the str
-- if the what instance number is out of scope or it isn't found,
-- returns the original str
local t = {...}
local i = 0
	local function repl()
	i=i+1
		for _, v in ipairs(t) do
			if v == i then return with end
		end
	end
local str = str:gsub(what, repl)
return str
end


function replace_capture_by_capture_number3(str, what, with, ...)
-- the elipsis (vararg) represents a list of integers
-- denoting the number of the what instance in the str
-- if the what instance number is out of scope or it isn't found,
-- returns the original str
local t, t2 = {...}, {}
-- construct table where the 'what' indices are keys rather than values
	for k, v in ipairs(t) do
	t2[v] = '' -- placeholder
	end
local i = 0
	local function repl()
	i=i+1
		if t[i] then return with end
	end
local str = str:gsub(what, repl)
return str
end



function replace_captures_with_table_vals1(str, capt, t)
-- each capture is replaced with the next table value
-- e.g. in the str 'test test test test', capt 'test'
-- and t {1,2,3,4} the result will be '1 2 3 4'
local i = 0
local str = str:gsub(capt, function() i=i+1 return t[i] end)
return str
end


function replace_captures_with_table_vals2(str, capt, t)
-- each capture is replaced with the next table value
-- e.g. in the str 'test test test test', capt 'test'
-- and t {1,2,3,4} the result will be '1 2 3 4'
local str = str
	for k, v in ipairs(t) do
	str = str:gsub(capt, v, 1)
	end
return str
end



function re_store_identical_captures(str, pattern, t)
-- temporarily replace capture with a numbered placeholder
-- and then restore the original substring
-- pattern can be lireral string or regular expression, if it's literal
-- make sure to escape it with Esc()
local placeholder = [[placeholder]]:upper()reverse()
	if not t then -- store
	local t = {}
		for w in str:gmatch(pattern) do
			if w then
			t[#t+1] = w
			end
		end
	-- numbered placeholders allow managing them selectively
	local i = 0
	str = str:gsub(pattern, function() i=i+1 return ' '..placeholder..i..' ' end)
	--[[ OR
	local t, str_tmp = {}, str -- use copy line_tmp to traverse the input string to allow formatting the original string during the loop without lengthening the loop and complicating the capture
		for w in str:gmatch(pattern) do
			if w then
			t[#t+1] = w
			w = Esc(w)
			str = str:gsub(w, ' '..placeholder..#t..' ', 1) -- only 1 replacement per gsub run to prevent replacing identical captures with identically numbered placeholders
			end
		end
	]]
	return str, t
	elseif t and #t > 0 then -- restore
	local s = ' '
		for i = 1, #t do
		local repl = t[i]:gsub('%%','%%%%')
		str = str:gsub(s..placeholder..i..s, repl) -- only found placeholders are restored
		end
	--[[ OR
		for k, v in ipairs(t) do
		local v = v:gsub('%%','%%%%')
		line = str:gsub(s..placeholder..k..s, v) -- only found placeholders are restored
		end
	]]
	return str
	end
end
-- USE:
-- local t = re_store_identical_captures(str, pattern) -- t arg is nil // store
-- re_store_identical_captures(str, pattern, t) -- restore
-- str must be the same on both occasions



-- !!!! OVER 26 captures may make the system freeze (could also depend on the length of each capture) // same with string.find() whose limit is 32 captures https://www.gammon.com.au/scripts/doc.php?lua=string.find
function list_2_table1(str, pattern, delimiter) -- pattern e.g. '(%d+);?' to extract semicolon delimited numbers; if using the included tables pattern and delimiter must be numbers else delimiter arg isn't needed
local pattern = {'(%a+)', -- mixed case words = 1
				 '(%l+)' -- only lower case words = 2
				 '(%u+)' -- only upper case words = 3
				 '(%-?%d+)', -- integers, uncluding signed =  4
				 '(%-?[%d%.]*)' -- decimal numbers, uncluding signed = 5
				-- hexadecimal could be added
				}
local delimiter = { ',' -- = 1
					'%.' -- a dot = 2
					':' -- = 3
					';' -- = 4
					'/' -- = 5
					'\\' -- = 6
					'[\\/%.,:;]+' -- any of the above = 7
				  }
local counter = str -- a safety measure to avoid accidental ovewriting the orig. string, although this shouldn't happen thanks to %0
local counter = {counter:gsub(pattern, '%0')} -- 2nd return value is the number of replaced captures
local t = {str:match(string.rep(pattern, counter[2]))} -- captures the pattern as many times as there're pattern repetitions in the string
-- OR IF USING TABLES:
-- counter = {counter:gsub(pattern[pattern]..delimiter[delimiter], '%0')}
-- t = {str:match(string.rep(pattern[pattern]..delimiter[delimiter], counter[2]))}
return t, counter[2] -- second return value holds number of captures
end


-- !!!! OVER 26 caprures may make the system freeze (could also depend on the length of each capture) // same with string.find() whose limit is 32 captures https://www.gammon.com.au/scripts/doc.php?lua=string.find
function list_2_table2(str, pattern) -- pattern e.g. '(%d+);?' to extract semicolon delimited numbers;
local counter = str -- a safety measure to avoid accidental ovewriting the orig. string, although this shouldn't happen thanks to %0
local counter = {counter:gsub(pattern, '%0')} -- 2nd return value is the number of replaced captures
local t = {str:match(string.rep(pattern, counter[2]))} -- captures the pattern as many times as there're pattern repetitions in the string
return t, counter[2] -- second return value holds number of captures
end


-- to process user input
-- to be used within loop as get_index_from_range_or_list1(str, i+1), if true, i+1 or value which corresponds to it will be saved to a table
function get_index_from_range_or_list1(str, tr_idx) -- str is a string containing range 'X-X' or list 'X, X, X, X' of numerals
local min, max = str:match('(%d+)%s*%-%s*(%d+)') -- the syntax is X-X // range
	if (min and max)
	and (tr_idx >= min+0 and max+0 >= tr_idx) -- range // +0 converts string to number to match tr_idx data type
	then return true
	elseif str:match('%d+,') then -- list // additional condition to prevent falling back on this routine when previous expression returns nils, because this will return true at least once since in the list the 1st numeral will always be found
		for idx in str:gmatch('%d+') do -- list
			if tonumber(idx) == tr_idx then return true end
		end
	end
end


-- to process user input
-- to be used within loop as get_index_from_range_or_list2(str, i+1), if true, i+1 or value which corresponds to it will be saved to a table
function get_index_from_range_or_list2(str, num) -- str is a string containing range 'X-X' or list 'X X X X' of numerals, the type of separator doesn't matter
local min, max = str:match('(%d+)%s*%-%s*(%d+)') -- the syntax is X-X // range
	if (min and max)
	and (num >= min+0 and max+0 >= num or num >= max+0 and min+0 >= num) -- range // +0 converts string to number to match num data type // allows reversed ranges, e.g. 10 - 1
	then return true
	elseif str:match('%f[%d]'..num..'%f[%D]') then return true -- list
--[[OR
	elseif str:match(num) then -- list
		for w in str:gmatch('%d+') do -- without the loop parts of composite numbers will produce truth as well in str:match(num), i.e. 16 will be true 3 times as 1, 6 and 16 // the loop allows respecting separators
			if tonumber(w) == num then return true end
		end
	]]
	end
end

--[[ EXAMPLE

	for i = 1, 16 do
		if get_index_from_range_or_list(output, i) then -- output is a string containing range or list
		ch_t[#ch_t+1] = i
		end
	end

	if #ch_t == 0 or #ch_t == 1 and ch_t[1]-1 == cur_chan -- -1 to conform to 0-based system used in cur_chan value
	then
	local err = #ch_t == 0 and 'No valid target MIDI channel has been specified.' or 'The target MIDI channel is the same as the current one.'
	local resp = r.MB(err, 'ERROR', 5)
		if resp == 4 then autofill = move and move..output or output goto RETRY
		else return r.defer(function() do return end end)
		end
	end

]]


function validate_search_term1(input_str, target_str, exact) -- exact is boolean
-- relies on Esc() function
	if exact then return target_str:match('^%s*('..Esc(input_str)..')%s*$') end
local cnt = 0
local truth_cnt = 0
	for w in input_str:gmatch('[%w%p]+') do
		if w then cnt = cnt+1 end
		if target_str:match(Esc(w)) then truth_cnt = truth_cnt+1 end
	end
return cnt > 0 and cnt == truth_cnt -- all words/punctuation marks of the search term found in the target_str; preventing equality of zeros
end


local function validate_search_term2(input_str, target_str, exact) -- exact is boolean
-- relies on Esc() function
	if exact then return target_str:match('^%s*('..Esc(input_str)..')%s*$') end
local loop_run
	for w in input_str:gmatch('[%w%p]+') do
	loop_run = 1
		if w and not target_str:match(Esc(w)) then return end
	end
return loop_run -- if nothing is found the loop doesn't start, if does start and is not exited preemptively, then search term was found
end


function Convert_Text_To_Menu(text, max_line_len, indent)
-- max_line_len is integer, determines length of line as a menu item, 70 seems optimal;
-- indent is both boolean and integer to indent all lines following the first paragraph line
-- which is useful when the first line starts with a number in the list to look like so
--[[
1. Lorem ipsum dolor sit amet, consectetur adipiscing elit,
   sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
   Ut enim ad minim veniam.
]]
-- to force new lines in such paragraph while keeping the identation the new line
-- must be indented in the source text, e.g.
--[[
1. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
     Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
]]
-- additional manual tweaking of the source text may be required,
-- as integer 'indent' arg determines the length of the indent made of empty spaces
-- 5 seems optimal;
-- if ommitted no indentation is created;
-- relies on multibyte_str_len() function (see below) to accurately count UTF-8 characters; can be removed if the text is sure to only contain basic Latin, in which case the line 'multibyte_str_len(text_clean)' can be replaced with '#text_clean'


local text = text:gsub('|', 'ㅣ') -- replace pipe, if any, with Hangul character for /i/ since its a menu special character, vertical line '│' (Unicode 2502), can be used indtead of Hangul
local text = text:gsub('&', '+') -- convert ampersand to + because it's a menu special character used as a quick access shortuct hence not displayed in the menu
local text = text:gsub('\n', '|')-- OR text:gsub('\r', '|') // convert user line breaks into pipes to divide lines by creating menu items, otherwise user line breaks aren't respected; multiple line break is created thanks to the space between pipes originally left after each \n character, if there's none a solid line is displayed instead or several thereof starting from 3 pipes and more
local t = {}
	for w in text:gmatch('[%w%p\128-\255]+[%s%p]*') do -- split into words + trailing space if any; [%w%p] makes sure that words with apostrophe <it's>, <don't> aren't split up; [%s%p] makes menu divider pipes and special characters (!#<>), if any, attached to the words because they're punctuation marks (%p); accounting for utf-8 characters
		if w then
		t[#t+1] = w end
	end

local text, menu, indent = '','', indent and (' '):rep(indent) or ''
	for k, w in ipairs(t) do
	local text_clean = (text..w):gsub('|','') -- doesn't seem to make a difference with or without the pipe
		if multibyte_str_len(text_clean) > max_line_len or text:match('(.+)|') then -- dump text var to menu var and reset text, if not dumped immediately when the text var ends with line break then when text var will exceed the length limit containing a user line break, hanging words will appear after such line break because they will now be included in the menu var and next time length of text var will be evaluated without them, e.g.:
		-- | text = 'The generated Lorem Ipsum is therefore | always' -- assuming the string exceeds the length limit, 'always' will be left hanging ...
		-- | menu = menu..'The generated Lorem Ipsum is therefore | always'..pipe -- line break is created after 'always' with pipe var, next time text var will be added after the pipe, so the result will look like:
		-- | 'The generated Lorem Ipsum is therefore
		-- | always
		-- | free from repetition, injected humor
		-- whereas 'always' has to be grouped with 'free from repetition, injected humor'
		local pipe = text:match('(.+)|') and '' or '|'..indent -- when the above condition is true because text ends with pipe the pipe is user's line break so no need to add another one, otherwise when condition is true because the line length exceeds the limit pipe is added to delimit lines as menu items
		text = #pipe == 0 and text:gsub('[!#<>]',' %0') or text -- make sure that menu special characters at the beginning of a new line (menu item) are ignored prefacing them with space; when string stored in the text var has pipe in the end, if ther're any menu special characters in the user text, they will follow the pipe due to the way user text is split into words at the beginning of the function, so if there're any specal characters placed at the beginning of a new line in the user text they will necessarily be found in the text var right next to the new line character converted at the beginning of the function into pipe to conform to the menu syntax and such new line character is attached to the preceding line
		menu = menu..text..pipe -- between menu and text pipe isn't needed because it's added after the text and next time will be at the end of the menu
		text = ''
		end
		if k == #t then
		menu = ' |'..menu..text..w..'| |' -- add padding
		else
		text = text..w
--Msg(text) -- interesting to watch
		end
	end
local tmp = menu
local _, line_cnt = tmp:gsub('|+','') -- count pipe clusters which format lines to find out the number of lines in case there'll be a need to add genuine menu items after the text, in which case their index will be equal line_cnt+n returned by gfx.showmenu()
return menu, line_cnt
end


-- https://www.charset.org/utf-8

function multibyte_str_len(str)
-- https://stackoverflow.com/questions/43125333/lua-string-length-cyrillic-in-utf8
-- https://stackoverflow.com/questions/22129516/string-sub-issue-with-non-english-characters
-- https://www.splitbrain.org/blog/2020-09/03-regexp_to_match_multibyte_character
-- https://stackoverflow.com/questions/9356169/utf-8-continuation-bytes
-- https://www.freecodecamp.org/news/what-is-utf-8-character-encoding/
-- count string length in characters regardless of the number of bytes they're represented by, works for Korean, Japanese, Chinese
-- Lua string library counts bytes, and UTF-8 characters produce inaccurate count because they're multi-byte, consisting also of leading (leader) bytes (192-254) and continuation (trailing) bytes (128-191), the continuation bytes must be discarded so only the basic ASCII (0-127) remain
-- In Lua 5.3+, use utf8.len
return #str:gsub('[\128-\191]','') -- OR #str:gsub('[\x80-\xbf]','') -- same in HEX
end


function utf8_len(str)
-- REAPER stock lyrics.lua
local a = utf8.len(str);
  if a == nil then return str:len() end -- or return #str
  return a;
end


-- this will overwrite the stock function in the global environment
-- doesn't affect # operator
string.len = 	function(self) -- self here is the source string
					return #self:gsub('[\128-\191]','')
					end
-- OR
function string.len(self) -- 'local' scope produces error
return #self:gsub('[\128-\191]','')
end
-- USE NORMALLY
-- str:len()

-- OR
function utf8_len2(str)
-- borrowed and streamlined from REAPER stock lyrics.lua
return utf8.len(str) or #str -- utf8.len() returns false if invalid bytes hence the fallback value
end


-- reverse non-ASCII string
-- this will overwrite the stock function in the global environment
-- supports ASCII strings as well of course
function string.reverse(self) -- self here is the source string
local str_reversed = ''
	for char in self:gmatch('[\192-\255]*.[\128-\191]*') do
	str_reversed = char..str_reversed
	end
return str_reversed
end
-- USE NORMALLY
-- str:reverse()



-- iterate over a UTF-8 string by character
-- https://stackoverflow.com/questions/22129516/string-sub-issue-with-non-english-characters
for c in str:gmatch(".[\128-\191]*") do
-- OR for c in str:gmatch('[\192-\255]*.[\128-\191]*') do -- with leading bytes
-- DO STUFF
end


function utf8_chars_to_bytes(str, a, b)
-- REAPER stock lyrics.lua
a = utf8.offset(str,a)
b = utf8.offset(str,b)
  if a == nil then a = str:len()+1 end
  if b == nil then b = str:len()+1 end
  if b < a then return b,a end
  return a,b
end


function format_time(US_order, _12_hour, Isr_date, Roman_month, dot) -- all booleans
-- US_order - month first
-- _12_hour - 12 hour cycle + AM/PM
-- Isr_date - zeros in day and month are discared
-- Roman_month - Roman month number delimited with slash
-- Isr_date and Roman_month are only relevant if US_order is false
-- dot instead of slash, incompatible with Roman_month, the latter has priority
local d = US_order and '%m/%d' or '%d/%m' -- month first
local t = _12_hour and '%I' or '%H'
local period = t == '%I' and (os.date('%H')+0 < 12 and ' AM' or ' PM') or ''
local date = os.date(d..'/%Y '..t..':%M'..period)
	local function roman(str)
	local t = {'I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII'}
	return '/'..t[tonumber(str:match('%d+'))]..' '
	end
	local function isr(str)
		if str:match('0%d/0%d') then return str:gsub('0','')
		elseif str:match('0%d/%d+') then return str:match('%d(%d/%d+/)') -- or str:sub(2)
		elseif str:match('%d+/0%d') then return str:gsub('/0', '/')
		end
	end
-- local date = '02/01/2023 15:29' -- TESTING
local date = not US_order and
(Roman_month and date:gsub('/%d+/', roman) or Isr_date and date:gsub('%d+/%d+/', isr))
or date
local date = not Roman_month and dot and date:gsub('/','.') or date
return date
end


function format_timestr_alt(pos) -- format by adding leading zeros because r.format_timestr() ommits them
-- pos is time in seconds
local stamp = r.format_timestr(pos, '')
return pos/3600 >= 1 and (pos/3600 < 10 and '0'..stamp or stamp) -- with hours
or pos/60 >= 1 and (pos/60 < 10 and '00:0'..stamp or '00:'..stamp) -- without hours
or '00:0'..stamp -- without hours and minutes

end


function magiclines(s)
-- iterate over lines including blank
-- https://stackoverflow.com/questions/19326368/iterate-over-lines-including-blank-lines
	if s:sub(-1)~='\n' then s=s..'\n' end
	return s:gmatch('(.-)\n')
end
--[[ USE:
local s = '' -- some string
	for line in magiclines(s) do
	-- DO STUFF WITH LINE
	end
-- SAME AS:
local s = s:sub(-1)~='\n' and s..'\n' or s
	for line in s:gmatch('(.-)\n') do
	-- DO STUFF WITH LINE
	end
]]


function parse_lines_in_reverse(str)
-- relies on Esc() function
local str = str:sub(1,2):match('.\n') and str or ' \n'..str -- add line break preceded by space before 1st line if absent to ensure 1st line capture with the pattern in use
local line = ''
	repeat
	line = Esc(line)
	-- OR
	-- line = line:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- escape
	line = str:match('.+(\n.-)'..line) -- lines are captured with line break used as an anchor so it might need to be deleted from the capture before storing in a table for instance but keeping the original line var because it's used inside the pattern
		if line then
		-- DO STUFF
--Msg(line:gsub('\n',''))
		else break end
	until not line
-- return STAFF
end



function read_file_in_reverse(file_path, target_str)
-- target_str is the string which when found stops the search
-- relies on Esc()
-- !!!! VERY SLOW because of iteration by 1 byte at a time
local f, mess = io.open(file_path, 'r')
	if mess and mess:match('No such file or directory') then return end
local i, cont = -1
	repeat
	local pos = f:seek('end',i)
	cont = f:read(pos)
		if cont:match(Esc(target_str)) then break end
	i = i-1
	until pos == 1
return cont
end


function hex(s)
-- probably can be used to convert binary data (i.e. image file) after getting it
-- with io.open(path, 'rb') to hex string
-- https://fingercomp.gitbooks.io/oc-cookbook/content/lua/hexify.html
-- see also 'Dump file to string literal.lua' in ReaPack which relies on ReaImGui extension
  return s:gsub(".", function(c)
    return ("%02x "):format(c:byte())
  end):sub(1, -2)

--[[ source https://github.com/ReaTeam/ReaScripts/blob/master/MIDI%20Editor/talagan_OneSmallStep.lua
# Ruby script to convert from png > lua to load binary img for ReaImGui

def png_to_lua(fname)
buf = File.open(fname,"rb").read.unpack("C*").map{ |c| "\\x%02X" % c }.each_slice(40).map{ |s| s.join }.join("\\z\n")
buf = "return \"\\z\n" + buf + "\"\n;\n"
outname = File.basename(fname,".png") + ".lua"
File.open(outname, "wb") { |f| f << buf }
end

png_to_lua("triplet.png")

--]]

end


-- https://stackoverflow.com/questions/13235091/extract-the-first-letter-of-a-utf-8-string-with-lua
-- https://q-syshelp.qsc.com/content/control_scripting/Lua_5.3_Reference_Manual/Standard_Libraries/4_-_Basic_UTF-8_Support.htm
-- iterate over a UTF-8 string
-- UTF-8 code point either begins with a byte from 0 to 127, or with a byte from 194 to 244 followed by one or several bytes from 128 to 191.
-- returns string
for code in str:gmatch("[%z\1-\127\194-\244][\128-\191]*") do
print(code)
end
-- using utf8 library since Lua 5.3
for _, c in utf8.codes(str) do
  print(utf8.char(c))
end
-- OR
-- utf8.charpattern is the string "[\0-\x7F\xC2-\xF4][\x80-\xBF]*" for the pattern to match one UTF-8 byte sequence, equal to "[\0-\127\194-\244][\128-\191]*]"
for w in str:gmatch(utf8.charpattern) do
  print(w)
end


-- punctuation character byte codes [\0-\47\58-\64\91-\96\123-191] -- the pattern range also includes control characters beyond code 127


function is_utf8_1(str)
-- deleting trailing (continuation bytes)
return #str ~= #str:gsub('[\128-\191]','')
end


function is_utf8_2(str)
-- capturing trailing (continuation bytes)
-- returns a string (likely empty) if true and nil if false
return str:match('[\128-\191]')
end


-- see also gmatch_alt in C L O S U R E S


function selective_case_change(str, selection_t, target_case)
-- str is a string containing words which require case change
-- selection_t is a table of words requiring case change
-- target_case is integer, 1 - upper, 2 - lower, if nil, defaults to lower case
-- to add support for non-ASCII characters use convert_case_in_unicode()
-- in 'C O N V E R S I O N S' section of this doc

local change_case = target_case == 1 and upper or target_case == 2 and lower
change_case = change_case or lower()

	for k, v in ipairs(selection_t) do
		if str == v then return str:change_case() end
	-- otherwise parse the entire replace_term in search for the operators
	local i = 1
		repeat
		local st, fin = str:find(v,i)
			-- if the capture is preceded or followed by an alphanumeric character
			-- it's a word containing v so its case doesn't need lowering because it's not a standalone word
			if st and not str:sub(st-1, st-1):match('%w')
			and not str:sub(fin+1, fin+1):match('%w')
			then
			local s = str
			local part1, part2 = st == 1 and '' or s:sub(1,st-1), fin == #str and '' or s:sub(fin+1)
			str = part1..s:sub(st,fin):change_case()..part2 -- reconstruct, gsub is unsuitable because it replaces regardless of whether capture is standalone or nested
			elseif not st then break -- no capture was found
			end
		i = st and fin+1 or i+1
		until not st or i > #str
	end

return str

end


function convert_case_selectively(str, pattern, want_upper)
-- convert to another case selectively
-- pattern can be literal string or a regular expression 
-- whose capture WILL NOT BE CONVERTED;
-- want_upper is boolean, if invalid the string
-- will be converted to lower case;
-- if pattern targets a word, then to make sure that only 
-- standalone capture is spared it must be enclosed between
-- spaces on both sides bar start and end of the string, e.g
-- if not c:match(' '..pattern.' ') and not c:match('^'..pattern..' ') and not c:match(' '..pattern..'$')
return str:gsub(pattern, function(c) 
if not c:match(pattern) then return c:(want_upper and upper() or lower()) end end)
end



function remove_duplicate_words(str)
-- script at https://forum.cockos.com/showthread.php?t=296325

local t = {dups={}, uniq={}}

	for w in str:gmatch('%S') do
		if not t.dups[w] then
		t.uniq[#t.uniq+1] = w
		t.dups[w] = '' -- dummy value
		end
	end

return table.concat(t.uniq, ' ')
end



function construct_table_from_2_lists(list1, list2)
-- list1 and list2 are long literal strings, i.e. enclosed within square brackets
-- where each item occupies exactly one line
-- they should preferably have identical number of lines
local t = {}
local i,ii = 0,0
	repeat
	local st1, fin1, item1 = list1:find('([^\n]+)', i+1)
	local st2, fin2, item2 = list2:find('([^\n]+)', ii+1)
		if st1 and st2 then
		t[item1] = item2
		end
	i,ii = fin1,fin2
	until not st1 or not st2
return t
end



function embellish_string(str, ornam_code_t, want_spaces)
-- ornam_code_t is a table of integers corresponding to indices of keys 
-- holding utf-8 char codes in the below tables
-- want_spaces is boolean to apply the ornament to space char as well;
-- the description is relevant to ornament display in the menu
-- 1 - sparse dashed underline (lower under digits)
-- 2/17 - sparse dotted underline; 4/12 - bold dotted underline; 5 - solid underline; 
-- 6/16 - bold dashed underline; 7 - tilde strikethrough; 8 - dash srtikethrough;
-- 9 - solid line strikethrough; 10/11 - short/long slash srikethrough;
-- 13 - solid bold overline; 14 - tilde overline (lower above digits); 
-- 15 - sold bold underline; 18 - dotted overline which crosses characters at the top;

-- when ornament is applied to spaces its level under/above the line
-- may differ from that applied to characters when displayed in the menu;
-- the level under/above numerals may also differ from the level under/above 
-- alphabetic chars when displayed in the menu;
-- https://www.charset.org/utf-8
local t = {'\xCC\xA0','\xCC\xA3','\xCC\xA4','\xCC\xA5','\xCC\xB2','\xCC\xB3','\xCC\xB4',
'\xCC\xB5','\xCC\xB6','\xCC\xB7','\xCC\xB8','\xCC\xBB','\xCC\xBF','\xCD\x82','\xCD\x87',
'\xCD\x9A','\xDF\xB2','\xDF\xB3'}
--[[ OR
local t = {'\204\160','\204\163','\204\164','\204\165','\204\178','\204\179','\204\180',
'\204\181','\204\182','\204\183','\204\184','\204\187','\204\191','\205\130','\205\135',
'\205\154','\223\178','\223\179'}
--]]
table.sort(ornam_code_t) -- some chars may not mix well if inserted not in ascending order 
-- e.g. 18,5 or 18,1
local ornam = ''
	for k, v in ipairs(ornam_code_t) do
	ornam = ornam..t[v]
	end
local str = str:gsub('[\192-\255]*.[\128-\191]*', function(c) return not want_spaces and #c:gsub(' ','') == 0 and c or c..ornam end) -- accounting for non-ASCII characters by including leading and trailing bytes if any
return str
end


function bytes2string(input)
-- character byte sequence passed as a regular string, i.e '\114\101\116'
-- Lua automatically interprets and outputs as text
-- therefore explicit conversion of byte sequence into characters isn't necessary
-- unless it's passed as a literal string, i.e. [['\114\101\116]],
-- only in this case #input:gsub('\\%x+','') == 0 will be true

	if #input > 0 and #input:gsub('\\%x+','') == 0 then -- byte sequence, convert to string
	return input:gsub('\\%x+', function(c) return c:match('%x+'):char() end)
	end

return input -- if not literal byte sequence, return as is

end



function add_zero_padding(max_num)
-- only supports integers
	for i=0, max_num do
	local pad = ('0'):rep(#(max_num..'')-#(i..'')) -- difference in integer length
	-- CONCATENATE pad VARIABLE HERE
	end
-- RETURN THE RESULT
end



function wrap_text(text, max_len)
-- https://old.reddit.com/r/Reaper/comments/1l08ctv/new_lua_script_for_reaper_subtitle_prompter_with/

local words = {}
	for word in text:gmatch("%S+") do
	table.insert(words, word)
	end

local lines = {}
local current_line = ""

	for i, word in ipairs(words) do
		if #current_line == 0 then
		current_line = word
		else
			if #current_line + 1 + #word <= max_len then
			current_line = current_line .. " " .. word
			else
			table.insert(lines, current_line)
			current_line = word
			end
		end
	end
	
	if #current_line > 0 then
	table.insert(lines, current_line)
	end

return table.concat(lines, "\n")

end


function numerate_instances(word, repeats, str)
-- numerates word intances appending the numeral after the word
-- in the str argument, if supplied, or if not -
-- in the string of the word duplicated as per the repeats arg;
-- word is a string, either literal or pattern,
-- if str arg isn't supplied word must be literal string
-- since duplicating a pattern makes no sense,
-- if the word arg is a literal string Esc() function 
-- may be required;
-- repeats is integer representing the number
-- of repetitions of the string passed as word arg;
-- str is the source string to numerate the word in, optional;
-- numeration starts at 1

-- local word = Esc(word)
local str = str or (word):rep(repeats)
local i
return str:gsub(word, function(c) i = i and i+1 or 1; return c..' '..i end)

end


function sanitize_string_for_menu(name, pipe)
-- stripping leading !, #, < and > and replacing all instances of |
-- so that being menu special characters they don't affect 
-- the way string is displayed in the menu;
-- pipe argument is a replacement character for pipe
-- if invalid or empty, underscore is used
local pipe = pipe and #pipe > 0 and pipe or '_'
return (name:sub(1,1):match('[!#<>]+') and name:sub(2) or name):gsub('|', pipe)
end



function Construct_Roman_Numerals(...)
-- vararg implies up to 2 arguments holding integers
-- representing range bounds, i.e. start/fin,
-- if both are supplied, invalid start defaults to 1,
-- invalid fin defaults to 4999, unlike with numbers 4, 40, 400,
-- number 4000 doesn't include V̅ (5000) character (although
-- the Wikipedia article states that only numbers up to
-- 3999 can be represented using regular notation, which 
-- suggests that 4000 must include character for 5000);
-- if start greater than fin, they're reversed;
-- if only 1 arg is supplied only this supplied 
-- number will be converted;
-- if no argument is supplied 
-- the range defaults to 1 - 4999;
-- zero as range start is supported, if supplied explicitly;
-- the function uses the commonest subtractive notation,
-- i.e. for 4, 9, 40, 90, 400, 900 and their instances 
-- https://en.wikipedia.org/wiki/Roman_numerals

local a, b = table.unpack({...})
local start, fin
	if a and b then -- two arguments
	start, fin = a, b	
	else -- one argument
	start, fin = a, a
	end
start, fin = tonumber(start), tonumber(fin)
-- ensure that bounds are positive integers
start, fin = start and math.floor(math.abs(start)) or 1, fin and math.floor(math.abs(fin)) or 10000
	if start > fin then
	start, fin = fin, start
	end

	local function parse_number(i, numeral)
	local order = {[1000]='M', [500]='D', [100]='C', [50]='L', [10]='X', [5]='V'}
	-- OR
	-- order = {'M', 'D', 'C', 'L', 'X', 'V'} -- if used, must be accessed with order[k] in the loop below
		
		for k, divisor in ipairs({1000, 500, 100, 50, 10, 5}) do -- divisors correspond to numbers denoted with unique characters in order to catch numbers they're included in; iterating in descending order of divisors to get the greatest possible order of a number and continue to parse it in this way until the order of ones, iteration in ascending order of divisors would give wrong results because most of the numbers would be multiples of 5 (the lowest divisor) either with or without remainder, as if most of them included character 'V' which is false
		local int = math.modf(i/divisor) -- OR math.floor(i/divisor) // whole part
			if int > 0 then -- regular numbers, i.e. not 4, 9, 40, 90, 400, 900 and their instances which are fashioned in subtractive format
			local numeral = (numeral or '')..order[divisor]:rep(int)
			local remainder = i%divisor -- get remainder to parse firther
			return parse_number(remainder, numeral)
			elseif
			-- the following conditions which capture numbers in subtractive notation
			-- rely on the fact that result of modulo operation
			-- equals the dividend if the divisor is greater, i.e. 4%5 is 4 and 91%100 is 91;
			-- the descending order of contidions follows the divisiors order
			-- in which they're interated over within the loop
			divisor >= 500 and divisor - i%divisor <= 100 -- accommodate 400 & 900 and their instances whose range lies within 100 from 500 and from 1000 respectively // 'divisor >= 500' is the same as 'divisor > 100' because there're only two divisors above 100 denoted with a unique character, namely 500 and 1000
			or divisor >= 50 and divisor - i%divisor <= 10 -- 40 & 90 and their instances whose range lies within 10 from 50 and from 100 respectively // 'divisor >= 50' is the same as 'divisor > 10' because there're only two divisors above 10 denoted with a unique character, namely 50 and 100
			or divisor >= 5 and divisor - i%divisor == 1 -- 4 & 9 and all their instances under 40
			then
			local unit = divisor >= 500 and 'C' or divisor >= 50 and 'X' or divisor >= 5 and 'I' -- determine subtraction unit for non-standard nunbers, i.e. IV, IX, XL, XC, CD, CM
			local numeral = (numeral or '')..unit..order[divisor]
			local remainder = i - (divisor-(divisor > 100 and 100 or divisor > 10 and 10 or 0)) -- get remainder by subtracting order from the divisor and subtracting that from the input number, i.e. if input number is 42, the remainder is 2 = 42 - (50-10), if the input number is 916, the remainder is 16 = 916 - (1000-100); 'divisor > 100' is the same as 'divisor >= 500' because there're only two divisors above 100 denoted with a unique character, namely 500 and 1000, and 'divisor > 10' is the same as 'divisor >= 50' because there're only two divisors above 10 denoted with a unique character, namely 50 and 100; ignoring divisor 5 here because it's already accounted for in 'numeral' variable for numbers under 40 and if included an endless loop kicks in
				if remainder > 0 then
				return parse_number(remainder, numeral)
				end
			return numeral
			end
		end
	return (numeral or '')..('I'):rep(i) -- attach ones, or return ones alone for numbers under 4
	end
	

	-- A MORE COMPACT CODE
	local function parse_number(i, numeral)

	local order = {[1000]='M', [500]='D', [100]='C', [50]='L', [10]='X', [5]='V'}
	-- OR
	-- order = {'M', 'D', 'C', 'L', 'X', 'V'} -- if used, must be accessed with order[k] in the loop below
		
		for k, divisor in ipairs({1000, 500, 100, 50, 10, 5}) do -- divisors correspond to numbers denoted with unique characters in order to catch numbers they're included in; iterating in descending order of divisors to get the greatest possible order of a number and continue to parse it in this way until the order of ones, iteration in ascending order of divisors would give wrong results because most of the numbers would be multiples of 5 (the lowest divisor) either with or without remainder, as if most of them included character 'V' which is false
		local int = math.modf(i/divisor) -- OR math.floor(i/divisor) // whole part
		
			if int > 0 -- regular numbers, i.e. not 4, 9, 40, 90, 400, 900 and their instances which are fashioned in subtractive format
			-- the following conditions which capture numbers in subtractive notation
			-- rely on the fact that result of modulo operation
			-- equals the dividend if the divisor is greater, i.e. 4%5 is 4 and 91%100 is 91;
			-- the descending order of contidions follows the divisiors order
			-- in which they're interated over within the loop
			or divisor >= 500 and divisor - i%divisor <= 100 -- accommodate 400 & 900 and their instances whose range lies within 100 from 500 and from 1000 respectively // 'divisor >= 500' is the same as 'divisor > 100' because there're only two divisors above 100 denoted with a unique character, namely 500 and 1000
			or divisor >= 50 and divisor - i%divisor <= 10 -- 40 & 90 and their instances whose range lies within 10 from 50 and from 100 respectively // 'divisor >= 50' is the same as 'divisor > 10' because there're only two divisors above 10 denoted with a unique character, namely 50 and 100
			or divisor >= 5 and divisor - i%divisor == 1 -- 4 & 9 and all their instances under 40
			then
			local unit = divisor >= 500 and 'C' or divisor >= 50 and 'X' or divisor >= 5 and 'I' -- determine subtraction unit for non-standard nunbers, i.e. IV, IX, XL, XC, CD, CM
			local numeral = int > 0 and (numeral or '')..order[divisor]:rep(int) or (numeral or '')..unit..order[divisor]
			local remainder = int > 0 and i%divisor -- get remainder to parse firther
			or i - (divisor-(divisor > 100 and 100 or divisor > 10 and 10 or 0)) -- get remainder for numbers in subtractive notation by subtracting order from the divisor and subtracting that from the input number, i.e. if input number is 42, the remainder is 2 = 42 - (50-10), if the input number is 916, the remainder is 16 = 916 - (1000-100); 'divisor > 100' is the same as 'divisor >= 500' because there're only two divisors above 100 denoted with a unique character, namely 500 and 1000, and 'divisor > 10' is the same as 'divisor >= 50' because there're only two divisors above 10 denoted with a unique character, namely 50 and 100; ignoring divisor 5 here because it's already accounted for in 'numeral' variable for numbers under 40 and if included an endless loop kicks in
				if int > 0 or remainder > 0 then
				return parse_number(remainder, numeral)
				else -- return numeral constructed in subtractive notation if remainders is smaller than 0
				return numeral
				end
			end
		end
	return (numeral or '')..('I'):rep(i) -- attach ones, or return ones alone for numbers under 4
	end
	
local t = {}
	for i=start,fin do
	t[i] = i == 0 and 'N' or parse_number(i)
	end
return t
end
-- USE: 
-- t = Construct_Roman_Numerals(1,100)
-- roman_67 = t[67]
-- t = Construct_Roman_Numerals(67)
-- roman_67 = t[67]




--=========================== S T R I N G S  E N D ==============================


--=============================== T A B L E S ===================================

function copy_array1(t)
	if not t or #t == 0 then return end
local a = {}
	for k, v in ipairs(t) do
	a[k] = v
	end
return a
end


function copy_array2(t)
	if not t or #t == 0 then return end
local a = {}
	for i = 1, #t do
	table.insert(a, i, t[i])
	end
return a
end


function copy_table(t)
-- inspired by https://stackoverflow.com/a/10842827/8883033
-- https://stackoverflow.com/questions/10842679/lua-multiple-assignment
return {table.unpack(t)}
end
-- e.g. local t2 = copy_table(t1)
-- OR simply
-- local t2 = {table.unpack(t1)}


function reverse_indexed_table1(t) -- around the last value
	if not t then return end
	for i = 1, #t-1 do -- loop as many times as the table length less 1, since the last value won't need moving
	local v = t[#t-i] -- store value
	table.remove(t, #t-i) -- remove it
	t[#t+1] = v -- insert it as the last value
	end
return t
end

function reverse_indexed_table2(t)
	if not t then return end
local fin = #t -- separate var because using #t in the loop won't work due to the table length increase
	for i = fin,1,-1 do
	t[#t+1] = t[i] -- append all values starting from the last to the end of current table
	end
	for i = 1, fin do
	table.remove(t,1) -- remove 1st field as many times as the length of the orig table, with each removal next field becomes 1st
	end
return t
end


function reverse_indexed_table3(t)
	for i = #t,1,-1 do
	t[#t+1] = t[i]
	table.remove(t,i)
	end
return t
end


function reverse_indexed_table4(t)
	for k, v in ipairs(t) do
		if k > #t/2 then break end -- only run half the table length (rounded down half if the length is an odd number), otherwise the order will be restored
	local i = k-1
	t[k] = t[#t-i]
	t[#t-i] = v
	end
return t
end


function reverse_indexed_table5(t)
	for k, v in ipairs(t) do
		if k > #t/2 then break end -- only run half the table length (rounded down half if the length is an odd number), otherwise the order will be restored
	local k2 = #t-k+1
	t[k] = t[k2]
	t[k2] = v
	end
return t
end


function James_Bradbury_reverse_table(t)
-- Invert the table around the middle point (mirror!)
-- https://github.com/ReaCoMa/ReaCoMa-2.0/blob/main/lib/utils.lua
    -- Reverse a table in place
	local i, j = 1, #t
	while i < j do
		t[i], t[j] = t[j], t[i]
		i = i + 1
		j = j - 1
	end
end


function filter_table_vals(t, val, func) -- val can be number, string, pointer or table, of course table values type must match 'val' arg type // t arg seems unnecessary because table is recognized even being local // basic use is (in)equality evaluation; for numbers <> operators can be employed // the function works recursively
-- idea - https://stackoverflow.com/questions/49709998/how-to-filter-a-lua-array-inplace
local num = type(val) == 'number'
local str = type(val) == 'string'
local ptr = type(val) == 'userdata'
local tab = type(val) == 'table'
	for k, v in ipairs(t) do
		if v ~= val then
	-- 	if str and not v:match(val) then -- filtering by string contents
	--  if tab and v == val[k] then -- filtering by values found in another table
		table.remove(t,k)
		func(t, val, filter_table_vals) -- recursiveness is used to overcome the problem of table indices (k) shift as slots are being removed which results in some indices being skipped
	end
end


function filter_inplace1(t, val, func)
   for k, v in ipairs(t) do
       if v == val then
       table.remove(t,k)
       func(t, val, filter_inplace1)
	   -- OR
	   -- filter_inplace(t, val) and use example is filter_inplace(t, 1)
       end
    end
end
-- EX
-- filter_inplace(t, 1, filter_inplace)

-- OR
function filter_inplace2(t, val)
   for k, v in ipairs(t) do
       if v = val then
       table.remove(t,k)
       filter_inplace(t, val)
       end
    end
end
-- EX
-- filter_inplace(t, 1)


function merge_2_arrays_at_index(t1,t2,index)
-- the result is updated t1
-- index applies to t1
-- ommitted or excessive index defaults to last+1
local index = (not index or index > #t1) and #t1+1 or index
local offset = 1-index
	for i = index, #t2+index-1 do
	table.insert(t1, i, t2[i+offset])
	end
end



function merge_tables1(t,...)
-- elipsis (vararg) represents a list of tables to be merged with t;
-- be aware that since the tables passed as elipsis will be merged with t
-- after the merge it will contain all of them,
-- so if you plan to use t afterwards with its original contents
-- it's safer to pass an anonymous table {} as the 1st argument
-- i.e. merge_tables1({}, t1,t2,t3)
local to_merge = {...}
	for _, tab in ipairs(to_merge)do
		for i = 1, #tab do
		t[#t+1] = tab[i]
	--[[ OR
		for _, v in ipairs(tab) do
		t[#t+1] = v
	--]]
		end
	end
return t
end


function merge_tables2(t, new, ...) -- new is boolean to indicate if to merge with t or create a new table, elipsis (vararg) represents a list of tables to be merged with t
local t = new and {table.unpack(t)} or t
local to_merge = {...}
	for _, tab in ipairs(to_merge)do
		for i = 1, #tab do
		t[#t+1] = tab[i]
	--[[ OR
		for _, v in ipairs(tab) do
		t[#t+1] = v
	--]]
		end
	end
return t -- required if merge_tables is used as an argument in another function, e.g. unpack() below or if new t
end


function merge_args_into_array(...)
-- args can be variables and other arrays which are unpacked
local t, t2 = {...}, {}
	for _, tab in ipairs(t) do
		if type(tab) == 'table' then
			for i = 1, #tab do
			t2[#t2+1] = table.unpack(tab,i,i) -- same as tab[i]
			end
		else
		t2[#t2+1] = tab
		end
	end
return t2
end


-- table merger solutions
-- https://stackoverflow.com/questions/1410862/concatenation-of-tables-in-lua
-- https://stackoverflow.com/questions/1283388/how-to-merge-two-tables-overwriting-the-elements-which-are-in-both



function unpack_alt(t, from, to)
-- from & to are indices of fields
-- if from is nil then from the 1st up until 'to'
-- if 'to' is nil, then 'from' to the last
-- if both are nil, then all
return table.unpack(t, from or 1, to)
end


function truncate_array1(t, idx, before, after) -- SEE truncate_array2()
-- after and before are booleans to determine whether to truncate before or after idx
-- cannot both be true

	if before and after then return end

local st = before and 1 or after and idx+1
local fin = before and idx-1 or after and #t
local remove_idx = before and 1 or after and idx+1

	for i = st, fin do
		if t[remove_idx] then -- prevent 'out of bounds' error if idx happens to be greater that the table length or <= 0
		table.remove(t, remove_idx)
		end
	end

end


function truncate_array2(t, from, to)
return {table.unpack(t, from, to)}
end



function shuffle_array(t, places, backward)
-- places is integer, backward is boolean
-- number of places backward = #t - places forward and vice versa,
-- the results will be identical

	if places == #t then return end -- because the order will end up being the same
local i = 0
	if not backward then
	local last = t[#t] -- store to assign to the 1st field
		repeat
			for i = #t,1,-1 do
				if i < #t then t[i+1] = t[i] end
			end
		t[1] = last
		last = t[#t]
		i = i+1
		until i == places
	else
	local first = t[1] -- store to assign to the last field
		repeat
			for i = 1, #t do
				if i > 1 then t[i-1] = t[i] end
			end
		t[#t] = first
		first = t[1]
		i = i+1
		until i == places
	end
end


function Randomize_Array(t)
math.randomseed(math.floor(r.time_precise()*1000)) -- math.floor() because the seeding number must be integer; seems to facilitate greater randomization at fast rate thanks to milliseconds count, not necessary in this script though
	for k, v in ipairs(t) do
	local r = math.random(1, #t)
	t[r], t[k] = t[k], t[r]
	end
end


-- local t = {'Bb1','E3','D2','B4','F#5','G#1','Db2','C4','A5','B3','Eb3','G1'}
-- in note names created by REAPER 'explode' actions sharps are applied to F and G, flats are applied to D, E and B
function sort_notes_by_name(t, wantReverse) -- t is an array containing note names, wantReverse is boolean
-- the notes must use # and b for sharps and flats
-- the notes must be capitalized to distinguish between B and flat sign b
local pat = '[%-%d]+'
table.sort(t, function(a,b) return a:match(pat) < b:match(pat) end) -- sort by octave
local oct = -10 -- a value lower than the lowest octave number to be able to detect the 1st lowest and so forth
local table_len = #t -- to be used in removing all separate note fields

-- STEP 1
	for _, v in ipairs(t) do -- store notes belonging to every octave in a separate nested table
	local str = type(v) == 'string' -- could be table because nested tables are being added during the loop
	-- outwitting sorting algo used below to make it place sharps later and flats earlier in the sequence, otherwise sharps are sorted to earlier slots because '#' precedes numerals in the character list while 'b' comes after numerals, numeral matter because in the note name they denote octave, so G#1 will precede G1 and E1 will precede Eb1
	local v = str and v:gsub('#','z') -- z follows numerals
	local v = str and v:gsub('b','!') -- ! precedes numerals
		if str and v:match(pat) > oct..'' then -- create a nested table and store first note name
		t[#t+1] = {v}
		oct = v:match(pat)
		elseif str and v:match(pat) == oct..'' then -- keep adding note names to the nested table while the octave is the same
		local len = #t[#t]
		t[#t][len+1] = v
		else break -- all strings have been removed, no point to continue
		end
	end

	for i = table_len, 1, -1 do -- remove all separate note fields
	table.remove(t,i)
	end

-- STEP 2
local table_len = #t -- to be used in removing all nested tables, there're fewer fields at this stage because their number is based on octaves

	for k, v in ipairs(t) do -- sort each octave alphabetically
		if type(v) == 'table' then -- could be string because note names are being added during the loop
		table.sort(v) -- sort nested table
			for i = 1, #v do
			local note = v[i]
				if note:match('A') or note:match('B') then -- move these notes to the end of the list
				v[#v+1] = note
				v[i] = '' -- mark for deletion, deletion during the loop ruins the table but moving and deleting while iterating in reverse doesn't produce the accurate result, A ends up following B because it follows it in reversed loop
				end
			end
			for i = #v,1,-1 do -- delete A and B placeholder fields if any
				if v[i] == '' then table.remove(v,i) end
			end

			for _, v in ipairs(v) do -- place nested table fields back to the main table in separate fields
			local v = v:gsub('z','#') -- restoring sharps and flats
			local v = v:gsub('!','b')
			t[#t+1] = v
			end
		else break -- all tables have been removed, no point to continue
		end
	end

-- STEP 3
	for i = table_len, 1, -1 do -- remove all nested tables
	table.remove(t,i)
	end

	if wantReverse then
		--[[ reverse table -- WORKS
		for i = #t,1,-1 do
		t[#t+1] = t[i]
		table.remove(t,i)
		end
		--]]
		--[-[ OR
		for k, v in ipairs(t) do -- WORKS
			if k > #t/2 then break end -- only run half the table length (rounded down half if the length is an odd number), otherwise the order will be restored
		local i = k-1
		t[k] = t[#t-i]
		t[#t-i] = v
		end
		--]]
	end

return t

end


function binary_search1(t, value)
-- https://stackoverflow.com/questions/19522451/binary-search-of-an-array-of-arrays-in-lua
local lo = 1
local hi = #t
local mid
	while lo < hi do
	mid = math.floor((lo+hi)/2)
		if t[mid] < value then
		lo = mid+1
		else
		hi = mid
		end
	end
return lo
end


function binary_search2(t, value) -- my implementation, isn't the classic method
-- the speed advantage over simple iteration only starts to be felt from about 100,000 array entries
-- https://github.com/ReaTeam/ReaScripts/blob/master/MIDI%20Editor/js_Notation%20-%20Set%20displayed%20length%20of%20selected%20notes%20to%20custom%20value.lua -- idea source
-- https://github.com/Roblox/Wiki-Lua-Libraries/blob/master/StandardLibraries/BinarySearch.lua
local mid = 1
local fin = #t
	while t[mid] < value do
	local result = math.floor((fin+mid)/2)
		if t[result] < value and result ~= mid then mid = result -- result ~= mid prevents endless loop when the sought value is the last in the array
		elseif
		t[result] > value and result ~= fin then fin = result
		else break end -- breaks short of the searched last value by 1
	end
	for i = mid, fin do
		if t[i] == value then return i end
	end
end


function collect_numbers(first, last)
-- first and last must be sequential numbers
local t = {}
	for i = first, last do
	t[#t+1] = i
	end
return t
end



function construct_char_array(up, low, both)
-- up, low, both are booleans to choose case
-- under one case there're 26 alphabetic chars in Latin basic
local capt = both and '%a' or up and '%u' or low and '%l'
local t = {}
	for i = 0, 255 do
	local char = string.char(i)
		if char:match(capt) then
		t[#t+1] = char
		end
	end
return t
end


function reuse_short_array_over_long(t1, t2, k2)
-- if two arrays must be used in parallel
-- and index k2 of the long array t2 exceeds the range of the short one t1
-- cycle indices of the short array, reusing its values
-- e.g. if t2 is '1,2,3,4,5,6,7' and t1 is 'a,b,c'
-- and k2 goes beyond 3 the count of t1 is restarted
-- so that 4 matches a, 5 matches b and 6 matches c
-- and so on
local k1 = k2
	if k2 > #t1 then
	-- when modulo is 0 the quotient is equal to the divisor i.e. #t1
	-- therefore the short table last index is selected
	-- e.g. #t1 is 5, #t2 is 7, if k2 is 7 then 7%5 = 2,
	-- reusing value at index 2 of t1, but if k2 is 5 then 5%5 = 0,
	-- or k2 is 10 then 10%5 = 0, so reusing value at index 5 of t1
	-- which is equal to its length
	k1 = k2%#t1 == 0 and #t1 or k2%#t1
	end
--Msg(k1)
--[[ works but unnecessary
-- reverse index order, e.g. 12345 turn into 54321
local ii = 0
	for i=#t1,1,-1 do
	ii = ii+1
		if ii == k1 then Msg(i) return i end
	end
--]]
return k1
end



function reuse_short_array_over_long_reversed(t1, t2, k2)
-- if two arrays must be used in parallel
-- and index k2 of the long array t2 exceeds the range of the short one t1
-- cycle indices of the short array, reusing its values
-- but in reverse, e.g. if t2 is '1,2,3,4,5,6,7'
-- and t1 is 'a,b,c', count from 7 and c respectively,
-- and when k2 goes beyond 5 the count of t1 is restarted
-- so that 4 matches c, 3 matches b and 2 matches 1
-- and so on

local k1 = k2
	if #t1 < #t2 then
	-- limit is the value after which the shorter table cycle is restarted
	local limit = #t2 - #t1
	k1 = k2 - limit
		if k2 <= limit then
		local int, fraq = math.modf(k2/#t1)
		local modulo = (#t2-k2)%#t1
		k1 = modulo == 0 and #t1 or #t1-modulo
		end
	end

return k1

end



function sort_tableA_by_tableB(tA, tB) -- indexed tables; table lengths may differ
-- replicate in tA order found in tB
	 for _, vB in ipairs(tB) do
		for kA, vA in ipairs(tA) do
			if vA == vB then
			tA[#tA+1] = vA
			table.remove(tA,kA)
			end
		end
	end
end



function sort_table1(t, start_idx, end_idx, field, descending) -- see version 2 below with recursion
-- t is an INDEXED table;
-- start_idx, end_idx limit table range within which
-- values must be sorted, to the best of my knowledge the stock table.sort
-- doesn't allow sorting within range and is unstable, i.e. when sorting by a criterion
-- which only varies in certain table fields, the entire table ends up being
-- sorted including some fields with values which by dent of being identical 
-- should not be sorted, so before sorting within range with this function
-- prepare the table by placing all target fields within that range, e.g.
--[[
local end_idx = 0
	for i=1, #t do -- not using ipairs to avoid affecting loop sequence when fields are moved within the table
	local v = t[i]
		if v == MATCH then -- OR v[field] // MATCH is a variable to campare against in search for a relevant field
		-- in this order, to remove from original index i
		-- before inserting at index 1
		table.remove(t,i)
		table.insert(t,1,task)
		end_idx = end_idx+1
		end
	end
]]
-- field is a string, name of a field in a nested associative array,
-- or integer of a field index in an indexed nested table, if the table t 
-- consists of nested arrays,
-- if field arg is invalid, indexed values in the table t will be sorted, if any;
-- descending is boolean to sort in descending order;
-- the algo is probably terribly inefficient, but for relatively short tables is fine
local compare = descending and math.max or math.min
local start_idx = start_idx and start_idx > 0 and start_idx ~= #t and start_idx or 1
local end_idx = end_idx and end_idx <= #t and end_idx ~= 1 and end_idx or #t
	for i=start_idx, end_idx do -- advance by 1 and evaluate values from index i onwards
	local result = math.huge*(descending and -1 or 1)
		for ii=i,end_idx do -- not using ipairs to avoid affecting loop sequence when fields are moved within the table
		local v = t[ii]
		local value = field and type(v) == 'table' and v[field] or not field and v
			if value then
			result = compare(value, result)
				if result == value then
				v = field and type(v) == 'table' and v or value -- if nested table move the entire table
				-- in this order, to remove from original index ii
				-- before inserting at index i
				table.remove(t,ii)
				table.insert(t,i,v) -- move to the index, value at which is currently being evaluated
				end
			end
		end
	end
return t
end



function sort_table2(t, start_idx, end_idx, field, descending)
-- t is an INDEXED table;
-- start_idx, end_idx limit table range within which
-- values must be sorted, to the best of my knowledge the stock table.sort
-- doesn't allow sorting within range and is unstable, i.e. when sorting by a criterion
-- which only varies in certain table fields, the entire table ends up being
-- sorted including some fields with values which by dent of being identical 
-- should not be sorted, so before sorting within range with this function
-- prepare the table by placing all target fields within that range, e.g.
--[[
local end_idx = 0
  for i=1, #t do -- not using ipairs to avoid affecting loop sequence when fields are moved within the table
  local v = t[i]
    if v == MATCH then -- OR v[field] // MATCH is a variable to campare against in search for a relevant field
    -- in this order, to remove from original index i
    -- before inserting at index 1
    table.remove(t,i)
    table.insert(t,1,task)
    end_idx = end_idx+1
    end
  end
]]
-- field is a string, name of a field in a nested associative array,
-- or integer of a field index in an indexed nested table, if the table t 
-- consists of nested arrays,
-- if field arg is invalid, indexed values in the table t will be sorted, if any;
-- descending is boolean to sort in descending order;
-- the algo is probably terribly inefficient, but for relatively short tables is fine
local compare = descending and math.max or math.min
local start_idx = start_idx and start_idx > 0 and start_idx ~= #t and start_idx or 1
local end_idx = end_idx and end_idx <= #t and end_idx ~= 1 and end_idx or #t
local result = math.huge*(descending and -1 or 1)
    for i=start_idx,end_idx do -- not using ipairs to avoid affecting loop sequence when fields are moved within the table
    local v = t[i]
    local value = field and type(v) == 'table' and v[field] or not field and v
      if value then
      result = compare(value, result)
        if result == value then
        v = field and type(v) == 'table' and v or value -- if nested table move the entire table
        -- in this order, to remove from original index ii
        -- before inserting at index i
        table.remove(t,i)
        table.insert(t,start_idx,v) -- move to the index, value at which is currently being evaluated
        end
      end
    end
return start_idx+1 < end_idx and sort_table(t, start_idx+1, end_idx, field, descending) or t
end




function is_table_already_sorted1(t, dir)
-- t is an indexed table
-- dir is integer, sorting direction to be evaluated
-- 1 - ascending, 2 descending
local asc, desc = dir == 1, dir == 2
local t2 = {table.unpack(t)} -- copy the orig table
-- if ascending the function isn't needed but leaving it for consistency
table.sort(t2, function(a,b) return asc and a < b or desc and a > b end) -- sort the copy
return table.concat(t2,',') == table.concat(t,',')	-- compary concatenated
end


local function is_table_already_sorted2(t, field, dir)
-- version for complex tables
-- t is an INDEXED table with nested tables
-- field is a string or integer, name of a field in the associative array
-- or field index in an indexed array
-- dir is integer, sorting direction to be evaluated
-- 1 - ascending, 2 descending
---------------------------------
-- collect values from the orig table into temp table t2
local t2 = {}
	for k, tab in ipairs(t) do -- here original t contains nested tables in all of which the required value is stored in the field 'value'
		if tab[field] then
		t2[k] = tab[field]
		end
	end
local t2_concat = table.concat(t2,',') -- convert into string before sorting
local asc, desc = dir == 1, dir == 2
-- if ascending the function isn't needed but leaving it for consistency
table.sort(t2, function(a,b) return asc and a < b or desc and a > b end) -- sort the temp table
return t2_concat == table.concat(t2,',') -- compare before and after sorting
end



function pack(...) -- same as table.pack()
-- https://www.gammon.com.au/scripts/doc.php?lua=pcall
-- http://lua-users.org/lists/lua-l/2009-11/msg00269.html
-- https://www.gammon.com.au/scripts/doc.php?lua=select
return {n = select("#", ...); ...}
-- OR
-- return {n = #{...}, ...}
end


function build_array_of_multiple_repeating_items(t)
-- t is an array containing nested 2-part arrays
-- consisting of the item needing repetition and the number
-- of such repetitions, e.g. { {a,2}, {b,3} }
-- var 'a' should be repeated twice, var 'b' should be repeated trice
-- the resulting table is supposed to contain
-- 2 instances of var 'a' followed by 3 instances of var 'b'
-- and be 5 fields long
local t2 = {}
	for k, data in ipairs(t) do
		for i=1,data[2] do
		table.insert(t2, data[1]) -- inserting at the last index, index arg (2) is ommitted
	-- OR
	--	t2[#t2+1] = data[1]
		end
	end
return t2
end



function deep_copy1(obj, seen)
-- https://gist.github.com/tylerneylon/81333721109155b2d244
-- Handle non-tables and previously-seen tables.
	if type(obj) ~= 'table' then return obj end
	if seen and seen[obj] then return seen[obj] end

-- New table; mark it as seen and copy recursively.
local s = seen or {}
local res = {}
s[obj] = res
	for k, v in pairs(obj) do
-- OR better to invoke the for loop with 'for k, v in next, obj do', 
-- to avoid triggering a __pairs metamethod. e.g.
--	for k, v in next obj do
	res[deep_copy1(k, s)] = deep_copy1(v, s) 
	end
-- set the metatable after copying the data, 
-- otherwise you risk triggering __index and __newindex metamethods, 
-- which will change the semantics.
return setmetatable(res, getmetatable(obj))

end


function deep_copy2(orig, copies)
-- http://lua-users.org/wiki/CopyTable
-- -- Save copied tables in `copies`, indexed by original table
copies = copies or {}
local orig_type = type(orig)
local copy
	if orig_type == 'table' then
		if copies[orig] then
		copy = copies[orig]
		else
		copy = {}
		copies[orig] = copy
			for orig_key, orig_value in next, orig, nil do
			copy[deepcopy2(orig_key, copies)] = deepcopy2(orig_value, copies)
			end
		setmetatable(copy, deepcopy2(getmetatable(orig), copies))
		end
		else -- number, string, boolean, etc
	copy = orig
	end
return copy
end


function embed_table_length1(t)
-- as field 'n'
return table.pack(table.unpack(t))
end


function embed_table_length2(t)
-- as field 'n' or any other arbitrary field
return t.n = #t
end


-- see also get_greatest_smallest_value



--=========================== T A B L E S  E N D ==============================


--================================ M I D I ================================

r.MIDIEditor_GetSetting_int(ME, 'last_clicked_cc_lane')
-- -1 -- Piano roll was last clicked context
-- 0 - 127 -- regular CC lanes
-- 256 - 287 -- 31 14-bit CC lanes
-- 513 -- pitch
-- 514 -- program
-- 515 -- channel pressure
-- 516 -- program/bank select
-- MIDI CHANNEL IS IRRELEVANT FOR:
-- 512 -- velocity
-- 519 -- off velocity
-- 517 -- text events
-- 518 -- SysEx
-- 520 -- notation events
-- 528 -- media item lane // doesn't seem to be actually returned by the function, instead returns last clicked lane or -1

r.MIDIEditor_GetSetting_int(ME, 'default_note_chan') -- returns channel currently selected in the MIDI Editor channel drop-down menu or last selected if 'All channels' or 'Multichannel' menu option is active

MIDI_GetCC()
-- chanmsg (event type):
-- 0 - non-CC: (off) velocity, text/notation/sysex events, 160 - Poly Aftertouch, 176 - CC, Bank/Program select, Bank select, 192 - Program change, 208 - Channel pressure (aftertouch), 224 - Pitch (bend)
-- msg2:
-- always 0 for non-CC, Bank/Program select, 00 Bank select MSB events
-- first 7 bits (MSB) of event value for Pitch (msg3 provides second 7 bits (LSB))
-- program number for Program
-- event value for Channel pressure
-- CC message number for CC events starting from 0
-- msg3:
-- always 0 for non-CC, Program, Channel pressure
-- second 7 bits (LSB) of event value for Pitch (msg2 provides first 7 bits (MSB))
-- bank MSB for Bank/Program select and 00 Bank select MSB events, 0 if Bank/Program select event doesn't have .reabank loaded
-- event value for CC events
MIDI_GetTextSysexEvt()
-- type var
-- text events: 1 text, 2 copyright notice, 3 track name, 4 instrument name, 5 lyrics, 6 marker, 7 cue, 8 program name, 9 device name
-- notation event: 15
-- sysex event: -1
-- setting sysex event data https://forums.cockos.com/showthread.php?p=2267909
r.MIDI_InsertTextSysexEvt() -- not inserted with empty bytestr argument
-- to insert a notation event linked to a note bytestr string must include 'NOTE' prefix, channel number and note number, e.g 'NOTE '..chan..' '..note, it can be additionally complemented with text, e.g. 'NOTE '..chan..' '..note..' '..text; 'TRAC ' prefix pertains to notation events inserted in the Notation events lane which aren't linked to notes
-- https://forum.cockos.com/showthread.php?t=273389&page=3#111
-- https://forum.cockos.com/showthread.php?p=2636270
-- https://forum.cockos.com/showthread.php?t=278052
-- the 'NOTE' and 'TRAC' prefixes are contained in the msg return value of r.MIDI_GetTextSysexEvt() depending on the source of the event, as well as in stuffed data
-- using stuffed MIDI data
-- https://github.com/MichaelPilyavskiy/ReaScripts/blob/master/MIDI%20editor/mpl_Remove%20MIDI%20CC.lua
-- https://forum.cockos.com/showthread.php?t=241140


function Is_MIDI_Ed_Open() -- see MIDIEditor_GetActiveAndVisible() below
-- NOT RELIABLE SINCE DOCKED MIDI EDITOR IN CLOSED DOCK IS STILL VALID
-- IF DOCK IS FLOATING THE NATURAL INSTINCT IS TO CLOSE IT USING THE WINDOW CLOSE BUTTON
-- AND THAT'S WHERE THE PROBLEM EMERGES
-- THE MIDI EDITOR REMAINS DOCKED AND EVEN BEING INVISIBLE IS VALID SINCE IT WASN'T EXPLICITLY CLOSED
-- ONLY CLOSURE WITH TAB CLOSE BUTTON MAKES IT TRULY NON-FOCUSED AND INVALID
-- https://forum.cockos.com/showthread.php?t=278871
return r.GetToggleCommandStateEx(32060, 1014) ~= -1 -- View: Toggle snap to grid // if closed toggle state isn't returned
end


function MIDIEditor_GetActiveAndVisible()
-- solution to the problem described at https://forum.cockos.com/showthread.php?t=278871
local ME = r.MIDIEditor_GetActive()
local dockermode_idx, floating = r.DockIsChildOfDock(ME) -- floating is true regardless of the floating docker visibility
local dock_pos = r.DockGetPosition(dockermode_idx) -- -1=not found, 0=bottom, 1=left, 2=top, 3=right, 4=floating
-- OR
-- local floating = dock_pos == 4 -- another way to evaluate if docker is floating
-- the MIDI Editor is either not docked or docked in an open docker attached to the main window
	if ME and (dockermode_idx == -1 or dockermode_idx > -1 and not floating
	and r.GetToggleCommandStateEx(0,40279) == 1) -- View: Show docker
	then return ME, dock_pos
-- the MIDI Editor is docked in an open floating docker
	elseif ME and floating then
		-- INSTEAD OF THE LOOP below the following function can be used
		local ret, val = r.get_config_var_string('dockermode'..dockermode_idx)
			if val == '32768' then -- OR val ~= '98304' // open floating docker OR not closed floating docker
			return ME, 4
			end
		--[[ OR
		for line in io.lines(r.get_ini_file()) do
			if line:match('dockermode'..dockermode_idx)
			and line:match('32768') -- open floating docker
			-- OR
			-- and not line:match('98304') -- not closed floating docker
			then return ME, 4 -- here dock_pos will always be floating i.e. 4
			end
		end
		--]]
	end
end


function Force_MIDI_Undo_Point1(take)
-- a trick shared by juliansader to force MIDI API to register undo point; Undo_OnStateChange() works too but with native actions it may create extra undo points, therefore Undo_Begin/EndBlock() functions must stay
-- https://forum.cockos.com/showpost.php?p=1925555
local item = take and r.GetMediaItemTake_Item(take) or r.GetMediaItemTake_Item(r.MIDIEditor_GetTake(r.MIDIEditor_GetActive()))
--r.SetMediaItemSelected(item, false)
--r.SetMediaItemSelected(item, true)
local is_item_sel = r.IsMediaItemSelected(item)
r.SetMediaItemSelected(item, not is_item_sel)
r.SetMediaItemSelected(item, is_item_sel)
end

function Force_MIDI_Undo_Point2(take) -- may or may not work, the above version is more reliable
local item = r.GetMediaItemTake_Item(take)
local tr = r.GetMediaItemTrack(item)
r.MarkTrackItemsDirty(tr, item)
end


function Lane_Type_To_Event_Data(ME) -- relies on Error_Tooltip() for error message
-- further implementation see in Insert or edit MIDI event at edit cursor.lua
local ME = not ME and r.MIDIEditor_GetActive()
local last_clicked_lane = r.MIDIEditor_GetSetting_int(ME, 'last_clicked_cc_lane')

	if last_clicked_lane == -1 then  -- last clicked lane return value is -1 when the Piano roll was last clicked context
	Error_Tooltip('\n\nthe last clicked lane is undefined\n\n  click any lane to make it active \n\n', 1, 1) -- caps, spaced true
	return end

return (last_clicked_lane >= 0 and last_clicked_lane <= 119 -- regular 7-bit cc lanes
or last_clicked_lane >= 256 and last_clicked_lane <= 287) -- 14-bit lanes
and 176
or last_clicked_lane == 513 and 224 -- pitch
or last_clicked_lane == 514 and 192 -- program change
or last_clicked_lane == 515 and 208 -- channel pressure (aftertouch)
or last_clicked_lane == 516 and 176 -- Bank/Program select // the data in this lane is linked to CC#00 Bank select MSB lane, events created in one automatically appear in the other, for both MIDI_GetCC() chanmsg return value is 176
or last_clicked_lane == 517 and 1 -- text events, between 1 and 14, currently only 9 are available // the value will be fine tuned in the loop so that all text event types are covered
or last_clicked_lane == 518 and -1 -- sysex event
or last_clicked_lane == 520 and 15 -- notation event

end


function MIDI_Take_Open_Close(is_open, item)
-- check if take is open in the MIDI Editor
-- if not open then open
-- run twice: 1) to open if not open and get take pointer; 2) to close if wasn't open initially
	if item then
	local item = r.GetSelectedMediaItem(0,0)
	local act_take = r.GetActiveTake(item)
	local is_midi = r.TakeIsMIDI(act_take)
	local is_open = r.MIDIEditor_GetActive() -- check if MIDI Editor is open
	local open = is_midi and not is_open and r.Main_OnCommand(40153, 0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
	local hwnd = r.MIDIEditor_GetActive()
	local midi_take = r.MIDIEditor_GetTake(hwnd)
	return midi_take, is_open
	elseif not is_open then -- wasn't open initially
	r.MIDIEditor_LastFocused_OnCommand(2, false)  -- File: Close window;  islistviewcommand false
	end
and
-- USAGE EXAMPLE:
-- r.PreventUIRefresh(1)
--local midi_take, is_open = MIDI_Take_Open_Close(is_open, item)
--DO STUFF
--MIDI_Take_Open_Close(is_open)
-- r.PreventUIRefresh(-1)


function Clear_Restore_MIDI_Channel_Filter(enabled_ID, is_open) -- must be applied to selected MIDI item
-- when Channel filter is enabled Get/Set functions only target events in the current channel
-- which may be undesirable if working with all events
-- run twice: 1) to open if not open and clear filter if enabled 2) to close if wasn't open initially and to restore filter if was enabled

-- Conditioning is reversed the 1st part will be activated after the 2nd when the function is run twice

	if enabled_ID then -- has been opened
	r.MIDIEditor_LastFocused_OnCommand(enabled_ID, false) -- islistviewcommand false // Re-enable filter
		if not is_open then r.MIDIEditor_LastFocused_OnCommand(2, false) end -- File: Close window;  islistviewcommand false // close if wasn't initially open
	else
	-- for the MIDI Editor action GetToggleCommandStateEx() only works if its active
	local is_open = r.MIDIEditor_GetActive() -- check if MIDI Editor is open
	local open = not is_open and r.Main_OnCommand(40153, 0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
	local enabled_ID
		for i = 18, 33 do
			if r.GetToggleCommandStateEx(32060, 40200+i) == 1 -- ID range of actions which enable channel filter is 40218 - 40233 Channel: Show only channel X // actions Channel: Toggle channel X could be evaluated instead, their ID range is 40643 - 40658
			then enabled_ID = 40200+i break end
		end
		if enabled_ID then
		r.MIDIEditor_LastFocused_OnCommand(40217, false) -- Channel: Show all channels // islistviewcommand false // DISABLE FILTER
		return enabled_ID, is_open
		elseif not is_open then r.MIDIEditor_LastFocused_OnCommand(2, false) -- File: Close window;  islistviewcommand false // close if wasn't initially open and filter wasn't enabled otherwise will stay open until the 2nd run to re-enable the filter
		end
	end
end
-- USAGE EXAMPLE:
-- r.PreventUIRefresh(1)
--local enabled_ID, is_open = Clear_Restore_MIDI_Channel_Filter()
--DO STUFF
-- if enabled_ID then Clear_Restore_MIDI_Channel_Filter(enabled_ID, is_open) end
-- r.PreventUIRefresh(-1)



local ME = r.MIDIEditor_GetActive()
local take = r.MIDIEditor_GetTake(ME)


function are_notes_selected(ME, take)
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take)
	for i = 0, notecnt-1 do
	local retval, sel, muted, startppq, endppq, chan, pitch, vel = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		if sel then return true end
	end
end


function Notes_Selected(ME, take) -- in current MIDI channel
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
return r.MIDI_EnumSelNotes(take, -1) ~= -1 -- OR >= 0 OR > -1 // 1st selected note
end


-- MUCH SIMPLER r.MIDI_EnumSelNotes(take, -1) == 0
function selected_notes_exist(ME, take)
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local noteidx = -1 -- since MIDI_EnumSelNotes returns the index of the next selected MIDI note, the first of which would be 0
	repeat
	noteidx = r.MIDI_EnumSelNotes(take, noteidx)
		if noteidx > 0 then break end -- at least 1 sel note
	until noteidx == -1 -- -1 if there are no more or no selected events
end



function CC_Evts_Selected(ME, take) -- in current MIDI channel but across all CC lanes
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
return r.MIDI_EnumSelCC(take, -1) ~= -1 -- -- OR >= 0 OR > -1 // 1st selected CC event // bar velocity, text/notation events and SysEx
end


function Notes_CCEvts_Selected(ME, take)
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
return r.MIDI_EnumSelNotes(take, -1) ~= -1, -- -- OR >= 0 OR > -1 // 1st selected note // in current MIDI channel
r.MIDI_EnumSelCC(take, -1) ~= -1 -- 1st selected CC event // in current MIDI channel but across all CC lanes // bar velocity, text/notation events and SysEx
end


function Evts_Selected(ME, take) -- in current MIDI channel but across all CC lanes + notes
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
return r.MIDI_EnumSelEvts(take, -1) ~= -1 -- -- OR >= 0 OR > -1 // 1st selected event
end


function All_Sel_CCEvts_Belong_To_Visble_OR_Last_Clicked_Lane(ME, take) -- ONLY USEFUL IF JUST ONE CC LANE IS OPEN WHICH MIGHT NOT BE THE CASE
-- 2 boolean return values: if any selected and if true then if all belong to the same lane
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local autom_lane = r.MIDIEditor_GetSetting_int(ME, 'last_clicked_cc_lane') -- last clicked if several lanes are displayed, otherwise currently visible lane
local autom_lane = autom_lane >= 256 and autom_lane <= 287 and autom_lane - 256 or autom_lane -- for events in 14-bit lanes MIDI_GetCC() returns 7-bit CC#
local first_sel_evt_idx = r.MIDI_EnumSelCC(take, -1) -- idx of the first selected event
local i = 0
local last_sel_evt_idx
	repeat
	local idx = r.MIDI_EnumSelCC(take, i)
		if r.MIDI_EnumSelCC(take, i+1) == -1 then last_sel_evt_idx = idx break end
	i = i + 1
	until idx == -1
local first = {r.MIDI_GetCC(take, first_sel_evt_idx)} -- retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 // -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all CC events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
local last = {r.MIDI_GetCC(take, last_sel_evt_idx)}
return first_sel_evt_idx > -1, first[7] == autom_lane and first[7] == last[7] -- 7th return value is CC#
end


function count_selected_notes(ME, take)
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local sel_note_cnt = 0
local noteidx = -1 -- since MIDI_EnumSelNotes returns the index of the next selected MIDI note, the first of which would be 0
	repeat
	noteidx = r.MIDI_EnumSelNotes(take, noteidx)
	sel_note_cnt = noteidx > -1 and sel_note_cnt+1 or sel_note_cnt
	until noteidx == -1 -- -1 if there are no more or no selected events
return sel_note_cnt
end



function Deselect_All_Notes(ME, take)
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take)
	for i=0,notecnt-1 do
	r.MIDI_SetNote(take, i, false) -- selectedIn false
	end
end



function count_selected_events(ME, take, evt_type, lane, ch) -- TEXT/SYSEX/NOTATION EVENTS ROUTINE ISN'T DEVELOPED
-- IF FILTER OR MULTICHANNEL MODE ARE ENABLED THEY WILL HAVE TO BE DISABLED SO THE FUNCTIONS TARGET ALL MIDI CHANNELS AND NOT ONLY THE ACTIVE ONES
-- evt_type is a string: '' - all, 'n' - notes, 'c' - cc, 't' - text/sysex
-- cc covers 160 - Poly Aftertouch, 176 - CC, Bank/Program select, Bank select, 192 - Program change, 208 - Channel pressure (aftertouch), 224 - Pitch (bend)
-- Use the above numbers as lane indices bar CC lanes (176) for which actual CC# should be used in the range of 0-119
-- lane and ch are either tables or integers if only single lane or channel
-- lane property is irrelevant for notes
-- ch property is irrelevant to text, notation and sysex events
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local typ = evt_type:match('[nct]+')
local EnumEvts, GetEvt = table.unpack(not typ and {r.MIDI_EnumSelEvts, r.MIDI_GetEvt}
or typ == 'n' and {r.MIDI_EnumSelNotes, r.MIDI_GetNote}
or typ == 'c' and {r.MIDI_EnumSelCC, r.MIDI_GetCC}
or typ == 't' and {r.MIDI_EnumSelTextSysexEvts, r.MIDI_GetTextSysexEvt} or {})
local ch = type(ch) == 'table' and ch or {ch}
local lane = type(lane) == 'table' and lane or {lane}
local sel_evt_cnt = 0
local idx = -1 -- since EnumEvts returns the index of the next selected MIDI event, the first of which would be 0
	repeat
	idx = EnumEvts(take, idx)
		if idx == -1 then break end
	local evt_t = {GetEvt(take, idx)}
	local ch_match, lane_match
		if ch and typ ~= 't' then
			for _, ch in ipairs(ch) do
				if evt_t[6] == ch then ch_match = true break end -- in notes and cc event props ch is 6th return value
			end
		end
		if lane and typ ~= 'n' then
			for _, lane in ipairs(lane) do
				if evt_t[5] == 176 and lane == msg2 or evt_t[5] == cc then lane_match = true break end -- in cc event props chanmsg is 5th return value, for CC messages (chanmsg = 176) lane number (CC#) is returned as msg2 value, for non-CC messages instead of actual lane number chanmsg value is evaluated since it's supposed to be passed as lane argument into the function // when Bank/Program select lane is visible the number of selected events there is trippled because they're counted in lanes 0 and 32 as well
			end
		end

	if typ == 'n' then -- notes,
	sel_evt_cnt = idx > -1 and (ch and ch_match or not ch) and sel_evt_cnt+1 or sel_evt_cnt
	elseif typ == 'c' then
	sel_evt_cnt = idx > -1 and (ch and ch_match or not ch) and (lane and lane_match or not lane) and sel_evt_cnt+1 or sel_evt_cnt
	elseif typ == 't' then
	sel_evt_cnt = idx > -1 and (lane and lane_match or not lane) and sel_evt_cnt+1 or sel_evt_cnt
	else
	sel_evt_cnt = idx > -1 and sel_evt_cnt+1 or sel_evt_cnt
	end
	until idx == -1 -- -1 if there are no more or no selected events

return sel_evt_cnt

end



function notes_at_current_pitch_exist(ME, take, time_st, time_end, loop_st, loop_end)
-- if time_st or loop_st are valid, evaluation is only performed
-- within time selection or loop
local cur_pitch = r.MIDIEditor_GetSetting_int(ME, 'active_note_row') -- store
local i = 0
	repeat
	local retval, sel, mute, startpos, endpos, chan, pitch, vel = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
	local pos = r.MIDI_GetProjTimeFromPPQPos(take, startpos)
		if pitch == cur_pitch and not time_st and not loop_st
		or (time_st and time_end and pos >= time_st and pos < time_end
		or loop_st and loop_end and pos >= loop_st and pos < loop_end)
		then return true
		end
	i=i+1
	until not retval
end




function find_first_next_note(take, start_pos) -- the first which starts later than the given one (start_pos) which allows ignoring chord notes in case they start simultaneously
local retval, notecnt, _, _ = r.MIDI_CountEvts(take)
local i = 0
	while i < notecnt do
	local retval, _, _, start_pos_next, _, _, _, _ = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		if start_pos_next > start_pos then return start_pos_next end
	i = i+1
	end
end


function Notes_Overlap_Ignored_Chords(take) -- chord notes which start simultaneously are recognized as overlapping
local retval, notecnt, _, _ = reaper.MIDI_CountEvts(take)
local i = 0
	while i < notecnt do
	local retval, _, _, _, end_pos, _, _, _ = reaper.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
	local retval, _, _, start_pos, _, _, _, _ = reaper.MIDI_GetNote(take, i+1)
		if end_pos > start_pos and start_pos ~= 0 then return true end -- start_pos ~= 0 to ignore a non-existing note index beyond the note count whose start_pos will be 0
	i = i + 1
	end
end


function Notes_Overlap_Respected_Chords(take) -- chord notes which start simultaneously aren't recognized as overlapping
local retval, notecnt, _, _ = reaper.MIDI_CountEvts(take)
local i = 0
	while i < notecnt do
	local retval, _, _, start_pos1, end_pos, _, _, _ = reaper.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
	local retval, _, _, start_pos2, _, _, _, _ = reaper.MIDI_GetNote(take, i+1)
		if start_pos1 < start_pos2 and end_pos > start_pos and start_pos2 ~= 0 then return true end -- start_pos1 < start_pos2 makes sure that chord notes which start simultanelusly aren't recognized as overlapping, start_pos ~= 0 to ignore a non-existing note index beyond the note count whose start_pos will be 0
	i = i + 1
	end
end


function Correct_Overlapping_Notes1(take) -- chord notes with start simultaneously are recognized as overlapping, so chords aren't preserved
local retval, notecnt, _, _ = reaper.MIDI_CountEvts(take)
local i = 0
	while i < notecnt do
	local retval, _, _, _, end_pos, _, _, _ = reaper.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
	local retval, _, _, start_pos, _, _, _, _ = reaper.MIDI_GetNote(take, i+1)
		if end_pos > start_pos and start_pos ~= 0 then -- start_pos ~= 0 to ignore a non-existing note index beyond the note count whose start_pos will be 0 thereby preventing setting the last note end_pos to 0
		reaper.MIDI_SetNote(take, i, selectedIn, mutedIn, startppqposIn, start_pos, chanIn, pitchIn, velIn, true) -- noSortIn
		end
	i = i + 1
	end
reaper.MIDI_Sort(take)
end


function Correct_Overlapping_Notes2(take) -- chord notes with start simultaneously aren't recognized as overlapping, so chords are preserved, uniformly correcting chord notes against notes which start later
local retval, notecnt, _, _ = reaper.MIDI_CountEvts(take)
local i = 0
	while i < notecnt do
	local retval, _, _, start_pos1, end_pos, _, _, _ = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
	local retval, _, _, start_pos2, _, _, _, _ = r.MIDI_GetNote(take, i+1)
	if start_pos1 == start_pos2 then -- collect all notes statring simultaneously (chord notes)
	chord_notes_t[i], chord_notes_t[i+1] = 1, 1 -- dummy values
	elseif start_pos1 < start_pos2 and end_pos > start_pos2 and start_pos2 ~= 0 then -- as soon as an overlapping note  which starts later (the closest one) is found // start_pos1 < start_pos2 to ignore simultaneous chord notes, start_pos ~= 0 to ignore a non-existing note index beyond the note count whose start_pos will be 0 thereby preventing setting the last note end_pos to 0
		if next(chord_notes_t) then -- if the table isn't empty, i.e. there're chord notes starting simultaneously
			for note_idx in pairs(chord_notes_t) do -- correct them (trim down to the start of the closest overlapping note)
			r.MIDI_SetNote(take, note_idx, selectedIn, mutedIn, startppqposIn, start_pos2, chanIn, pitchIn, velIn, true) -- noSortIn
			end
		r.MIDI_Sort(take)
		chord_notes_t = {}
		else -- if no chord notes, simply correct the current note
		r.MIDI_SetNote(take, i, selectedIn, mutedIn, startppqposIn, start_pos2, chanIn, pitchIn, velIn, true) -- noSortIn
		end
	end
	i = i + 1
	end
r.MIDI_Sort(take)
end


local ME = r.MIDIEditor_GetActive()
local take = r.MIDIEditor_GetTake(ME)

function re_store_sel_MIDI_notes(take, deselect_all, t) 
-- store and restore (in the current MIDI channel if Channel filter is enabled)
-- deselect_all is boolean, only relevant at the storage stage

local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take)

	if not t then
	local sel_note_t = {}
		for i = 0, notecnt-1 do
		local retval, sel, mute, startpos, endpos, chan, pitch, vel = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
			if sel then sel_note_t[#sel_note_t+1] = i end
		end
	--[[ ALTERNATIVE
		local i = 0
			repeat
			local note = r.MIDI_EnumSelNotes(take, i)
				if note > -1 then sel_note_t[#sel_note_t+1] = i end
			i = i+1
			until note == -1
	]]	
		if deselect_all then
			for k, note_idx in ipairs(sel_note_t) do
			r.MIDI_SetNote(take, note_idx, false) -- selectedIn false, the rest is ignored
			end
		end
	return sel_note_t
	elseif #t > 0 then
		for _, v in ipairs(t) do
		r.MIDI_SetNote(take, v, true, false, -1, -1, 0, -1, -1, true) -- noteidx - v, selectedIn - true, mutedIn - false, startppqposIn and endppqposIn both -1, chanIn - 0, velIn -1, noSortIn - true since only one note params are set
		end
	end
	
r.MIDI_Sort(take)

end


local ME = r.MIDIEditor_GetActive()
local take = r.MIDIEditor_GetTake(ME)

function Mouse_Cursor_outside_painoroll_1(take) -- see a more efficient version below

r.PreventUIRefresh(1)
local ACT = r.MIDIEditor_LastFocused_OnCommand
local stored_edit_cur_pos = r.GetCursorPosition()
local item = r.GetMediaItemTake_Item(take)
ACT(40443, false) -- View: Move edit cursor to mouse cursor // islistviewcommand false
local edit_cur_pos = r.GetCursorPosition()

-----------------------------------------------------
ACT(40037, false) -- View: Go to end of file // islistviewcommand false
local item_end = r.GetCursorPosition()
ACT(40036, false) -- View: Go to start of file // islistviewcommand false
local item_start = r.GetCursorPosition()
--[[ OR
local edit_cur_pos = r.GetCursorPosition()
local item_start = r.GetMediaItemInfo_Value(item, 'D_POSITION')
local item_end = item_start + r.GetMediaItemInfo_Value(item, 'D_LENGTH')
]]
-----------------------------------------------------

r.SetEditCurPos(stored_edit_cur_pos, 0, 0) -- restore edit cursor pos; moveview is 0, seekplay is 0
r.PreventUIRefresh(-1)

	if edit_cur_pos >= item_end or edit_cur_pos <= item_start then
	return true end
	-- OR
	-- return edit_cur_pos >= item_end or edit_cur_pos <= item_start

end



function Mouse_Cursor_outside_painoroll_2(take)

local edit_cur_pos = r.GetCursorPosition()
local item = r.GetMediaItemTake_Item(take)
local item_st = r.GetMediaItemInfo_Value(item, 'D_POSITION')
local item_end = item_st + r.GetMediaItemInfo_Value(item, 'D_LENGTH')

return edit_cur_pos >= item_end or edit_cur_pos <= item_st

end



function Re_Store_Edit_Cursor_Pos_In_MIDI_Ed(stored_pos)
-- moves to mouse cursor, then restores
-- HOWEVER if within the MIDI Editor the edit cursor was initially located
-- to the left of the start in item which starts exactly at the project start
-- the cursor position will be registered as 0
-- and upon restoration the cursor will be moved to the item start
-- i.e. the project start, because it cannot be moved left past it 
-- into the negative even if manually it can

r.PreventUIRefresh(1)

	if not stored_pos then -- store
	
	local ACT = r.MIDIEditor_LastFocused_OnCommand
	local stored_pos = r.GetCursorPosition()
	ACT(40443, false) -- View: Move edit cursor to mouse cursor // islistviewcommand false
	local edit_cur_pos = r.GetCursorPosition()
	return stored_pos
	
	else -- restore

	r.SetEditCurPos(stored_pos, 0, 0) -- restore edit cursor pos; moveview is 0, seekplay is 0
	
	end

r.PreventUIRefresh(-1)

end
-- USE:
--local stored_pos = Re_Store_Edit_Cursor_Pos_In_MIDI_Ed()
-- DO STRUFF
--Re_Store_Edit_Cursor_Pos_In_MIDI_Ed(stored_pos)



function Get_Mouse_Coordinates_MIDI(wantSnapped) -- wantsnapped is boolean
-- inserts a note at mouse cursor, gets its pitch and start position and then deletes it
-- advised to use with Get_Note_Under_Mouse() to avoid other notes, that is only run this function if that function returns nil to be sure that there's no note under mouse and Mouse_Cursor_outside_painoroll() to make sure than the mouse cursor if within the piano roll because 'Edit: Insert note at mouse cursor' which is used here inserts notes even if the cursor is outside of the MIDI item bounds, see details in the comment to the action below

local ME = r.MIDIEditor_GetActive()
local take = r.MIDIEditor_GetTake(ME)
local is_snap = r.GetToggleCommandStateEx(32060, 1014) -- View: Toggle snap to grid
local ACT = r.MIDIEditor_LastFocused_OnCommand

r.PreventUIRefresh(1)
r.Undo_BeginBlock() -- to prevent creation of undo point by 'Edit: Insert note at mouse cursor' and 'Edit: Delete notes'

	if wantSnapped and is_snap == 0 or not wantSnapped and is_snap == 1 then
	ACT(1014, false) -- View: Toggle snap to grid // islistviewcommand false
	end

local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take)

local sel_note_t = {}
	for i = 0, notecnt-1 do -- store currently selected notes
	local retval, sel, mute, startpos, endpos, chan, pitch, vel = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		if sel then sel_note_t[#sel_note_t+1] = i end
	end

r.MIDI_SelectAll(take, false) -- deselect all notes so the inserted one is the only selected and can be gotten hold of

ACT(40001, false) -- Edit: Insert note at mouse cursor // islistviewcommand false // inserts a note even if mouse cursor already points at a note; if outside of the MIDI item left edge inserts a note at the item start, if outside of the right edge - inserts and extends the item if 'Loop item source' option is OFF or inserts in the parallel position within the item if this option is ON

local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take) -- re-count after insertion
local idx, x_coord, y_coord

		for i = 0, notecnt-1 do -- get index and cordinates of the inserted note which is selected by default and the only one selected since the rest have been deselected above; the coordinates correspond to the mouse cursor position wihtin piano roll
		local retval, sel, mute, startpos, endpos, chan, pitch, vel = r.MIDI_GetNote(take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
			if sel then idx, x_coord, y_coord = i, startpos, pitch break end
		end

--r.MIDI_DeleteNote(take, idx) -- delete the inserted note // buggy, lengthens the note overlaped by the one being deleted
-- https://forum.cockos.com/showthread.php?t=159848
-- https://forum.cockos.com/showthread.php?t=195709

ACT(40002, false) -- Edit: Delete notes // islistviewcommand false

--do return end

	-- restore note selection
	for _, idx in ipairs(sel_note_t) do
	r.MIDI_SetNote(take, idx, true, x, x, x, x, x, x, true) -- selectedIn true, mutedIn, startppqposIn, endppqposIn, chanIn, noSortIn are nil, noSort true since multiple notes
	end
	r.MIDI_Sort(take)
	-- restore orig Snap state
	local rest = r.GetToggleCommandStateEx(32060, 1014) ~= is_snap and ACT(1014, false)

r.PreventUIRefresh(-1)
r.Undo_EndBlock('',-1) -- to prevent creation of undo point by 'Edit: Insert note at mouse cursor' and 'Edit: Delete notes'

	if idx then
	return x_coord, y_coord, r.MIDI_GetProjTimeFromPPQPos(take, x_coord)
	-- OR return {x_coord, y_coord, r.MIDI_GetProjTimeFromPPQPos(take, x_coord)}
	end

end


local hwnd = r.MIDIEditor_GetActive()
local midi_take = r.MIDIEditor_GetTake(hwnd)

function Get_Note_Under_Mouse(hwnd, midi_take)
-- returns note index or nil if no note under mouse cursor
-- advised to use with Mouse_Cursor_outside_painoroll() because if mouse is outside of the MIDI item
-- the result will be nil as when there's no note under mouse

local ACT = r.MIDIEditor_OnCommand -- or r.MIDIEditor_LastFocused_OnCommand in which case hwnd arg isn't necessary

r.PreventUIRefresh(1)

ACT(hwnd, 40659) -- Correct overlapping notes // absolutely necessary because splitting overlapping notes breaks the entire edifice, the split action splits both
r.Undo_BeginBlock() -- to prevent creation of undo point by 'Edit: Split notes at mouse cursor' // if script creates its own undo point and this function is called inside the undo block undo here will interfere with the script undo block
local retval, notecntA, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(midi_take)
local props_t = {}
	for i = 0, notecntA-1 do -- collect current notes properties
	local retval, sel, muted, startppq, endppq, chan, pitch, vel = r.MIDI_GetNote(midi_take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
	props_t[#props_t+1] = {startppq, endppq, pitch}
	end
local snap = r.GetToggleCommandStateEx(32060, 1014) == 1 -- View: Toggle snap to grid
local off = snap and ACT(hwnd, 1014) -- disable snap
ACT(hwnd, 40052) -- Edit: Split notes at mouse cursor
local on = snap and ACT(hwnd, 1014) -- re-enable snap
local retval, notecntB, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(midi_take) -- re-count after split
local idx, fin, note
	if notecntB > notecntA then -- some note was split
		for i = 0, notecntB-1  do
		retval, sel, muted, startppq, endppq, chan, pitch, vel = r.MIDI_GetNote(midi_take, i) -- only targets notes in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
			--[[-- INEFFICIENT
			if not idx then -- locate the 1st part of the split note
				for k, v in ipairs(props_t) do
					if k-1 == i -- k-1 since table index is 1-based while note count is 0-based; the 1st part of the note will keep the note original index after split and after restoration
					and startppq == v[1] and endppq ~= v[2] and pitch == v[3] then
					idx, fin, note = i, endppq, pitch
					break end
				end
			elseif idx and startppq == fin and pitch == note then -- locate the 2nd part of the split note
			r.MIDI_DeleteNote(midi_take, i) -- delete the 2nd part
			r.MIDI_SetNote(midi_take, idx, false, false, -1, endppq, -1, -1, -1, false) -- restore the note original length // selected false, muted false; startppq, chan, pitch, vel all -1, noSort false
			return idx end
			---]]-----
		local v = props_t[i+1] -- +1 since table index is 1-based while note count is 0-based; the 1st part of the note will keep the note original index after split and after restoration
			if v and startppq == v[1] and endppq ~= v[2] and pitch == v[3] then
			idx, fin, note = i, endppq, pitch 
			end
			if idx and startppq == fin and pitch == note then -- locate the 2nd part of the split note
			r.MIDI_DeleteNote(midi_take, i) -- delete the 2nd part
			r.MIDI_SetNote(midi_take, idx, x, x, x, endppq, x, x, x, false) -- restore the note original length // selected, muted, startppq, chan, pitch, vel all nil, noSort false because only one note is affected
			return idx end
		end
	end
r.PreventUIRefresh(-1)
r.Undo_EndBlock('',-1) -- to prevent creation of undo point by 'Edit: Split notes at mouse cursor'
end



function is_dotted(num) -- find if a note is already dotted, arg is duration in QN
-- https://www.liveabout.com/music-theory-101-dotted-notes-rests-4686771
-- https://hellomusictheory.com/learn/dotted-notes/
--local t = {0.03125, 0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8} -- 1/128, 1/64, 1/32, 1/16, 1/8, 1/4, 1/2, 1, 2 // if using raw QN value num/1.5
local t = {0.5, 1, 2, 4, 8, 16, 32, 64, 128} -- 2 whole notes, whole, breve, crotchet, eighth, sixteenth etc // if converting raw QN value to fraction of a quarter note: 4/(num/1.5)
local num = 4/(num/1.5)
	for _, div in ipairs(t) do
		if num == div then return true end
	end
end


function round_note(num)
-- used in 'Convert selected notes to dotted'
-- round note duration down or up to the closest straight musical division
--local t = {0.03125, 0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8} -- 1/128, 1/64, 1/32, 1/16, 1/8, 1/4, 1/2, 1, 2 // if using  raw QN value
local t = {0.5, 1, 2, 4, 8, 16, 32, 64, 128} -- 2 whole notes, whole, breve, crotchet, eighth, sixteenth etc // if converting raw QN value to fraction of a quarter note: 4/num, the return value must then be converted back to raw QN: 4/return value
	for k, div in ipairs(t) do
		if num == div then return div end
	local nxt = t[k+1]
		if nxt and num > div and num < nxt then
			if num - div < nxt - num then
			return div
			else return nxt
			end
		elseif k == 1 and num < div
		or k == #t and num > div
		then return div
		end
	end
end



function is_CC_Env_active(ME, take) -- whether there're events
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local cur_CC_lane = r.MIDIEditor_GetSetting_int(ME, 'last_clicked_cc_lane') -- last clicked if several lanes are displayed, otherwise currently visible lane
local cur_CC_lane = cur_CC_lane == 513 and 224 or cur_CC_lane == 515 and 208 or cur_CC_lane == 514 and 192 or cur_CC_lane -- converting  MIDIEditor_GetSetting_int() function return values to MIDI_GetCC() chanmsg return value: pitch bend, channel pressure, program change, regular CC
local evt_idx = 0
	repeat
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- Velocity / Off Velocity / Text events / Notation enents / SySex lanes are ignored || only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel
	-- Watch out for 'Bank/Program select' lane (chanmsg 176 but no dedicated lane number) because the number of events there is trippled as they're counted in lanes 0 and 32 as well
		if retval then
			if chanmsg == 176 and msg2 == cur_CC_lane then return msg2  -- CC message, chanmsg = 176 // as soon as event is found in the current lane
			elseif chanmsg == cur_CC_lane then -- non-CC message (chanmsg =/= 176)
			return chanmsg == 192 and 'Program change' or chanmsg == 208 and 'Channel pressure' or chanmsg == 224 and 'Pitch bend'
			end
		end
	evt_idx = evt_idx + 1
	until not retval
end


-- USE THIS, COMPREHENSIVE FUNCTION or Get_Currently_Active_Chan_And_Filter_State2()
function Get_Currently_Active_Chan_And_Filter_State1(ME, take)
-- returns number of currently active channel is channel filter is enabled or multiple active channels if multichannel mode is enabled
-- if filter isn't enabled and no multichannel mode, the returned table will be empty and the filter state will be nil
-- MIDI Ed actions toggle state can only be evaluated when ME is open
local is_open = ME or r.MIDIEditor_GetActive() -- check if MIDI Editor is open // USE FUNCTION MIDIEditor_GetActiveAndVisible() instead because if MIDI Editor is docked and the docker is closed it remains active without being visible
-- OR
-- local is_open = ME or r.GetToggleCommandStateEx(32060, 40218) > -1
local open = not is_open and r.Main_OnCommand(40153, 0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
local ME = r.MIDIEditor_GetActive()
local take = not take and r.MIDIEditor_GetTake(ME) or take
local act_ch_t, filter_state = {}

	for i = 40218, 40233 do -- ID range of actions 'Channel: Show only channel X' which select a channel in the filter and enable the filter
-- 	for i = 40643, 40658 do -- ID range of actions 'Channel: Toggle channel X' -- unsuitable since these aren't mutually exclusive, they apply to the filter Multichannel mode
		if r.GetToggleCommandStateEx(32060, i) == 1 then
		filter_state = i-40217 break end -- currently active channel 1-based
	end

	for i = 40643, 40658 do -- ID range of actions 'Channel: Toggle channel X' which activate the Multichannel mode and aren't mutually exclusive
		if r.GetToggleCommandStateEx(32060, i) == 1 then
		act_ch_t[#act_ch_t+1] = i-40642 -- store 1-based ch #
		end
	end

	if not is_open then r.MIDIEditor_LastFocused_OnCommand(2, false) end -- File: Close window; islistviewcommand false

-- the table is empty and filter_state is false when the filter isn't enabled and some channel is selected in its drop-down menu or when All channels option is enabled regardless of filter actual state
-- the table contains a single channel and filter_state is assigned a channel number when the filter is enabled and a single channel is exclusively displayed by being selected in the filter drop-down menu
-- the table contains several channels and filter_state is true when Multichannel mode is enabled
-- so basically unlike the next Get_Currently_Active_Chan_And_Filter_State2() function this function cannot detect a single channel selected in the filter when the filter is OFF
return act_ch_t, filter_state

end


-- USE THIS, COMPREHENSIVE FUNCTION
function Get_Currently_Active_Chan_And_Filter_State2(obj, ME) -- via chunk, ME is MIDI Editor pointer
-- returns channel filter status and the channels currently selected in the filter regardless of its being enabled in 1-BASED COUNT
-- for a single active channel when filter is enabled see Get_Ch_Selected_In_Ch_Filter() or Ch_Filter_Enabled1()
-- filter enabled status is true when either a single channel is active, multichannel mode is active or 'Show only events that pass the filter' option is checked in the Event filter dialogue and can be true when 'All channels' option is active in the menu as well;
-- when the table contains a single channel this means this channel is selected in the filter drop-down menu, in this case the filter status indicates whether this channel is exclusively displayed;
-- when the table contains several channels the filter state is always true;
-- the table's being empty means that ALL channels are active, i.e. 'All channels' option is selected in the filter drop-down menu while filter isn't enabled, filter_state will be false, in this case last active channel will be returned;
-- 16 entries in the table mean that ALL channels are active, i.e. 'All channels' option is selected while the filter is enabled, filter_state will be true
local item = r.ValidatePtr(obj, 'MediaItem*')
local take = r.ValidatePtr(obj, 'MediaItem_Take*')
local item = item and obj or take and r.GetMediaItemTake_Item(obj)
	if not item then return end
local take = take and obj or r.GetActiveTake(item)
local retval, takeGUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo
local takeGUID = takeGUID:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- escape
local take_found
--local ch_bit_t = {1,2,4,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536}
local act_ch_t, filter_state = {}
	for line in chunk:gmatch('[^\n\r]+') do
		if line:match(takeGUID) then take_found = 1 end
		if take_found and line:match('EVTFILTER') then
		local cnt = 0
			for val in line:gmatch('[%-%d]+') do
			cnt = val and cnt+1 or cnt
				if cnt == 7 then filter_state = val break end -- filter boolean is 7th field
			end
		local val = line:match('EVTFILTER (%d+)')
			if val then
				for i = 0, 15 do
				local bit = 2^i
					if val+0&bit == bit then -- channel numbers are 0-based logarithm of the value from the chunk with base 2 // +0 is accommodating for Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
					act_ch_t[#act_ch_t+1] = i+1 -- 1-based channel number // can be changed
					end
				end
			break end -- break to prevent chunk loop from continuing and getting data from next takes because take_found remains valid, it could be reset to nil at this point but this wouldn't stop the chunk loop
		end
	end
return #act_ch_t > 0 and act_ch_t or {r.MIDIEditor_GetSetting_int(ME, 'default_note_chan')+1}, filter_state == '1' -- 1-based last active channel number
end



------------ THESE ARE CUT-DOWN VERSIONS OF THE ABOVE Get_Currently_Active_Chan_And_Filter_State 1 & 2 ----------------------
function Ch_Filter_Enabled1(ME, take)
-- MIDI Ed actions toggle state can only be evaluated when ME is open
-- returns 1-based # of a channel currently selected in the enabled channel filter so only supports exclusively displayed channel, not Multichannel mode
local is_open = ME or r.MIDIEditor_GetActive() -- check if MIDI Editor is open
-- OR
-- local is_open = ME or r.GetToggleCommandStateEx(32060, 40218) > -1
local open = not is_open and r.Main_OnCommand(40153, 0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
local ME = r.MIDIEditor_GetActive()
local take = not take and r.MIDIEditor_GetTake(ME) or take
local filter_on
	for i = 40218, 40233 do -- ID range of actions 'Channel: Show only channel X' which select a channel in the filter and enable the filter
-- 	for i = 40643, 40658 do -- ID range of actions 'Channel: Toggle channel X' -- unsuitable since these aren't mutually exclusive, they apply to the filter Multichannel mode
		if r.GetToggleCommandStateEx(32060, i) == 1 then
			if not is_open then r.MIDIEditor_LastFocused_OnCommand(2, false) end -- File: Close window; islistviewcommand false
		return i-40217 end -- currently active channel 1-based
	end
	if not is_open then r.MIDIEditor_LastFocused_OnCommand(2, false) end -- File: Close window; islistviewcommand false // in case the loop didn't exit early
end


function Ch_Filter_Enabled2(obj) -- via chunk, no need to open the MIDI Ed
-- filter enabled status is true when either a single channel is active, multichannel mode is active or 'Show only events that pass the filter' option is checked in Event filter dialogue and can be true when 'All channels' option is active in the menu as well

	local function get_enabled_channels(channel_bitfield)
	local t = {}
		for i = 0, 15 do
		local bit = 2^i
		local set = channel_bitfield+0&bit == bit
			if set then t[i] = set end -- i is 0-based channel number
		end
	return t
	end

local item = r.ValidatePtr(obj, 'MediaItem*')
local take = r.ValidatePtr(obj, 'MediaItem_Take*')
local item = item and obj or take and r.GetMediaItemTake_Item(obj)
	if not item then return end
local take = take and obj or r.GetActiveTake(item)
local retval, takeGUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo
local takeGUID = takeGUID:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- escape
local take_found, channel_bitfield
	for line in chunk:gmatch('[^\n\r]+') do
		if line:match(takeGUID) then take_found = 1 end
		if take_found and line:match('EVTFILTER') then
		local cnt = 0
			for val in line:gmatch('[%-%d]+') do
			cnt = val and cnt+1 or cnt
			channel_bitfield = channel_bitfield or cnt == 1 and val
				if cnt == 7 then -- filter boolean is 7th field
				return val == '1', get_enabled_channels(channel_bitfield) end 
			end
		end
	end
end


function Get_Ch_Selected_In_Ch_Filter(obj)
-- return value is 1-based channel # regardless of whether the filter is enabled or not, or nil if several channels are selected in 'Multichannel' mode or 'All channels' so doesn't support Multichannel mode, ONLY SUPPORTS 1 ACTIVE CHANNEL
local item = r.ValidatePtr(obj, 'MediaItem*')
local take = r.ValidatePtr(obj, 'MediaItem_Take*')
local item = item and obj or take and r.GetMediaItemTake_Item(obj)
	if not item then return end
local take = take and obj or r.GetActiveTake(item)
local retval, takeGUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo
local takeGUID = takeGUID:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- escape
local take_found
	for line in chunk:gmatch('[^\n\r]+') do
		if line:match(takeGUID) then take_found = 1 end
		if take_found and line:match('EVTFILTER') then
		local val = line:match('EVTFILTER (%d+)')
			if val then
				for i = 0, 15 do
					if val+0 == 2^i then return i+1 end -- channel numbers are 0-based logarithm of the value from the chunk with base 2 // THIS ONLY RETURNS CORRECT VALUE IF ONE CHANNEL ENABLED ONLY, SEE PROPER WAY IN Ch_Filter_Enabled2() above
				end
			--[[ OR without the loop
			-- https://www.gammon.com.au/scripts/doc.php?lua=math.log
			local chan_No = math.log(val)/math.log(2)
			return chan_No == math.floor(chan_No) and chan_No+1 -- if integer
			]]
			end
		end
	end
end
--------- THESE ARE CUT-DOWN VERSIONS OF THE ABOVE Get_Currently_Active_Chan_And_Filter_State 1 & 2 END ---------------


function Prompt_to_Enable_MIDI_Ch_Filter(ME, take) -- for scripts where selection of one MIDI channel is essencial due to the use of Re_Store_Selected_CCEvents3() since there's no way to ascertain that a channel is actually selected in the channel filter

-- MIDI Ed actions toggle state can only be evaluated when ME is open
local ME = ME or r.MIDIEditor_GetActive()
local take = not take and r.MIDIEditor_GetTake(ME) or take

-- MIDIEditor_GetSetting_int(ME, 'default_note_chan') used inside Re_Store_Selected_CCEvents3() is unreliable in getting the current channel because when 'All Channels' or 'Multichannel' option is selected in the Channel filter it still returns the last active channel which may not be the channel the user intends to use as the source but which will be selected by Re_Store_Selected_CCEvents3() restore routine and if such channel has no events the script will throw an error message about absence of valid selected events, hence the need to make the user select the channel explicitly; restoring the channel selection to 'All Channels' in this case will not look consistent if the user initially had channel selected (some bits refer to the script 'Copy or Move selected notes and/or other MIDI events in visible lanes to specified MIDI channels')

local filter_on
	for i = 40218, 40233 do -- ID range of actions 'Channel: Show only channel X' which select a channel in the filter and enable the filter
-- 	for i = 40643, 40658 do -- ID range of actions 'Channel: Toggle channel X' -- unsuitable since these aren't mutually exclusive and apply to the filter Multichannel mode which must be avoided in this script exactly like 'All channels'
		if r.GetToggleCommandStateEx(32060, i) == 1 then filter_on =  1 break end
	end
	if not filter_on then
	local s = ' '
	r.MB(s:rep(10)..'The script only supports one source channel.\n\n   It appears that the MIDI channel filter is not enabled.\n\n\t'..s:rep(6)..'For the script to work reliably\n\n  please select the MIDI channel in the filter and enable it.', 'ALERT', 0)
	return true end
end
-- USE:
-- if Prompt_to_Enable_MIDI_Ch_Filter() then return r.defer(function() do return end end) end




function Re_Store_Selected_CCEvents1(ME, take, t)
-- !!!! will work if no events were deleted or added in the interim regardless of the MIDI channel
-- if channel filter is enabled per channel clicking within one MIDI channel doesn't affect event selection in other MIDI channels
-- if channel filter is enabled per channel deleting selected events in one MIDI channel with action doesn't affect selected events in other MIDI channels; in the same MIDI channels selected events are deleted regardless of their lane visibility
-- with the mouse CC events can only be selected in one lane, the selection is exclusive just like track automation envelope nodes unless Shift is held down, marque selection or Ctrl+A are used
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take

	if not t then
	local t, evt_idx = {}, 0
		repeat
		local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
			if sel then t[#t+1] = evt_idx -- store and deselect
			r.MIDI_SetCC(take, evt_idx, false, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn false, noSortIn true // deselect
			end
		evt_idx = evt_idx+1
		until not retval
	r.MIDI_Sort(take)
--	r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation
	return t
	else
--	r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation
	local evt_idx = 0
		repeat -- deselect all
		local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- just to use retval to stop the loop // only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		r.MIDI_SetCC(take, evt_idx, false, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn false, noSortIn true // deselect
		evt_idx = evt_idx+1
		until not retval
	r.MIDI_Sort(take)
		for _, evt_idx in ipairs(t) do -- restore
		r.MIDI_SetCC(take, evt_idx, true, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn, noSortIn true
		end
	r.MIDI_Sort(take)
	end
end


function Re_Store_Selected_CCEvents2(ME, take, t, deselect_before_restore) -- deselect_before_restore is boolean
-- !!!! will work EVEN IF events were deleted or added in the interim BUT FOR THE  CURRENTLY ACTIVE MIDI CHANNELS IF THE MIDI FILTER IS ENABLED
-- if channel filter is enabled per channel clicking within one MIDI channel doesn't affect event selection in other MIDI channels
-- if channel filter is enabled per channel deleting selected events in one MIDI channel with action doesn't affect selected events in other MIDI channels; in the same MIDI channels selected events are deleted regardless of their lane visibility
-- with the mouse CC events can only be selected in one lane, the selection is exclusive just like track automation envelope nodes unless Shift is held down, marque selection or Ctrl+A are used
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take

	if not t then
	local t, evt_idx = {}, 0
		repeat
		local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
			if sel then
			t[#t+1] = {retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3, evt_idx} -- store and deselect // evt_idx is stored to be able to reselect events in the visible lanes with Only_Select_Evnts_In_Visble_CC_Lanes() after using Get_Currently_Visible_CC_Lanes()
			r.MIDI_SetCC(take, evt_idx, false, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn false, noSortIn true // deselect
			end
		evt_idx = evt_idx+1
		until not retval
	r.MIDI_Sort(take)
--	r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation
	return t
	else
--	r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation
		if deselect_before_restore then
		local evt_idx = 0
			repeat -- deselect all
			local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- just to use retval to stop the loop // probably MIDI_SetCC() boolean return value could be used instead //  only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
			r.MIDI_SetCC(take, evt_idx, false, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn false, noSortIn true // deselect
			evt_idx = evt_idx+1
			until not retval
		r.MIDI_Sort(take)
		end
	r.MIDI_Sort(take)
	local evt_idx = 0
		repeat
		local evt_data = {r.MIDI_GetCC(take, evt_idx)} -- only targets events in the current MIDI channel if Channel filter is enabled
	--	local restore
			for _, evt_data_stored in ipairs(t) do
			local match = 0
				for i = 3, 8 do -- extract and compare values one by one; only 6 values are relevant, 3 - 8, i.e. muted, ppqpos, chanmsg, chan, msg2, msg3
				local val1 = table.unpack(evt_data, i, i) -- the 3d argument isn't really necessary since even when multiple values are returned starting from index up to the end, only the first one is stored
				local val2 = table.unpack(evt_data_stored, i, i)
					if val1 == val2 then match = match+1 end
			 -- OR
			 -- match = evt_data[i] == evt_data_stored[i] and match+1 or match
				end
				if match == 6 then restore = 1 break end -- 6 return values match
			-- OR
			-- if match == 6 then break end -- 6 return values match
			end
			if restore then -- restore
		 -- OR
		 -- if match == 6 then
			local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = table.unpack(evt_data) -- if only selection and event count changed these values aren't needed
			r.MIDI_SetCC(take, evt_idx, true, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn, noSortIn true
			end
		evt_idx = evt_idx+1
		until not evt_data[1] -- retval
	r.MIDI_Sort(take)
	end
end


function Re_Store_Selected_CCEvents3(ME, take, t, deselect_before_restore) -- deselect_before_restore is boolean
-- !!!! will work EVEN IF events were deleted or added in the interim FOR ALL MIDI CHANNELS
-- if channel filter is enabled per channel clicking within one MIDI channel doesn't affect event selection in other MIDI channels
-- if channel filter is enabled per channel deleting selected events in one MIDI channel with action doesn't affect selected events in other MIDI channels; in the same MIDI channels selected events are deleted regardless of their lane visibility
-- with the mouse CC events can only be selected in one lane, the selection is exclusive just like track automation envelope nodes unless Shift is held down, marque selection or Ctrl+A are used
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local cur_chan = r.MIDIEditor_GetSetting_int(ME, 'default_note_chan') -- 0-15 // returns last channel when channel filter is set to 'All Channels' or 'Multichannel'
local cur_ch_comm_ID = 40218 + cur_chan -- 40218 is 'Channel: Show only channel 01' // will be used to restore current channel after traversing all

-- if channel filter isn't enabled, it's either set to 'All channels' or to a specific channel BUT actions 'Set channel for new events to ...' which switch channels in the filter keeping it OFF only change their toggle state to ON if 'Channel: Show only channel ...' are ON as well, bug report https://forum.cockos.com/showthread.php?t=276748, so cannot be used to determine if a channel is selected in the filter while the filter is OFF, hence we're left with All channels ('Channel: Show all channels' ID 40217) as the only option also because it's not possible to use 'Set channel for new events to ...' (40482 - 40497) to disable the filter and set it to another (original) channel, since while the filter is enabled these behave exactly like 'Channel: Show only channel ...' and the only way to disable the filter is to use 'Channel: Show all channels' which effectively makes it switch to All channels option, and also because 'Set channel for new events to ...' doesn't make the filter switch if the filter is set to All channels

	if not t then
	r.PreventUIRefresh(1)
	local t = {}
		for ch = 0, 15 do
		local comm_ID = 40218 + ch -- construct command ID for the next action 'Channel: Show only channel N'; starting from 1
		r.MIDIEditor_LastFocused_OnCommand(comm_ID, false) -- islistviewcommand false // select MIDI channel
		local evt_idx = 0
			repeat
			local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
				if sel then
				t[#t+1] = {retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3, evt_idx} -- store and deselect // evt_idx is stored to be able to reselect events in the visible lanes with Only_Select_Evnts_In_Visble_CC_Lanes() after using Get_Currently_Visible_CC_Lanes()
				r.MIDI_SetCC(take, evt_idx, false, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn false, noSortIn true // deselect
				end
			evt_idx = evt_idx+1
			until not retval
		r.MIDI_Sort(take)
		end
	--	r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation https://forum.cockos.com/showthread.php?t=272887
	r.MIDIEditor_LastFocused_OnCommand(cur_ch_comm_ID, false) -- islistviewcommand false // restore original channel
	r.PreventUIRefresh(-1)
	return t
	else
	r.PreventUIRefresh(1)
--	r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation
		if deselect_before_restore then
			for ch = 0, 15 do
			local comm_ID = 40218 + ch -- construct command ID for the next action 'Channel: Show only channel N'; starting from 1
			r.MIDIEditor_LastFocused_OnCommand(comm_ID, false) -- islistviewcommand false // select MIDI channel
			local evt_idx = 0
				repeat -- deselect all
				local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- just to use retval to stop the loop // probably MIDI_SetCC() boolean return value could be used instead || only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
				r.MIDI_SetCC(take, evt_idx, false, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn false, noSortIn true // deselect
				evt_idx = evt_idx+1
				until not retval
			r.MIDI_Sort(take)
			end
		end
		for ch = 0, 15 do
		local comm_ID = 40218 + ch -- construct command ID for the next action 'Channel: Show only channel N'; starting from 1
		r.MIDIEditor_LastFocused_OnCommand(comm_ID, false) -- islistviewcommand false // select MIDI channel
		local evt_idx = 0
			repeat
			local evt_data = {r.MIDI_GetCC(take, evt_idx)} -- only targets events in the current MIDI channel if Channel filter is enabled
			local restore
				for _, evt_data_stored in ipairs(t) do
				local match = 0
					for i = 3, 8 do -- extract and compare values one by one; only 6 values are relevant, 3 - 8, i.e. muted, ppqpos, chanmsg, chan, msg2, msg3
					local val1 = table.unpack(evt_data, i, i) -- the 3d argument isn't really necessary since even when multiple values are returned starting from index up to the end, only the first one is stored
					local val2 = table.unpack(evt_data_stored, i, i)
						if val1 == val2 then match = match+1 end
				 -- OR
				 -- match = evt_data[i] == evt_data_stored[i] and match+1 or match
					end
					if match == 6 then restore = 1 break end -- 6 return values match
				 -- OR
				 -- if match == 6 then break end -- 6 return values match
				end
				if restore then -- restore
			 -- OR
			 -- if match == 6 then
				local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = table.unpack(evt_data) -- if only selection and event count changed these values aren't needed
				r.MIDI_SetCC(take, evt_idx, true, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn, noSortIn true // only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for events from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
				end
			evt_idx = evt_idx+1
			until not evt_data[1] -- retval
		r.MIDI_Sort(take)
		end
	r.MIDIEditor_LastFocused_OnCommand(cur_ch_comm_ID, false) -- islistviewcommand false // restore original channel
	r.PreventUIRefresh(-1)
	end

end


-- VISIBLE actually means selected in the left hand CC lane menu, regardless of its being collapsed or not
function Get_Currently_Visible_CC_Lanes(ME, take) -- WITH EVENTS ONLY, must be preceded and followed by Re_Store_Selected_CCEvents3() because it changes selection
-- lanes of 14-bit CC messages aren't supported because the action 40802 'Edit: Select all CC events in time selection (in all visible CC lanes)' doesn't select their events, it only does if their 7-bit lane is open; doesn't affect non-CC lanes; doesn't deselect events in invisible lanes
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local item = r.GetMediaItemTake_Item(take)
local pos = r.GetMediaItemInfo_Value(item, 'D_POSITION')
local fin = pos + r.GetMediaItemInfo_Value(item, 'D_LENGTH')
local time_st, time_end = r.GetSet_LoopTimeRange(false, false, 0, 0, false) -- isSet, isLoop, allowautoseek false // store
r.GetSet_LoopTimeRange(true, false, pos, fin, false) -- isSet true, isLoop, allowautoseek false // create time sel
r.PreventUIRefresh(1)
--r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation

-- DESELECTION OF ALL MUST BE HANDLED BY Re_Store_Selected_CCEvents3() instead of the above action

r.MIDIEditor_LastFocused_OnCommand(40802, false) -- islistviewcommand false // Edit: Select all CC events in time selection (in all visible CC lanes) -- DOESN'T AFFECT non-CC events BUT IGNORES visible 14 bit CC lanes // EXCLUSIVE, i.e. deselects all other CC events
-- https://forum.cockos.com/showthread.php?t=272887
local idx = -1 -- start with -1 since MIDI_EnumSelCC returns idx of the next event hence will actually start from 0
local evt_t, ch_t = {}, {}
	repeat
	idx = r.MIDI_EnumSelCC(take, idx)
		if idx > -1 then
		local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, idx) -- point indices are based on their time position hence points with sequential indices will likely belong to different CC envelopes // only targets events in the current MIDI channel if Channel filter is enabled // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		local stored
			for _, cc in ipairs(evt_t) do
				if cc == msg2 or cc == chanmsg then stored = 1 break end
			end
			if not stored then evt_t[#evt_t+1] = chanmsg == 176 and msg2 or chanmsg  -- only collect unique numbers of CC messages (chanmsg = 176) for which msg2 value represents CC#, or non-CC messages which have channel data (chanmsg is not 176) for which msg2 value doesn't represent CC#; chanmsg = Pitch bend - 224, Program - 192, Channel pressure - 208, Poly aftertouch - 160
			end
		local stored
			for _, ch in ipairs(ch_t) do
				if ch == chan then stored = 1 break end
			end
			if not stored then ch_t[#ch_t+1] = chan end
		end
--	i = i+1
	until idx == -1
--[[ ALSO WORKS
local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take)
	for i = 0, ccevtcnt-1 do
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, i) -- point indices are based on their time position hence points with sequential indices will likely belong to different CC envelopes
		for _, cc in ipairs(evt_t) do
			if cc == msg2 or cc == chanmsg then stored = 1 break end
		end
		if not stored then evt_t[#evt_t+1] = chanmsg == 176 and msg2 or chanmsg -- only collect unique numbers of CC messages (chanmsg = 176) for which msg2 value represents CC#, or non-CC messages which have channel data (chanmsg is not 176) for which msg2 value doesn't represent CC#; chanmsg = Pitch bend - 224, Program - 192, Channel pressure - 208, Poly aftertouch - 160
		ch_t[#ch_t+1] = chan
		end
	end
--]]

--r.MIDIEditor_LastFocused_OnCommand(40671, false) -- islistviewcommand false // Unselect all CC events -- IN FACT DESELECTS EVEN non-CC events such as text and notation

-- DESELECTION OF ALL MUST BE HANDLED BY Re_Store_Selected_CCEvents3() instead of the above action

r.GetSet_LoopTimeRange(true, false, time_st, time_end, false) -- isSet true, isLoop, allowautoseek false // restore
r.PreventUIRefresh(-1)
table.sort(evt_t) table.sort(ch_t)
return evt_t, ch_t

end


-- VISIBLE actually means selected in the left hand CC lane menu, regardless of its being collapsed or not
function Only_ReSelect_Evnts_In_Visble_CC_Lanes(sel_evts_t, vis_lanes_t, evt_ch_t, take)
-- Only re-select originally selected events in the visible lanes // can be modified to select all events in visible lanes whether originally selected or not
-- sel_evts_t and vis_lanes_t are tables returned by Re_Store_Selected_CCEvents3() and Get_Currently_Visible_CC_Lanes() above respectively
-- evt_ch_t is returned by Get_Currently_Active_Chan_And_Filter_State() function
-- search by index isn't reliable as they change after sorting, so all return values must be collated to find originally selected events bar selected status value because at this stage the event won't be selected; this loop basically searches for current indices of the stored events so they can be re-selected
Re_Store_Selected_CCEvents3(take) -- deselect all
local i = 0
	repeat
		local evt_data = {r.MIDI_GetCC(take, i)}
		for _, sel_evts_data in ipairs(sel_evts_t) do
		local match_cnt = 0
			for i = 3, 8 do
			match_cnt = evt_data[i] == sel_evts_data[i] and match_cnt+1 or match_cnt
			end
			if match_cnt == 6 then -- original event found in sel_evts_t table
			local chmsg, chan, msg2 = table.unpack(sel_evts_data,5,7)
			-- determine if the original event belongs to one of the visible lanes, 14-bit lane events aren't supported
			local evt_match
				for _, cc in ipairs(vis_lanes_t) do
					if chmsg == 176 and cc == msg2 -- CC message, chanmsg = 176
					or chmsg == cc then -- non-CC message (chanmsg =/= 176) which has channel data, such as Pitch, Channel pressure, ProgramChange and for which chanmsg value is stored instead since it's unique while their msg2 value doesn't refer to the CC#
					evt_match = 1
					break end
				end
				-- when channel filter is enabled per channel or multichannel mode is enabled, belonging to one of the visible lanes isn't enough because the channel an event belongs to may not be visible
				if evt_match then
					for _, ch in ipairs(evt_ch_t) do
						if chan == ch-1 then -- ch-1 because channels are stored by Get_Currently_Active_Chan_And_Filter_State() using 1-based count
						r.MIDI_SetCC(take, i, true, mutedIn, ppqposIn, chanmsgIn, chanIn, msg2In, msg3In, true) -- selectedIn, noSortIn true
						break end
					end
				end
			end
		end
	until not evt_data[1]

r.MIDI_Sort(take)

end


-- VISIBLE actually means selected in the left hand CC lane menu, regardless of its being collapsed or not
function Get_Visible_Lanes_With_Selected_Events(ME, take, vis_lanes_t) -- vis_lanes_t stems from Get_Currently_Visible_CC_Lanes() function
-- 14-bit lanes aren't supported if Get_Currently_Visible_CC_Lanes() was used
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
-- Find numbers of the message types of visible lanes with selected events
local lanes_with_sel_evts_t, ch_t = {}, {}
local evt_idx = 0
	repeat
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel
		if sel then
			for _, cc in ipairs(vis_lanes_t) do
				if chanmsg == 176 and cc == msg2 -- CC message, chanmsg = 176
				or chanmsg == cc then -- non-CC message (chanmsg =/= 176) which has channel data, such as Pitch, Channel pressure, ProgramChange and for which chanmsg value is stored instead since it's unique while their msg2 value doesn't refer to the CC#
				local stored
					for _, cc2 in ipairs(lanes_with_sel_evts_t) do
						if cc == cc2 then stored = true break end
					end
					if not stored then
					local len = #lanes_with_sel_evts_t+1
					lanes_with_sel_evts_t[len] = chanmsg == 176 and msg2 or chanmsg -- only collect unique numbers of CC messages (chanmsg = 176) for which msg2 value represents CC#, or non-CC messages which have channel data (chanmsg is not 176) for which msg2 value doesn't represent CC#; chanmsg = Pitch bend - 224, Program - 192, Channel pressure - 208, Poly aftertouch - 160
					end
				local stored
					for _, ch in ipairs(ch_t) do
						if ch == chan then stored = 1 break end
					end
					if not stored then ch_t[#ch_t+1] = chan end
				end
			end
		end
	evt_idx = evt_idx+1
	until not retval
return lanes_with_sel_evts_t, ch_t
end



function Get_CC_Lanes_With_Selected_Events(ME, take) -- if preceded by the sequence of functions Re_Store_Selected_CCEvents3(), Get_Currently_Visible_CC_Lanes(), Re_Store_Selected_CCEvents3(ME, take) to deselect all, and Only_ReSelect_Evnts_In_Visble_CC_Lanes() amounts to getting visible CC lanes with selected events
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
-- Find numbers of the message types of visible lanes with selected events
local i = -1 -- start with -1 since MIDI_EnumSelCC returns idx of the next event hence will actually start from 0
local t = {}
	repeat
	local idx = r.MIDI_EnumSelCC(take, i)
		if idx > -1 then
		local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, idx) -- point indices are based on their time position hence points with sequential indices will likely belong to different CC envelopes // only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		local stored
			for _, cc in ipairs(t) do
				if cc == msg2 or cc == chanmsg then stored = 1 break end
			end
			if not stored then t[#t+1] = chanmsg == 176 and msg2 or chanmsg  -- only collect unique numbers of CC messages (chanmsg = 176) for which msg2 value represents CC#, or non-CC messages which have channel data (chanmsg is not 176) for which msg2 value doesn't represent CC#; chanmsg = Pitch bend - 224, Program - 192, Channel pressure - 208, Poly aftertouch - 160
			end
		end
	i = i+1
	until idx == -1
return t
end



function Delete_CC_Evts_From_Target_Lanes(ME, take, lanes_with_sel_evts_t) -- before pasting/moving in case there's old automation to prevent mixing/garbling // lanes_with_sel_evts_t is the table returned by Get_Visible_Lanes_With_Selected_Events() or Get_CC_Lanes_With_Selected_Events() functions
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
-- Count events in the current channel to use in reversed loop below for the sake of deletion
local count = 0
	repeat
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, count) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel
		if not retval then break end
	count = count+1
	until not retval
-- Delete events from target lanes, if any
r.MIDI_DisableSort(take)
local evt_idx = count-1 -- in reverse due to deletion, -1 because the count ends up being 1-based
	repeat
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel
		if not retval then break end
		for _, cc in ipairs(lanes_with_sel_evts_t) do
			if chanmsg == 176 and cc == msg2 -- CC message, chanmsg = 176
			or chanmsg == cc then -- non-CC message (chanmsg =/= 176) which has channel data, such as Pitch, Channel pressure, ProgramChange and for which chanmsg value is stored instead since it's unique while their msg2 value doesn't refer to the CC#
			r.MIDI_DeleteCC(take, evt_idx)
			end
		end
	evt_idx = evt_idx-1
	until not retval
r.MIDI_Sort(take)
end


-- VISIBLE actually means selected in the left hand CC lane menu, regardless of its being collapsed or not
function Selected_Evnts_In_Visible_CC_Lanes(vis_lanes_t, take) -- vis_lanes_t is the table returned by Get_Currently_Visible_CC_Lanes() function above
-- Find if there're selected events in at least one visible CC lane (out of several)
local ccidx = 0
local sel_cnt = 0
	repeat -- deselect all
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, ccidx) -- just to use retval to stop the loop // only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		for _, cc in ipairs(vis_lanes_t) do
			if sel and (chanmsg == 176 and cc == msg2 or chanmsg == cc) then sel_cnt = sel_cnt+1 break end -- for non-CC messages (chanmsg =/= 176) their chanmsg value is stored since it's unique while their msg2 value doesn't refer to the CC#
		end
		if sel_cnt > 0 then break end -- exit if at least one found
	ccidx = ccidx+1
	until not retval
return sel_cnt > 0
end


-- CURRENTLY ONLY USEFUL IF JUST ONE CC LANE IS OPEN WHICH MIGHT NOT BE THE CASE
-- should be modified to:
-- after getting all sel CC events with Re_Store_Selected_CCEvents3()
-- after getting currently visible CC lanes with Get_Currently_Visible_CC_Lanes()
-- collate msg2 or chanmsg return values of CC or non-CC events respectively with the numbers of currently visible lanes
-- VISIBLE actually means selected in the left hand CC lane menu, regardless of its being collapsed or not
function All_Sel_CCEvts_Belong_To_Visble_OR_Last_Clicked_Lane(ME, take) -- 2 boolean return values: if any selected and if true then if all belong to the same lane // non-CC events are ignored so return values are both false
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local autom_lane = r.MIDIEditor_GetSetting_int(ME, 'last_clicked_cc_lane') -- last clicked if several lanes are displayed, otherwise currently visible lane
--Msg(autom_lane)
local autom_lane = autom_lane >= 256 and autom_lane <= 287 and autom_lane - 256 or autom_lane -- for events in 14-bit lanes MIDI_GetCC() returns 7-bit CC# hence the subtraction // events are displayed as selected in both 7 and 14 bit lanes
local first_sel_evt_idx = r.MIDI_EnumSelCC(take, -1) -- idx of the first selected event
local i = 0
local last_sel_evt_idx
	repeat
	local idx = r.MIDI_EnumSelCC(take, i)
		if r.MIDI_EnumSelCC(take, i+1) == -1 then last_sel_evt_idx = idx break end
	i = i + 1
	until idx == -1
local first = {r.MIDI_GetCC(take, first_sel_evt_idx)} -- retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 // only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all events use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
local last = {r.MIDI_GetCC(take, last_sel_evt_idx)}
return first_sel_evt_idx > -1, first[7] == autom_lane and first[7] == last[7] -- 7th return value is CC#
end



function Delete_Notes_In_MIDI_Channel(ME, take) -- STRANGE, THE ACTUAL MIDI CHANNEL ISN'T SPECIFIED, PROBABLY NEEDS REVISION, as is will only work if channel filter is enabled and will delete from the currently active channel
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
-- Count notes in the current channel to use in reversed loop below for the sake of deletion
local count = 0
	repeat
	local retval, sel, muted, ppqpos, endppq, chan, pitch, vel = r.MIDI_GetNote(take, count) -- only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel // if looking for all notes use Clear_Restore_MIDI_Channel_Filter() to disable filter if enabled and re-enable afterwards
		if not retval then break end
	count = count+1
	until not retval
r.MIDI_DisableSort(take)
local note_idx = count-1 -- in reverse due to deletion, -1 because the count ends up being 1-based
	repeat
	r.MIDI_DeleteNote(take, note_idx)
	note_idx = note_idx-1
	until note_idx < 0
r.MIDI_Sort(take)
end



function Delete_Notes(take, chan, want_active_ch)
-- only deletes notes in the active MIDI channel when channel filter is enabled
-- otherwise in all channels
-- chan is integer, 0-15, to only delete notes in particular channel
-- want_active_ch is boolean to only delete notes in the channel currently selected in the channel filter
-- if both chan and want_active_ch are valid, chan has proirity
local retval, notecnt, ccevtcnt, textsyxevtcnt = r.MIDI_CountEvts(take)
local ME = r.MIDIEditor_GetActive()
local def_chan = want_active_ch and r.MIDIEditor_GetSetting_int(ME, 'default_note_chan') -- channel selected in the channel filter regardless of the filter being enabled, Omni is 0, same as channel 1
local ch = chan or def_chan

	for i=notecnt-1,0,-1 do -- in reverse due to deletion
	local retval, sel, muted, startppq, endppq, chan, pitch, vel = r.MIDI_GetNote(take, i)
		if ch and chan == ch -- delete from specific channel
		or not ch then -- delete from all channels
		r.MIDI_DeleteNote(take, i)
		end
	end

end
--[[ USE for deletion in muliple channels
local ch_t = {2,5,13,15} -- channels to delete from
	for _, ch in ipairs(ch_t) do
	Delete_Notes(take, ch, want_active_ch)
	end
]]



function CC_Evts_Exist(ME, take)
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local evt_idx = 0
	repeat
	local retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3 = r.MIDI_GetCC(take, evt_idx) -- Velocity / Off Velocity / Text events / Notation enents / SySex lanes are ignored || only targets events in the current MIDI channel if Channel filter is enabled, if looking for genuine false or 0 values must be validated with retval which is only true for notes from current channel
		if retval then return retval end -- as soon as a selected event is found
	evt_idx = evt_idx + 1
	until not retval
end


function Store_Insert_Notes_OR_Evts(ME, take, t, move, chanIn, events) -- move is boolean, if true events will be deleted from the source channel, chanIn is channel for note/event setting, events is boolean to handle envelope events rather than notes
local ME = not ME and r.MIDIEditor_GetActive() or ME
local take = not take and r.MIDIEditor_GetTake(ME) or take
local Get, Delete, Insert = table.unpack(not events and {r.MIDI_GetNote, r.MIDI_DeleteNote, r.MIDI_InsertNote} or {r.MIDI_GetCC, r.MIDI_DeleteCC, r.MIDI_InsertCC})
-- !!!! Get, Delete, Insert, GeCCShape functions only target event in the current MIDI channel if Channel filter is enabled !!!!!
-- local chanIn = not chanIn and r.MIDIEditor_GetSetting_int(ME, 'default_note_chan') or chanIn -- 0-15
	if not t then
	local t = {}
	local idx = 0
		repeat
		local retval, shape, beztension = table.unpack(events and {r.MIDI_GetCCShape(take, idx)} or {})
		t[#t+1] = {Get(take, idx)}
		table.insert(t[#t], shape); table.insert(t[#t], beztension)
		local retval = t[#t][1]
			if idx == 0 and not retval then t = {} break end -- if no notes/events at all, resetting the table which would otherwise contain 1 field and produce false positive
		idx = idx+1
		until not retval
		if move then -- delete from the source channel
		r.MIDI_DisableSort(take)
			for i = #t,1,-1 do
			Delete(take, i-1)
			end
		r.MIDI_Sort(take)
		end
	return t
	else -- insert
	-- Count content in the current channel to use in reversed loop below for the sake of deletion
	local count = 0
		repeat
		local retval, sel, muted, ppqpos, endppq, chan, pitch, vel = Get(take, count) -- here only retval matters
			if not retval then break end
		count = count+1
		until not retval
	-- Delete content from the target channel
	r.MIDI_DisableSort(take)
	local idx = count-1 -- in reverse due to deletion, -1 because the count ends up being 1-based
		repeat
		Delete(take, idx)
		idx = idx-1
		until idx < 0
	r.MIDI_Sort(take)
		-- Insert notes or events in the target channel
		for k, data in ipairs(t) do
		local retval, sel, muted, ppqpos, a, chan, b, c, shape, beztension = table.unpack(data, 1, 10) -- for note it's retval, sel, muted, startppqpos, endppqpos, chan, pitch, vel; for CC events it's retval, sel, muted, ppqpos, chanmsg, chan, msg2, msg3, shape, beztension
			if retval then -- the last retval will be nil since one invalid event is stored at the end of the store loop
			Insert(take, sel, muted, ppqpos, a, chanIn, b, c, true) -- chanIn comes from the function argument, noSortIn true
				if events then
				r.MIDI_SetCCShape(take, k-1, shape, beztension, true) -- noSortIn true
				end
			end
		end
	r.MIDI_Sort(take)
	end

end
--[[ USE:

local notes_t = Store_Insert_Notes_OR_Evts(ME, take, t, move, chanIn, events) -- events false // store
local evts_t = Store_Insert_Notes_OR_Evts(ME, take, t, move, chanIn, true) -- events true // store

-- DO STUFF

local del = notes_move and Store_Insert_Notes_OR_Evts(ME, take, t, notes_move, chanIn, false) -- t, chanIn, events are false // delete notes from the source channel
local del = events_move and Store_Insert_Notes_OR_Evts(ME, take, t, events_move, chanIn, true) -- t, chanIn are false, events true // delete events from the source channel

if #notes_t > 0 and notes then Store_Insert_Notes_OR_Evts(ME, take, notes_t, notes_move, ch-1, false) end -- events false // insert
if #evts_t > 0 and events then Store_Insert_Notes_OR_Evts(ME, take, evts_t, events_move, ch-1, true) end -- events true // insert
]]


function Get_MIDI_Ed_Grid(take)

local grid_QN, swing_val, note_len = r.MIDI_GetGrid(take) -- in QN, quarter note is 1, 1/8th is 0.5 and so on. Swing is between -1 and 1 (the API doc is inaccurate in saying 0 and 1), when swing is negative the grid is shifted leftwards. Note length is 0 if it follows the grid size.; triplet is 1.5 of the straight division, 1/4T = 1/4 / 1.5 = 1 / 1.5; dotted is 1.5 times straight, 1/4D = 1/4 * 1.5 = 1 * 1.5; swing doesn't affect grid_QN value because it's returned as swing_val

-- exact grid divisions up to 1 measure can be calculated by the expression 4000/grid_QN
-- triplet notes in this case produce integer greater by 1/3 than the straight note value,
-- dotted notes are fractional and trickier to recognize, their fractionl part
-- alternates between 0.333333333333 and 0.666666666667

local mult = 1.5 -- to calculate triplets and dotted notes
local t = {['Grid'] = 0, -- Grid value is used in note_len evaluation
['4'] = 16, ['4T'] = 16/mult, ['4D'] = 16*mult,
['2'] = 8, ['2T'] = 8/mult, ['2D'] = 8*mult,
['1'] = 4, ['1T'] = 4/mult, ['1D'] = 4*mult,
['1/2'] = 2, ['1/2T'] = 2/mult, ['1/2D'] = 2*mult,
['1/4'] = 1, ['1/4T'] = 1/mult, ['1/4D'] = 1.5,
['1/8'] = 1/2, ['1/8T'] = 1/2/mult, ['1/8D'] = 1/2*1.5,
['1/16'] = 1/4, ['1/16T'] = 1/4/mult, ['1/16D'] = 1/4*mult,
['1/32'] = 1/8, ['1/32T'] = 1/8/mult, ['1/32D'] = 1/8*mult,
['1/64'] = 1/16, ['1/64T'] = 1/16/mult, ['1/64D'] = 1/16*mult,
['1/128'] = 1/32, ['1/128T'] = 1/32/mult, ['1/128D'] = 1/32*mult}

local grid, swing, note

	for div, val in pairs(t) do
		if grid_QN == val then grid, swing = div, swing_val*100 break end -- converting the swing value to percentage
	end

	for div, val in pairs(t) do
		if note_len == val then note = div break end
	end

local grid_div_len_sec = 60/r.Master_GetTempo()*grid_QN
local grid_div_len_px = grid_div_len*r.GetHZoomLevel()

return grid, swing, note, grid_div_len_sec, grid_div_len_px

end



function Get_MIDI_Ed_Visible_Grid(ME, take)
-- the function is only compatible with builds 7.37+
-- where insert note actions respect visible grid
-- when the option 'Snap to visible grid' (first introduced in build 7.36)
-- is enabled and minimum line spacing setting applies to the MIDI Editor grid
-- so when the line spacing produced by the original grid type is smaller 
-- than the minimum line spacing value, actual (visible) grid resolution 
-- can be learned by inserting a note and measuring its length;
-- IN MIDI EDITOR, FOLDED VISIBLE GRID OF TRIPLET, DOTTED AND SWUNG
-- DIVISIONS PRODUCES LINE SPACING OF MAINLY STRAIGHT NOTES;
-- relies on re_store_sel_MIDI_notes();
-- !!! IMPORTANT: 
-- 1) THE FUNCTION MUST BE INCLUDED WITHIN THE UNDO BLOCK
-- BECAUSE THE ACTION 'Edit: Insert note at edit cursor' CREATES
-- AN UNDO POINT AND IF PLACED OUTSIDE OF THE UNDO BLOCK, MIDI EVENT 
-- IT TEMPORARILY INSERTS GETS RESTORED WHEN CHANGE PRODUCED 
-- BY THE SCRIPT IS UNDONE
-- 2) IT MUST BE PRECEDED BY:
--[[ 
local note_div, note_mode = Re_Store_Note_Length_Setting(take) -- store settings
	if note_mode ~= 'Grid' then
	r.MIDIEditor_LastFocused_OnCommand(41295, false) -- islistviewcommand false // Set length for next inserted note: grid // ENABLE SO THAT 'Edit: Insert note at edit cursor' ACTION INSERTS NOTE BY GRID, ORIGINAL OR VISIBLE (in bilds 7.37+)
	end
]]
-- AND FOLLOWED BY:
--[[ 
	if note_mode ~= 'Grid' then
	Re_Store_Note_Length_Setting(take, note_div, note_mode) -- restore settings
	end
]]
-- 3) BE MINDFUL OF THE USE OF PreventUIRefresh() BEFORE THE FUNCTION
-- BECAUSE IT MAY PREVENT EDIT CURSOR POSITION CHANGE EFFECTED
-- WITH 'View: Go to start of file' BELOW FROM BEING ACCESSIBLE
-- TO 'Edit: Insert note at edit cursor', THIS HASN'T BEEN TESTED


-- the function is an alternative to Get_Visible_Grid_Div_Length()
-- which works reliably for Arrange grid but is not relable in the MIDI Editor
-- becasue MIDI Editor grid when folded doesn't respect mimimum line spacing value 
-- set in the grid settings (never respected before build 7.37 and only partially 
-- respects since) and instead creates greater line spacing which is impossible 
-- to calculate with the said function because the function looks for time value in sec 
-- corresponding to mimimum line spacing value in pixels and cannot guess 
-- by how much actual line spacing of the visible MIDI Editor grid is greater 
-- than the minimum value,
-- that said Get_Visible_Grid_Div_Length() function is still able to give an indication 
-- when the MIDI Editor visible grid doesn't match the grid setting in builds 7.37+

-- SINCE THE FUNCTION IS INTRUSIVE IT MUST BE CONDITIONED
-- BY DIFFERENCE BETWEEN LINE SPACING IN THE ORIGINAL GRID AND THE VISIBLE GRID
-- SO IT DOESN'T RUN UNNECESSARY
local grid_QN, swing_val, note_len = r.MIDI_GetGrid(take) -- grid_QN is effective grid setting in quarter notes
local grid_div_len = 60/r.Master_GetTempo()*grid_QN -- grid division length in sec
local retval, min_spacing = r.get_config_var_string('projgridmin') -- minimum visible grid resolution // setting in Snap/Grid Settings dialogue 'Show grid, line spacing: ... minimum: ... pixels'
local _7_37 = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 7.37

	if _7_37 and min_spacing+0 > 0 and grid_div_len*r.GetHZoomLevel() >= min_spacing+0 then return end -- build 7.37+, original grid line spacing in px is NOT smaller than the setting, i.e. visible grid resolution is NOT active, so no need to determine its line spacing

-- The routine runs when build is 7.37+, original grid line spacing in px is smaller 
-- than min_spacing setting, i.e. visible grid is active
-- or when min_spacing setting is 0 so there's no clear rule determining when the grid 
-- folds to fit the zoom level, so whether there's difference between original 
-- and visible grids will have to be determined using this function return value 
-- and based on this decision will have to be made which one to opt for.
-- OR when build is older than 7.37 allowing to get grid line spacing regardles if whether
-- it matches the original or the visible grid
	
local sel_notes = re_store_sel_MIDI_notes(take, 1) -- deselect_all true because note insert action doesn't make the note exclusively selected
local cur_pitch = r.MIDIEditor_GetSetting_int(ME, 'active_note_row') -- store
local edit_cur_pos = r.GetCursorPosition() -- store
local snap_to_vis_grid = r.GetToggleCommandStateEx(32060, 42473) == 1 -- Options: Snap to visible grid

local ACT = r.MIDIEditor_LastFocused_OnCommand

r.PreventUIRefresh(1)

	if not snap_to_vis_grid then -- toggle to ON, must be enaled for the insert note action to respect visible grid
	ACT(42473, false) -- islistviewcommand // Options: Snap to visible grid
	end
	
r.MIDIEditor_SetSetting_int(ME, 'active_note_row', 0)
ACT(40036, false) -- islistviewcommand // View: Go to start of file
ACT(40051, false) -- islistviewcommand // Edit: Insert note at edit cursor // inserts notes at grid resolution even if global Snap is disabled as long as note length setting is Grid
local note_st, note_end, note_idx

-- get first selected note because when note is inserted by action above
-- it ends up being the only one selected because the rest were preemptively deselected above
local i = 0
	repeat
	local retval, sel, muted, startppqpos, endppqpos, chan, pitch, vel = r.MIDI_GetNote(take, i)
		if sel then note_st, note_end, note_idx = startppqpos, endppqpos, i break end		
	i=i+1
	until not retval
	
-- Restore everything
	if not snap_to_vis_grid then -- toggle to OFF if was intially OFF
	ACT(42473, false) -- islistviewcommand // Options: Snap to visible grid
	end

	if note_idx then r.MIDI_DeleteNote(take, note_idx) end

re_store_sel_MIDI_notes(take, nil, sel_notes) -- deselect_all nil, irrelevant at the restoration stage
r.MIDIEditor_SetSetting_int(ME, 'active_note_row', cur_pitch) -- restore
r.SetEditCurPos(edit_cur_pos, false, false) -- moveview, seekplay false // restore

r.PreventUIRefresh(-1)

-- exact grid divisions up to 1 measure can be calculated by the expression 4000/grid_QN
-- triplet notes in this case produce integer greater by 1/3 than the straight note value,
-- dotted notes are fractional and trickier to recognize, their fractionl part
-- alternates between 0.333333333333 and 0.666666666667
local mult = 1.5 -- to calculate triplets and dotted notes
local t = {
['4'] = 16, ['4T'] = 16/mult, ['4D'] = 16*mult,
['2'] = 8, ['2T'] = 8/mult, ['2D'] = 8*mult,
['1'] = 4, ['1T'] = 4/mult, ['1D'] = 4*mult,
['1/2'] = 2, ['1/2T'] = 2/mult, ['1/2D'] = 2*mult,
['1/4'] = 1, ['1/4T'] = 1/mult, ['1/4D'] = 1.5,
['1/8'] = 1/2, ['1/8T'] = 1/2/mult, ['1/8D'] = 1/2*1.5,
['1/16'] = 1/4, ['1/16T'] = 1/4/mult, ['1/16D'] = 1/4*mult,
['1/32'] = 1/8, ['1/32T'] = 1/8/mult, ['1/32D'] = 1/8*mult,
['1/64'] = 1/16, ['1/64T'] = 1/16/mult, ['1/64D'] = 1/16*mult,
['1/128'] = 1/32, ['1/128T'] = 1/32/mult, ['1/128D'] = 1/32*mult}

	if note_idx then
	local sec = r.MIDI_GetProjTimeFromPPQPos(take, note_end)-r.MIDI_GetProjTimeFromPPQPos(take, note_st) -- length in sec
	local QN = r.MIDI_GetProjQNFromPPQPos(take, note_end)-r.MIDI_GetProjQNFromPPQPos(take, note_st) -- length in QN
	local vis_QN = QN or sec/(60/r.Master_GetTempo()) -- visible grid division in quarter notes
		for div, val in pairs(t) do
		-- due to floating point rounding errors and long fractional parts
		-- it's impossible to reliably evaluate equality by direct comparison 
		-- between two floating point numbers
		-- because numbers functionally the same will differ in minute fraction,
		-- this is always an ussue with notes length, which seems to be related 
		-- to their measurement in ppq per quarter note, and value in quarter notes
		-- ends up being slightly larger than the value it's supposed to be equal to,
		-- mainly with triplets whose floating point precision is 18 decimal places		
		-- i.e. 1/64T: val = 0.041666666666666664 VS vis_QN = 0.041666666666666741, 
		-- so a way to compare them is by converting them into strings, tostring()
		-- function automatically rounds off long floating point numbers of up to about
		-- 15 decimal places which seems enough for reliable comparison because the
		-- difference is smaller;
		-- employing this solution for completeness because folded grid only matches 
		-- whole notes except when extremely folded in which case it matches 1/2D
			if tostring(val/vis_QN) == '1.0' -- the fractional part of the quotient of the division is so small that after being rounded by conversion into string all which remains of it is decimal zeros
	--[[ OR
		if val..'' == vis_QN..'' or val..'' == (vis_QN..''):gsub('%.0','') -- this works BUT craps out at whole numbers because when vis_QN is converted into string there's a trailing decimal zero while in the table whole numbers lack such zero which causes the evaluation to fail, hence the gsub
		]]
			then
			return div, sec, QN end
		end
	end

end




function Re_Store_Note_Length_Setting(take, note_div, note_mode)
-- note division and mode settings at the bottom of the MIDI Editor
-- take must be valid is chunk is going to be used
-- TO BE ABLE TO RESTORE SETTINGS VIA CHUNK
-- AT THE RESTORATION STAGE THE FUNCTION MUST BE PRECEDED WITH:
-- r.MIDIEditor_LastFocused_OnCommand(2, false) -- File: Close window
-- AND FOLLOWED BY:
-- r.SelectAllMediaItems(0, false) -- deselect all
-- r.SetMediaItemSelected(r.GetMediaItemTake_Item(take), true)
-- r.Main_OnCommand(40153,0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
-- see pros and cons of each method in annotations below
	
	-- store
	if not note_div and not note_mode -- IF USING ACTIONS, in this case note_mode will certainly be valid at the restoration stage and assigned command ID 41711 (straight note mode) even if note_div is nil
	-- if not note_div -- IF USING CHUNK, note_mode can come in as nil if the data was collected from chunk, but note_div will always be valid
	then
	local note_div_sett_t = {
	-- these actions always keep their toggle state as long as note division
	-- is active regardles of the way it was activated
	-- while actions without 'preserving division type' verbiage change
	-- their toggle state and therefore unreliable;
	-- there're no actions to enable 2 and 4 measures in the note menu
	-- so these cannot be stored and restored
	41710, -- Set length for next inserted note: 1 preserving division type
	41709, -- Set length for next inserted note: 1/2 preserving division type
	41708, -- Set length for next inserted note: 1/4 preserving division type
	41707, -- Set length for next inserted note: 1/8 preserving division type
	41706, -- Set length for next inserted note: 1/16 preserving division type
	41705, -- Set length for next inserted note: 1/32 preserving division type
	41704, -- Set length for next inserted note: 1/64 preserving division type
	41703, -- Set length for next inserted note: 1/128 preserving division type
	41295 -- Set length for next inserted note: grid
	}
	local note_mode_sett_t = {
	-- with whole notes, dotted 1 whole note is supported, however
	-- when 1 measure dotted is set via action it ends up displayed as 1/1 instead of 1
	-- and if the pull-up note list is opened, 1/128 becomes automatically selected;
	-- there's no single action to enable 1 measure dotted unlike with smaller note divisions;
	-- when triplet 1 whole note and all non-straight types of 2 and 4 measure note
	-- are manually enabled in the note menu the toggle state of the triplet 
	-- and dotted actions listed below is set to OFF while the toggle state of the 
	-- straight action is set to ON,
	-- when triplet and dotted modes are enabled for 2 and 4 measure notes via action, 
	-- the mode remains straight, but note notation is shown as a fraction, i.e. 4/3, 
	-- or a decimal fraction, repeated execution of the triplet or dotted action keeps 
	-- calculating the new fractional note value, while for 1 measure note this is
	-- only the case with triplet mode set via action, however if set, dotted mode
	-- action starts to affect it as well;
	41712, -- Set length for next inserted note: dotted preserving division length
	41711, -- Set length for next inserted note: straight preserving division length
	41713 -- Set length for next inserted note: triplet preserving division length
	}
	local note_div, note_mode
		for k, act_ID in ipairs(note_div_sett_t) do
			if r.GetToggleCommandStateEx(32060, act_ID) == 1 
			then note_div = act_ID
			end
		end
		for k, act_ID in ipairs(note_mode_sett_t) do
			if r.GetToggleCommandStateEx(32060, act_ID) == 1 
			then note_mode = act_ID
			end
		end

	--[[ ALTERNATIVE 2
		if note_div == 41710 or not note_div then -- 1 measure or 2 and 4 measures, resort to chunk for reasons described above, because there's no other way to reliably restore them
		local ret, chunk = r.GetItemStateChunk(r.GetMediaItemTake_Item(take), '', false) -- insundo false
		local CFGEDIT = chunk:match('CFGEDIT (.-)\n')
		local i = 0
		CFGEDIT = CFGEDIT:gsub('[%.%d]+', function(c) i=i+1 if i==21 then note_div = c return end end) -- note setting field is 21st
		note_mode = nil -- reset
		end
	--]]

	return note_div, note_mode -- returns action command IDs
	
	-- restore
	else 	
	
	--[=-[ ALTERNATIVE 1
	local note_div = note_div or 41710 -- if note_div came in as nil because note was set to 2 or 4 measures, set to 1 because there're no actions for 2 and 4 measure notes
	local set = note_div and r.MIDIEditor_LastFocused_OnCommand(note_div, false) -- islistviewcommand
--	local note_mode = not (note_div or note_mode) and 41711 or note_mode -- if note_div came in as nil because note was set to 2 or 4 measures for which note mode (triplet, dotted) isn't supported, or if note_mode came in false because 1 measure note mode was set to triplet which isn't supported, set the mode to 1 measure straight -- OLD
	-- THE PROBLEM IS THAT WHEN 1 measure dotted IS RESTORED IT MAY END UP DISPLAYED AS 1/1 INSTEAD OF 1	
	-- and if the drop-down note list is opened 1/128 becomes automatically selected;
	-- there's no single action to enable 1 measure dotted unlike with smaller note divisions
	local note_mode = note_div and note_div ~= 41710 and note_mode -- only set mode when note_div var is valid, which excluses 2 and 4 measure note because they cannot be set via actions, OR when note_div is NOT 1 measure because setting dotted mode for 1 measure note results in the note value not being properly displayed in the menu, see above, while for 1 measure, straight explicit mode setting isn't necessary anyway; so for 1,2,4 measure notes only restore 1 straight
	local note_mode = note_mode and r.MIDIEditor_LastFocused_OnCommand(note_mode, false) -- islistviewcommand
	--]=]
	--[=[ ALTERNATIVE 2, using chunk, actually isn't worth the effort
		if note_mode then -- note settings which can be restored with actions
		r.MIDIEditor_LastFocused_OnCommand(note_div, false) -- islistviewcommand
		r.MIDIEditor_LastFocused_OnCommand(note_mode, false) -- islistviewcommand
		elseif note_div then -- 1,2 and 4 measure settings, use chunk
		-- TO SET CHUNK TO AN OPEN MIDI ITEM IT MUST BE CLOSED AND RE-OPENED WITH
		-- r.MIDIEditor_LastFocused_OnCommand(2, false) -- File: Close window BEFORE THE FUNCTION
		-- AND 
		-- r.SelectAllMediaItems(0, false)
		-- r.SetMediaItemSelected(r.GetMediaItemTake_Item(take), true)
		-- r.Main_OnCommand(40153,0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
		-- AFTER IT, BUT NON-STRAIGHT MEASURES ARE RESTORED IN DIFFERENT VALUES WITH MODE BEING straight
		-- i.e. 1 triplet as 2/3 straight; 4 dotted as 6 straight, AND SO ARE CONFUSING AND INCONSISTENT
		local item = r.GetMediaItemTake_Item(take)
		local ret, chunk = r.GetItemStateChunk(item, '', false) -- insundo false
		local CFGEDIT = chunk:match('CFGEDIT .-\n')
	--[[ 1. an unsuccessful attempt to set straight note via chunk and enable triple/dotted via action, because the displayed result is the same as if setting via chunk alone
		local note_div = note_div+0
		local triplet_src, dotted_src = math.floor(note_div*1.5+0.5), math.floor(note_div/1.5+0.5)
		note_div = triplet_src%4 == 0 and triplet_src or dotted_src%4 == 0 and dotted_src or note_div
		--]]
		local i = 0
		CFGEDIT_new = CFGEDIT:gsub('[%.%d]+', function(c) i=i+1 if i==21 then return note_div end end) -- note setting field is 21st
		chunk = chunk:gsub(CFGEDIT, CFGEDIT_new)
		r.SetItemStateChunk(item, chunk, false) -- insundo false
	--[[ 2. an unsuccessful attempt to set straight note via chunk and enable triple/dotted via action
		local note_mode = triplet_src%4 == 0 == 0 and 41713 or dotted_src%4 == 0 and 41712
			if cmdID then
			r.MIDIEditor_LastFocused_OnCommand(note_mode, false) -- islistviewcommand
			end
		--]]
		end
	--]=]
	end

end



function Get_Track_MIDI_Note_Names(tr)
local note_names = '<MIDINOTENAMES'
	for note_idx = 0, 127 do -- note range
		for chan_idx = -1, 15 do -- MIDI channel range, -1 is omni
		local name = r.GetTrackMIDINoteNameEx(0, tr, note_idx, chan_idx) -- name is nil if no custom name
			if name then
			-- enclose inside quotes if contains spaces as per REAPER format
			name = name:match(' ') and '"'..name..'"' or name
			-- concatenate <MIDINOTENAMES block line
			note_names = note_names..'\n'..chan_idx..' '..note_idx..' '..name..' 0 '..note_idx
			-- if name is found under onmi MIDI channel it will also be returned for all 16 channels
			-- so no point in continuing because this is not how the code looks in the track chunk
				if chan_idx == -1 then break end
			end
		end
	end
return note_names ~= '<MIDINOTENAMES' and note_names..'\n>'
end



function Get_Note_Name_At_Current_Pitch(ME)
local ME = ME or r.MIDIEditor_GetActive()
local pitch = r.MIDIEditor_GetSetting_int(ME, 'active_note_row')
local note_t = {'C','C#','D','D#','E','F','F#','G','G#','A','A#','B'}
return pitch/12 < 0 and note_t[pitch+1] or note_t[pitch%12+1]..tostring(math.floor(pitch/12-1)) -- +1 in pitch+1 and pitch%12+1 because range starts at 0 and at each C note modulo is 0 while notes table is indexed from 1; -1 in pitch/12-1 because MIDI Editor keyboard starts from octave -1, so 0 in the 0-127 range of the pitch var refers to C-1 rather than C0 and everything must be shifted downwards by 1 to match the keyboard labels and note readouts; math.floor to truncate trailing decimal 0 before conversion into string
end



function Get_Default_MIDI_Chan(take, sectID)
-- the one selected in the channel filter regardless of its being enabled
-- 'All channels' option defaults to channel 1
r.PreventUIRefresh(1)
	if sectID ~= 32060 then -- script isn't run from the MIDI Editor section // open MIDI Editor
	r.Main_OnCommand(40153,0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
	end
local chan = r.MIDIEditor_GetSetting_int(r.MIDIEditor_GetActive(), 'default_note_chan')
	if sectID ~= 32060 then -- script isn't run from the MIDI Editor section // close MIDI editor
	r.MIDIEditor_LastFocused_OnCommand(2, false) -- islistviewcommand false // File: Close window
	end
r.PreventUIRefresh(-1)
return chan
end


function Re_Store_MIDI_Editor_Mode(mode_init)
-- the modes are Named Notes (Drum Map), Piano roll, Event List, Notation
-- the mode seems to be MIDI Editor window specific so if temp track and temp MIDI item
-- are used changing the mode in the temp MIDI item won't affect the mode active elsewhere
-- if the project is empty on startup Notation mode which was last used
-- cannot be restored when temp track and temp MIDI items are used
-- because its toggle state is not stored, instead the mode last active before Notation
-- is returned with GetToggleCommandStateEx() even though all modes are mutually exclusive
	local function get()
	local get_togg_state = r.GetToggleCommandStateEx
		for _, mode_ID in ipairs({40042, 40043, 40056, 40954}) do -- mode action command IDs
			if get_togg_state(32060, mode_ID) == 1 then -- OR get_togg_state(32060, 40056) == 1 since mode action IDs are the same in both MIDI Editor and Event List sections
			return mode_ID
			end
		end
	end
	if not mode_init then
	return get()
	else
	local mode_cur = get()
	r.MIDIEditor_LastFocused_OnCommand(mode_init, mode_cur == 40056) -- islistviewcommand is true if mode_cur equals Event List mode command ID // restore the initial MIDI Editor mode
	end
end
-- USE:
-- mode_init = Re_Store_MIDI_Editor_Mode() -- store
-- Re_Store_MIDI_Editor_Mode(mode_init) -- restore


function Detect_Natural_Notes(note_idx)
-- note_idx is MIDI note number 0 -127
local note_idx_adj = note_idx < 12 and 11+note_idx or note_idx
	for k, modulo in ipairs({0,2,4,5,7,9,11}) do
		if note_idx_adj%12 == modulo then return note_idx end
	end
end




--============================= M I D I  E N D =============================


--============================= (R E) S T O R E ============================

function StoreSelectedObjects() -- CAN BE COMBINED INTO A SINGLE FUNCTION WITH THE RESTORE ONE BELOW, see Re_Store_Selected_Objects()

-- Store selected items
-- REAPER devs don't recommend using CountSelectedMediaItems()
-- and GetSelectedMediaItem in favor of CountMediaItems()
-- and IsMediaItemSelected() instead
-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
local sel_itms_cnt = r.CountSelectedMediaItems(0)
local itm_sel_t = {}
	if sel_itms_cnt > 0 then
	local i = 0
		while i < sel_itms_cnt do
		itm_sel_t[#itm_sel_t+1] = r.GetSelectedMediaItem(0,i)
		i = i+1
		end
	end

-- Store selected tracks
local sel_trk_cnt = reaper.CountSelectedTracks2(0,true) -- plus Master, wantmaster true
local trk_sel_t = {}
	if sel_trk_cnt > 0 then
	local i = 0
		while i < sel_trk_cnt do
		trk_sel_t[#trk_sel_t+1] = r.GetSelectedTrack2(0,i,true) -- plus Master, wantmaster true
		i = i+1
		end
	end

return itm_sel_t, trk_sel_t

end


function Restore_Saved_Selected_Objects(itm_sel_t, trk_sel_t) -- only restored if there was selection, if nothing was selected the latest selection is kept

r.PreventUIRefresh(1)

	-- Restore selected items
	if #itm_sel_t > 0 then
--	r.Main_OnCommand(40289,0) -- Item: Unselect all items
	r.SelectAllMediaItems(0,false) -- deselect all
	local i = 0
		while i < #itm_sel_t do
		r.SetMediaItemSelected(itm_sel_t[i+1],true) -- +1 since item count is 1 based while the table is indexed from 1
		i = i + 1
		end
	end

	-- Restore selected tracks
	if #trk_sel_t > 0 then
--	r.Main_OnCommand(40297,0) -- Track: Unselect all tracks
	r.SetOnlyTrackSelected(trk_sel_t[1]) -- select one to be restored while deselecting all the rest
	r.SetTrackSelected(r.GetMasterTrack(0),false) -- deselect Master
		for _,v in next, trk_sel_t do
		r.SetTrackSelected(v,true)
		end
	end

r.UpdateArrange()
r.TrackList_AdjustWindows(0)

r.PreventUIRefresh(-1)
end


function Restore_Saved_Selected_Objects(itm_sel_t, trk_sel_t) -- selection state is restored if objects both were and weren't selected

r.PreventUIRefresh(1)

--r.Main_OnCommand(40289,0) -- Item: Unselect all items OR
r.SelectAllMediaItems(0,false) -- deselect all
	if #itm_sel_t > 0 then
	local i = 0
		while i < #itm_sel_t do
		r.SetMediaItemSelected(itm_sel_t[i+1],true) -- selected is true
		i = i + 1
		end
	end

--r.Main_OnCommand(40297,0) -- Track: Unselect all tracks
r.SetOnlyTrackSelected(r.GetMasterTrack(0)) -- select to deselect the rest
r.SetTrackSelected(r.GetMasterTrack(0),false) -- deselect Master
	if #trk_sel_t > 0 then
		for _,v in next, trk_sel_t do
		r.SetTrackSelected(v,true) -- selected is true
		end
	end

r.UpdateArrange()
r.TrackList_AdjustWindows(0)

r.PreventUIRefresh(-1)
end




function Re_Store_Selected_Objects(t1,t2) -- when storing the arguments aren't needed

r.PreventUIRefresh(1)

local t1, t2 = t1, t2

	if not t1 then
	-- Store selected items
	-- REAPER devs don't recommend using CountSelectedMediaItems()
	-- and GetSelectedMediaItem in favor of CountMediaItems()
	-- and IsMediaItemSelected() instead
	-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
	local sel_itms_cnt = r.CountSelectedMediaItems(0)
		if sel_itms_cnt > 0 then
		t1 = {}
		local i = sel_itms_cnt-1
			while i >= 0 do -- in reverse due to deselection
			local item = r.GetSelectedMediaItem(0,i)
			t1[#t1+1] = item
		--	r.SetMediaItemSelected(item, false) -- selected false; deselect item // OPTIONAL
			i = i - 1
			end
		end
	elseif t1 and #t1 > 0 then -- Restore selected items
--	r.Main_OnCommand(40289,0) -- Item: Unselect all items
--	OR
	r.SelectAllMediaItems(0, false) -- selected false
		for _, item in ipairs(t1) do
		r.SetMediaItemSelected(item, true) -- selected true
		end
	r.UpdateArrange()
	end

	if not t2 then
	-- Store selected tracks
	local sel_trk_cnt = reaper.CountSelectedTracks2(0,true) -- plus Master, wantmaster true
		if sel_trk_cnt > 0 then
		t2 = {}
		local i = sel_trk_cnt-1
			while i >= 0 do -- in reverse due to deselection
			local tr = r.GetSelectedTrack2(0,i,true) -- plus Master, wantmaster true
		--	r.SetTrackSelected(tr, false) -- selected false; deselect track // OPTIONAL
			t2[#t2+1] = tr
			i = i - 1
			end
		end
	elseif t2 and #t2 > 0 then -- restore selected tracks
--	r.Main_OnCommand(40297,0) -- Track: Unselect all tracks
	r.SetOnlyTrackSelected(t2[1]) -- select one to be restored while deselecting all the rest
	r.SetTrackSelected(r.GetMasterTrack(0), false) -- unselect Master
	-- OR
	-- r.SetOnlyTrackSelected(t2[1])
		for _, tr in ipairs(t2) do
		r.SetTrackSelected(tr, true) -- selected true
		end
	r.UpdateArrange()
	r.TrackList_AdjustWindows(0)
	end

r.PreventUIRefresh(-1)

return t1, t2

end

------------------ USAGE -------------------
local t1, t2 = Re_Store_Selected_Objects() -- store
-- DO STUFF --
Re_Store_Selected_Objects(t1, t2) -- restore
--------------------------------------------


function re_store_sel_trks1(t)
-- with deselection; t is the stored tracks table to be fed in at restoration stage
	if not t then
	local sel_trk_cnt = reaper.CountSelectedTracks2(0,true) -- plus Master, wantmaster true
	local trk_sel_t = {}
		if sel_trk_cnt > 0 then
		local i = sel_trk_cnt -- in reverse because of deselection
			while i > 0 do -- not >= 0 because sel_trk_cnt is not reduced by 1, i-1 is on the next line
			local tr = r.GetSelectedTrack2(0,i-1,true) -- plus Master, wantmaster true
			trk_sel_t[#trk_sel_t+1] = tr
			r.SetTrackSelected(tr, 0) -- selected 0 or false // unselect each track
			i = i-1
			end
		end
	return trk_sel_t
	elseif t --and #t > 0
	then
	r.PreventUIRefresh(1)
--	r.Main_OnCommand(40297,0) -- Track: Unselect all tracks
	-- deselect all tracks, this ensures that if none was selected originally
	-- none will end up selected because re-selection loop below won't start
	local master = r.GetMasterTrack(0)
	r.SetOnlyTrackSelected(master) -- select master
	r.SetTrackSelected(master, 0) -- immediately deselect
		for _,v in next, t do
		r.SetTrackSelected(v,1)
		end
	r.UpdateArrange()
	r.TrackList_AdjustWindows(0)
	r.PreventUIRefresh(-1)
	end
end



function re_store_sel_trks2(track_indices)
-- for storage as extended state

	if not tracks_indices then -- store
	local track_indices = ''
		for i=0, r.CountSelectedTracks2(0, true)-1 do -- wantmaster true
		local idx = r.CSurf_TrackToID(r.GetSelectedTrack2(0,i, true), false) -- wantmaster true, mcpview false // idx 0 is Master track
		track_indices = track_indices..','..idx
		end
	return track_indices
	else -- restore
		for idx in track_indices:gmatch('%d+') do
			if idx then
			local tr = r.CSurf_TrackFromID(idx, false) -- mcpview false
			r.SetTrackSelected(tr, true) -- selected true
			end
		end
	end

end



function ReStoreSelectedItems(t, keep_last_selected)
-- keep_last_selected is boolean relevant for the restoration stage
-- to add last selected items to the original selection
	if not t then -- Store selected items
	-- REAPER devs don't recommend using CountSelectedMediaItems()
	-- and GetSelectedMediaItem in favor of CountMediaItems()
	-- and IsMediaItemSelected() instead
	-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
	local sel_itms_cnt = r.CountSelectedMediaItems(0)
		if sel_itms_cnt > 0 then
		local t = {}
		local i = sel_itms_cnt-1
			while i >= 0 do -- in reverse due to deselection
			local item = r.GetSelectedMediaItem(0,i)
			t[#t+1] = item
			r.SetMediaItemSelected(item, false) -- deselect item
			i = i - 1
			end
		return t end
	elseif t then -- Restore selected items
		if not keep_last_selected then
	--	r.Main_OnCommand(40289,0) -- Item: Unselect all items
		r.SelectAllMediaItems(0, false) -- selected false // deselect all
		end
	local i = 1
		while i <= #t do
		r.SetMediaItemSelected(t[i],true) -- if in between function runs any item pointers become invalid due to item deletion or split, the function doesn't throw an error, because the data type it expects remains valid
		i = i + 1
		end
	end
r.UpdateArrange()
end



function Re_Store_Selected_Items(t, keep_last_selected)
-- at the restoration stage when evaluating whether any items 
-- were saved into the table, 'if next(t) then' statement is used
-- because the table isn't indexed and 'if #t > 0 then' won't work

	if not t then
	local t = {}
		for i=0, r.CountMediaItems(0)-1 do
		local item = r.GetMediaItem(0,i) 
			if r.IsMediaItemSelected(item) then
			t[item] = '' -- dummy entry
			end
		end
	r.SelectAllMediaItems(0, false) -- selected false // deselect all
	return t
	elseif t and next(t) then
		if not keep_last_selected then
		r.SelectAllMediaItems(0, false) -- selected false // deselect all
		end
		for item in pairs(t) do
		r.SetMediaItemSelected(item, true) -- selected true
		end
	end

r.UpdateArrange()

end



function re_store_obj_selection(t1, t2)
	if not t1 and not t2 then
	local t1, t2 = {}, {}
		for i = 0, r.CountSelectedTracks2(0,true) do -- plus Master, wantmaster true
		t1[#t1+1] = r.GetSelectedTrack2(0,i,true) -- plus Master, wantmaster true
		end
		for i = 0, r.CountSelectedMediaItems(0)-1 do
		-- REAPER devs don't recommend using CountSelectedMediaItems()
		-- and GetSelectedMediaItem in favor of CountMediaItems()
		-- and IsMediaItemSelected() instead
		-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
		t2[#t2+1] = r.GetSelectedMediaItem(0,i)
		end
	return #t1 > 0 and t1, #t2 > 0 and t2
	else
		r.SetOnlyTrackSelected(r.GetMasterTrack(0))
		r.SetTrackSelected(r.GetMasterTrack(0),false) -- unselect Master
		if t1 then
			for _, tr in ipairs(t1) do
			r.SetTrackSelected(tr, true) -- selected true
			end
		end
		r.SelectAllMediaItems(0, false) -- selected false // deselect all
		if t2 then
			for _, itm in ipairs(t2) do
			r.SetMediaItemSelected(itm, true) -- selected true
			end
		end
	end
end


--========================= (R E) S T O R E   E N D ============================

--========================= O B J E C T S ============================

function Find_And_Get_New_Objects(t, wantItems) -- wantItems is boolean
local Count, Get = table.unpack(not wantItems and {r.CountTracks, r.GetTrack} or {r.CountMediaItems,r.GetMediaItem})
	if not t then
	local t = {}
		for i = 0, Count(0)-1 do
		t[r.Get(0,i)] = '' -- dummy field
		end
	return t
	elseif t then
	local t2 = {}
		for i = 0, Count(0)-1 do
		local obj = Get(0,i)
			if not t[obj] then -- track wasn't stored so is new
			t2[#t2+1] = {obj=obj, idx=i}
			end
		end
	return #t2 > 0 and t2
	end
end


function Get_Object_Under_Mouse_Curs() -- used in 'FX presets menu script'

-- Before build 6.37 GetCursorContext() and r.GetTrackFromPoint(x, y) are unreliable in getting TCP since the track context and coordinates are true along the entire timeline as long as it's not another context
-- using edit cursor to find TCP context instead since when mouse cursor is over the TCP edit cursor doesn't respond to action 'View: Move edit cursor to mouse cursor' // before build 6.37 STOPS PLAYBACK WHILE GETTING TCP
-- Before build 6.37 no MCP support; when mouse is over the Mixer on the Arrange side the trick to detect track panel doesn't work, because with 'View: Move edit cursor to mouse cursor' the edit cursor does move to the mouse cursor

	local function GetMonFXProps() -- get mon fx accounting for floating window, GetFocusedFX() doesn't detect mon fx in builds prior to 6.20

		local master_tr = r.GetMasterTrack(0)
		local src_mon_fx_idx = r.TrackFX_GetRecChainVisible(master_tr)
		local is_mon_fx_float = false -- only relevant if there's need to reopen the fx in floating window
			if src_mon_fx_idx < 0 then -- fx chain closed or no focused fx -- if this condition is removed floated fx gets priority
				for i = 0, r.TrackFX_GetRecCount(master_tr) do
					if r.TrackFX_GetFloatingWindow(master_tr, 0x1000000+i) then
					src_mon_fx_idx = i; is_mon_fx_float = true break end
				end
			end
		return src_mon_fx_idx, is_mon_fx_float
	end

r.PreventUIRefresh(1)

local retval, tr, item = r.GetFocusedFX() -- account for focused FX chains and Mon FX chain in builds prior to 6.20
local fx_chain_focus = LOCK_FX_CHAIN_FOCUS or r.GetCursorContext() == -1

local obj, obj_type

	if (retval > 0 or GetMonFXProps() >= 0) and fx_chain_focus then -- (last) focused FX chain as GetFocusedFX() returns last focused which is still open
	obj, obj_type = table.unpack(retval == 2 and tr > 0 and {r.GetTrackMediaItem(r.GetTrack(0,tr-1), item), 1} or retval == 1 and tr > 0 and {r.GetTrack(0,tr-1), 0} or {r.GetMasterTrack(0), 0})
	else -- not FX chain
	local x, y = r.GetMousePosition()
		if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.37 then -- or '[%d%.]+'; SUPPORTS MCP
		local retval, info_str = r.GetThingFromPoint(x, y)
		obj, obj_type = table.unpack(info_str == 'arrange' and {({r.GetItemFromPoint(x, y, true)})[1], 1} -- allow locked is true
		or info_str:match('[mt]cp') and {r.GetTrackFromPoint(x, y), 0} or {nil})
		else
		-- First get item to avoid using edit cursor actions
		--[-[------------------------- WITHOUT SELECTION --------------------------------------------
		obj, obj_type = ({r.GetItemFromPoint(x, y, true)})[1], 1 -- get without selection, allow locked is true, the function returns both item and take pointers, here only item's is collected, works for focused take FX chain as well
		--]]
		--[[-----------------------------WITH SELECTION -----------------------------------------------------
		-- will require prior storage and restoration of selection (generally inefficient)
		r.Main_OnCommand(40289,0) -- Item: Unselect all items;  -- when SEL_OBJ_IN_CURR_CONTEXT option in the USER SETTINGS is OFF to prevent getting any selected item when mouse cursor is outside of Arrange proper (e.g. at the Mixer or Ruler or a focused Window), forcing its recognition only if the item is under mouse cursor, that's because when cursor is within Arrange and there's no item under it the action 40528 (below) itself deselects all items (until their selection is restored at script exit) and GetSelectedMediaItem() returns nil so there's nothing to fetch the data from, but when the cursor is outside of the Arrange proper (e.g. at the Mixer or Ruler) this action does nothing, the current item selection stays intact and so GetSelectedMediaItem() does return first selected item identificator
		r.Main_OnCommand(40528,0) -- Item: Select item under mouse cursor
		obj, obj_type = r.GetSelectedMediaItem(0,0), 1
		--]]
			if not obj then -- before build 6.37
			-- r.GetTrackFromPoint() covers the entire track timeline hence isn't suitable for getting the TCP
			local curs_pos = r.GetCursorPosition() -- store current edit curs pos
			local start_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false, screen_x_start, screen_x_end are 0 to get full arrange view coordinates // get time of the current Arrange scroll position to use to move the edit cursor away from the mouse cursor // https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and stop_time should be on the screen when non-zero when isSet is true
--local TCP_width = tonumber(cont:match('leftpanewid=(.-)\n')) -- only changes in reaper.ini when dragged
			local right_tcp = r.GetToggleCommandStateEx(0,42373) == 1 -- View: Show TCP on right side of arrange
			local edge = right_tcp and start_time-5 or end_time+5
			r.SetEditCurPos(edge, false, false) -- moveview, seekplay false // to secure against a vanishing probablility of overlap between edit and mouse cursor positions in which case edit cursor won't move just like it won't if mouse cursor is over the TCP // +/-5 sec to move edit cursor beyond right/left edge of the Arrange view to be completely sure that it's far away from the mouse cursor // if start_time is 0 and there's negative project start offset the edit cursor is still moved to the very start, that is past 0
			r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping) // more sensitive than with snapping
			local new_cur_pos = r.GetCursorPosition()
				if new_cur_pos == edge or new_cur_pos == 0 then -- the edit cursor stayed put at the pos set above since the mouse cursor is over the TCP // if the TCP is on the right and the Arrange is scrolled all the way to the project start or close enough to it start_time-5 won't make the edit cursor move past the project start hence the 2nd condition, but it can move past the right edge
				--[-[------------------------- WITHOUT SELECTION --------------------------------------------
				obj, obj_type = r.GetTrackFromPoint(x, y), 0 -- get without selection, works for focused track FX chain as well
				--]]
				--[[-----------------------------WITH SELECTION -----------------------------------------------------
				-- will require prior storage and restoration of selection (generally inefficient)
				r.Main_OnCommand(41110,0) -- Track: Select track under mouse
				obj, obj_type = r.GetSelectedTrack2(0,0, true), 0 -- account for Master is true
				--]]
				end
		-- restore edit cursor position
		--[[
			local min_val, subtr_val = table.unpack(new_cur_pos == edge and {curs_pos, edge} -- TCP found, edit cursor remained at edge
			or new_cur_pos ~= edge and {curs_pos, new_cur_pos} -- TCP not found, edit cursor moved
			or {0,0})
			r.MoveEditCursor(min_val - subtr_val, false) -- dosel false = don't create time sel; restore orig. edit curs pos, greater subtracted from the lesser to get negative value meaning to move closer to zero (project start) // MOVES VIEW SO IS UNSUITABLE
		--]]
		--[-[ OR SIMPLY
			r.SetEditCurPos(curs_pos, false, false) -- moveview, seekplay false // restore orig. edit curs pos
		--]]
			end
		end
	end

r.PreventUIRefresh(-1)

	return obj, obj_type

end


function GetObjInfo_Value(obj, param) -- param is a string // envelope included
local t = {'MediaItem*', 'MediaItem_Take*', 'MediaTrack*', 'TrackEnvelope*', 'ReaProject*'}
	for _, v in ipairs(t) do
		if reaper.ValidatePtr2(0, obj, v) then p = v break end
	end
local func = p == 'MediaItem*' and reaper.GetMediaItemInfo_Value or p == 'MediaItem_Take*' and reaper.GetMediaItemTakeInfo_Value or p == 'MediaTrack*' and reaper.GetMediaTrackInfo_Value or p == 'TrackEnvelope*' and reaper.GetEnvelopeInfo_Value or p == 'ReaProject*' and reaper.GetSetProjectInfo
return func(obj, param, 0, false) -- last two args are for project data, is_set is false
end


function SetObjInfo_Value(obj, param, val) -- param is a string, val is a number // envelope doesn't exist
local t = {'MediaItem*', 'MediaItem_Take*', 'MediaTrack*', 'ReaProject*'}
	for _, v in ipairs(t) do
		if reaper.ValidatePtr2(0, obj, v) then p = v break end
	end
local func = p == 'MediaItem*' and reaper.SetMediaItemInfo_Value or p == 'MediaItem_Take*' and reaper.SetMediaItemTakeInfo_Value or p == 'MediaTrack*' and reaper.SetMediaTrackInfo_Value or p == 'ReaProject*' and reaper.GetSetProjectInfo
return func(obj, param, val, true) -- last args is for project data, is_set is true
end


function GetSetObjInfo_String(obj, param, name, is_set) -- param and name are strings, is_set is boolean
local t = {'MediaItem*', 'MediaItem_Take*', 'MediaTrack*', 'ReaProject*'}
	for _, v in ipairs(t) do
		if reaper.ValidatePtr2(0, obj, v) then p = v break end
	end
local func = p == 'MediaItem*' and reaper.GetSetMediaItemInfo_String or p == 'MediaItem_Take*' and reaper.GetSetMediaItemTakeInfo_String or p == 'MediaTrack*' and reaper.GetSetMediaTrackInfo_String
return func(obj, param, name, is_set)
end


function GetObjAllInfo_Values(obj) -- as of REAPER 6.12c
local t = {'MediaItem*', 'MediaItem_Take*', 'MediaTrack*', 'TrackEnvelope*', 'ReaProject*', 'HWND'}
local p
	for _, v in ipairs(t) do
		if reaper.ValidatePtr2(0, obj, v) then p = v break end -- in REAPER builds prior to 7.06 ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') recognize ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) > 0 because in this case there're no points // SUCH VALIDATION IS ALWAYS TRUE FOR VALID TRACK FX ENVELOPES AND ALL TAKE ENVELOPES REGARDLESS OF VISIBILITY, FOR VISIBLE BUILT-IN TRACK ENVELOPES REGARDLESS OF PRESENCE OF USER CREATED POINTS AND FOR HIDDEN BUILT-IN TRACK ENVELOPES WHICH HAVE USER CREATED POINTS; FOR TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS HIDDEN PROGRAMMATICALLY IT'S FALSE THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE i.e. 'not env_chunk:match('\nPT %d')', BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, FUNCTIONS DO RETURN THEIR POINTER, HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES BECOME INVALID
	end
local t = p == 'MediaItem*' and {B_MUTE = 0, B_MUTE_ACTUAL = 0, C_MUTE_SOLO = 0, B_LOOPSRC = 0, B_ALLTAKESPLAY = 0, B_UISEL = 0, C_BEATATTACHMODE = 0, C_AUTOSTRETCH = 0, C_LOCK = 0, D_VOL = 0, D_POSITION = 0, D_LENGTH = 0, D_SNAPOFFSET = 0, D_FADEINLEN = 0, D_FADEOUTLEN = 0, D_FADEINDIR = 0, D_FADEOUTDIR = 0, D_FADEINLEN_AUTO = 0, D_FADEOUTLEN_AUTO = 0, C_FADEINSHAPE = 0, C_FADEOUTSHAPE = 0, I_GROUPID = 0, I_LASTY = 0, I_LASTH = 0, I_CUSTOMCOLOR = 0, I_CURTAKE = 0, IP_ITEMNUMBER = 0, F_FREEMODE_Y = 0, F_FREEMODE_H = 0, P_TRACK = 0}
or p == 'MediaItem_Take*' and {D_STARTOFFS = 0, D_VOL = 0, D_PAN = 0, D_PANLAW = 0, D_PLAYRATE = 0, D_PITCH = 0, B_PPITCH = 0, I_CHANMODE = 0, I_PITCHMODE = 0, I_CUSTOMCOLOR = 0, IP_TAKENUMBER = 0, P_TRACK = 0, P_ITEM = 0, P_SOURCE = 0}
or p == 'MediaTrack*' and {B_MUTE = 0, B_PHASE = 0, IP_TRACKNUMBER = 0, I_SOLO = 0, I_FXEN = 0, I_RECARM = 0, I_RECINPUT = 0, I_RECMODE = 0, I_RECMON = 0, I_RECMONITEMS = 0, I_AUTOMODE = 0, I_NCHAN = 0, I_SELECTED = 0, I_WNDH = 0, I_TCPH = 0, I_TCPY = 0, I_MCPX = 0, I_MCPY = 0, I_MCPW = 0, I_MCPH = 0, I_FOLDERDEPTH = 0, I_FOLDERCOMPACT = 0, I_MIDIHWOUT = 0, I_PERFFLAGS = 0, I_CUSTOMCOLOR = 0, I_HEIGHTOVERRIDE = 0, B_HEIGHTLOCK = 0, D_VOL = 0, D_PAN = 0, D_WIDTH = 0, D_DUALPANL = 0, D_DUALPANR = 0, I_PANMODE = 0, D_PANLAW = 0, P_ENV = 0, B_SHOWINMIXER = 0, B_MAINSEND = 0, C_MAINSEND_OFFS = 0, B_FREEMODE = 0, C_BEATATTACHMODE = 0, F_MCP_FXSEND_SCALE = 0, F_MCP_SENDRGN_SCALE = 0, I_PLAY_OFFSET_FLAG = 0, D_PLAY_OFFSET = 0, P_PARTRACK = 0, P_PROJECT = 0}
or p == 'TrackEnvelope*' and {I_TCPY = 0, I_TCPH = 0, I_TCPY_USED = 0, I_TCPH_USED = 0, P_TRACK = 0, P_ITEM = 0, P_TAKE = 0}
or p == 'ReaProject*' and {RENDER_SETTINGS = 0, RENDER_BOUNDSFLAG = 0, RENDER_CHANNELS = 0, RENDER_SRATE = 0, RENDER_STARTPOS = 0, RENDER_ENDPOS = 0, RENDER_TAILFLAG = 0, RENDER_TAILMS = 0, RENDER_ADDTOPROJ = 0, RENDER_DITHER = 0, PROJECT_SRATE = 0, PROJECT_SRATE_USE = 0}
local GET = p == 'MediaItem*' and reaper.GetMediaItemInfo_Value or p == 'MediaItem_Take*' and reaper.GetMediaItemTakeInfo_Value or p == 'MediaTrack*' and reaper.GetMediaTrackInfo_Value or p == 'ReaProject*' and reaper.GetSetProjectInfo
	if GET then -- not window handle HWND
	if type(t) == 'table' and next(t) then
		for k in pairs(t) do
		t[k] = GET(obj, k, 0, false) -- last two args are for project data, is_set is false // overwrite zeros in table fields with actual return values
		end
	return t
	else -- window handle
	return p
	end
end



function Get_Obj_By_GUID1(obj_type, GUID)
-- obj_type: 'track', 'item', 'take', 'track fx', 'take fx', 'env'; GUID is a string
-- return values are: track, item, take, take_id, fx_id, fx_parm_id, env, env_id
-- if fx_id >= 16777216 the fx is either track input fx or Mon FX if tr is the Master track
-- env_id is only valid if it's a track/take envelope (and not an fx param envelope) accessed with CountTrack/TakeEnvelopes and GetTrack/TakeEnvelope
-- for fx parm envelopes fx_parm_id is returned

local TRACK, ITEM = obj_type:match('track'), obj_type == 'item' or obj_type:match('take')
local obj_count = TRACK and r.CountTracks or (ITEM or obj_type == 'take') and r.CountMediaItems
local get_obj = TRACK and r.GetTrack or (ITEM or obj_type == 'take') and r.GetMediaItem
local get_info_string = TRACK and r.GetSetMediaTrackInfo_String or ITEM and r.GetSetMediaItemInfo_String

	if obj_type ~= 'env' then
		for i = (TRACK and -1 or ITEM and 0), obj_count(0)-1 do
		local obj = TRACK and i == -1 and r.GetMasterTrack(0) or get_obj(0,i)
		local ret, obj_GUID = get_info_string(obj, 'GUID', '', false) -- setNewValue false
			if (TRACK or ITEM) and obj_GUID == GUID then
			return TRACK and obj, ITEM and obj, take, take_id, fx_id, parm_id, env, env_id
			elseif obj_type == 'take' then
				for take_idx = 0, r.CountTakes(obj)-1 do
				local take = r.GetTake(obj, take_idx)
				local ret, take_GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
					if take_GUID == GUID then return tr, obj, take, take_idx, fx_id, parm_id, env, env_id end
				end
			elseif obj_type:match('fx') then
				if r.ValidatePtr(obj, 'MediaTrack*') then
					for fx_idx = 0, r.TrackFX_GetCount(obj)-1 do -- main fx chain
					local fx_GUID = r.TrackFX_GetFXGUID(obj, fx_idx)
						if fx_GUID == GUID then return obj, item, take, take_id, fx_idx, parm_id, env, env_id end
					end
					for fx_idx = 0, r.TrackFX_GetRecCount(obj)-1 do -- input and Mon fx chains
					local fx_GUID = r.TrackFX_GetFXGUID(obj, fx_idx+0x1000000) -- OR fx_idx + 16777216
						if fx_GUID == GUID then return obj, item, take, take_id, fx_idx+0x1000000, parm_id, env, env_id end
					end
				elseif r.ValidatePtr(obj, 'MediaItem*') then
					for take_idx = 0, r.CountTakes(obj)-1 do
					local take = r.GetTake(obj, take_idx)
						for fx_idx = 0, r.TakeFX_GetCount(take)-1 do
						local fx_GUID = r.TakeFX_GetFXGUID(take, fx_idx)
							if fx_GUID == GUID then return tr, obj, take, take_idx, fx_idx, parm_id, env, env_id end
						end
					end
				end
			end
		end
	else
		for i = -1, r.CountTracks(0)-1 do -- track envs
		local tr = r.GetTrack(0,i) or r.GetMasterTrack(0)
			-- CountTrackEnvelopes() only lists active track built-in and fx envelopes (isn't affected by enabled parameter modulation when no actual envelope is active) hence fx envelopes should be targeted separately first to avoid mixing up envelopes in different contexts
			-- GetFXEnvelope() returns envelope even if there's no active envelope but parameter modulation was enabled at least once, after disabling the data isn't removed from the chunk so env remains valid; must be validated with r.ValidatePtr(env, 'TrackEnvelope*') which only returns active envelope
			for fx_idx = 0, r.TrackFX_GetCount(tr)-1 do -- main fx chain
				for parm_idx = 0, r.TrackFX_GetNumParams(tr, fx_idx)-1 do -- fx parm envs
				local env = r.GetFXEnvelope(tr, fx_idx, parm_idx, false) -- create false
					if r.ValidatePtr(env, 'TrackEnvelope*') then
					local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
						if chunk:match('GUID ({.-})') == GUID then
						return tr, item, take, take_id, fx_idx, parm_idx, env, env_id end
					end
				end
			end

			-- (input and Mon FX don't support envelopes)

			for env_idx = 0, r.CountTrackEnvelopes(tr)-1 do
			local env = r.GetTrackEnvelope(tr, env_idx)
			local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
				if chunk:match('GUID ({.-})') == GUID then return tr, item, take, take_id, fx_id, parm_id, env, env_idx end
			end
		end

		for i = 0, r.CountMediaItems(0)-1 do
		local item = r.GetMediaItem(0,i)
			for take_idx = 0, r.CountTakes(item)-1 do
			local take = r.GetTake(item, take_idx)
				-- CountTakeEnvelopes() lists both take and take fx envelopes hence fx envelopes should be targeted separately first to avoid mixing up envelopes in different contexts
				for fx_idx = 0, r.TakeFX_GetCount(take)-1 do
					for parm_idx = 0, r.TakeFX_GetNumParams(take, fx_idx)-1 do
					local env = r.TakeFX_GetEnvelope(take, fx_idx, parm_idx, false) -- create false
					-- in REAPER builds prior to 7.06 TakeFX_GetEnvelope() returns env even if there's none but parameter mudulation was enabled at least once for the corresponding fx parameter hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
						if env and r.CountEnvelopePoints(env) > 0 then -- real, not ghost envelope // SUCH VALIDATION ONLY WORKS FOR VISIBLE TRACK BUILT-IN ENVELOPES EVEN WITHOUT USER CREATED POINTS, FOR HIDDEN TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS IT'S FALSE; FOR VALID TRACK FX AND ALL TAKE ENVELOPES IT'S ALWAYS TRUE
						local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
							if chunk:match('GUID ({.-})') == GUID then
							return tr, item, take, take_idx, fx_idx, parm_idx, env, env_id end
						end
					end
				end
				-- in REAPER builds prior to 7.06 CountTakeEnvelopes() lists ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
				for env_idx = 0, r.CountTakeEnvelopes(take)-1 do
				local env = r.GetTakeEnvelope(take, env_idx)
					if r.CountEnvelopePoints(env) > 0 then -- real, not ghost envelope
					local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
						if chunk:match('GUID ({.-})') == GUID then
						return tr, item, take, take_idx, fx_id, parm_id, env, env_idx end
					end
				end
			end
		end
	end

end


function Get_Obj_By_GUID2(GUID) -- GUID is a string
-- return values are: track, item, take, take_id, fx_id, fx_parm_id, env, env_id
-- if fx_id >= 16777216 the fx is either track input fx or Mon FX if tr is the Master track
-- env_id is only valid if it's a track/take envelope (and not an fx param envelope) accessed with CountTrack/TakeEnvelopes and GetTrack/TakeEnvelope
-- for fx parm envelopes fx_parm_id is returned

	for i = -1, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i) or r.GetMasterTrack(0)
	local ret, tr_GUID = r.GetSetMediaTrackInfo_String(tr, 'GUID', '', false) -- setNewValue false
		if tr_GUID == GUID then
		return tr, item, take, take_id, fx_id, parm_id, env, env_id
		end
		for fx_idx = 0, r.TrackFX_GetCount(tr)-1 do -- main fx chain
		local fx_GUID = r.TrackFX_GetFXGUID(tr, fx_idx)
			if fx_GUID == GUID then return tr, item, take, take_id, fx_idx, parm_id, env, env_id end
		-- CountTrackEnvelopes() only lists active track built-in and fx envelopes (isn't affected by enabled parameter modulation when no actual envelope is active) hence fx envelopes should be targeted separately first to avoid mixing up envelopes in different contexts
		-- GetFXEnvelope() returns envelope even if there's no active envelope but parameter modulation was enabled at least once, after disabling the data isn't removed from the chunk so env remains valid; must be validated with r.ValidatePtr(env, 'TrackEnvelope*') which only returns active envelope
			for parm_idx = 0, r.TrackFX_GetNumParams(tr, fx_idx)-1 do -- fx parm envs
			local env = r.GetFXEnvelope(tr, fx_idx, parm_idx, false) -- create false
				if r.ValidatePtr(env, 'TrackEnvelope*') then
				local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
					if chunk:match('GUID ({.-})') == GUID then
					return tr, item, take, take_id, fx_idx, parm_idx, env, env_id end
				end
			end
		end
		for fx_idx = 0, r.TrackFX_GetRecCount(tr)-1 do -- input and Mon fx chains
		local fx_GUID = r.TrackFX_GetFXGUID(tr, fx_idx+0x1000000) -- OR fx_idx + 16777216
			if fx_GUID == GUID then return tr, item, take, take_id, fx_idx+0x1000000, parm_id, env, env_id end
		end
		for env_idx = 0, r.CountTrackEnvelopes(tr)-1 do
		local env = r.GetTrackEnvelope(tr, env_idx)
		local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			if chunk:match('GUID ({.-})') == GUID then return tr, item, take, take_id, fx_id, parm_id, env, env_idx end
		end
	end

	for i = 0, r.CountMediaItems(0)-1 do
	local item = r.GetMediaItem(0,i)
	local ret, itm_GUID = r.GetSetMediaItemInfo_String(item, 'GUID', '', false) -- setNewValue false
		if itm_GUID == GUID then
		return tr, item, take, take_id, fx_id, parm_id, env, env_id
		end
		for take_idx = 0, r.CountTakes(item)-1 do
		local take = r.GetTake(item, take_idx)
		local ret, take_GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
			if take_GUID == GUID then return tr, item, take, take_idx, fx_id, parm_id, env, env_id end
			for fx_idx = 0, r.TakeFX_GetCount(take)-1 do
			local fx_GUID = r.TakeFX_GetFXGUID(take, fx_idx)
				if fx_GUID == GUID then return tr, item, take, take_idx, fx_idx, parm_id, env, env_id end
			-- CountTakeEnvelopes() lists both take and take fx envelopes hence fx envelopes should be targeted separately first to avoid mixing up envelopes in different contexts;
			-- in REAPER builds prior to 7.06 CountTakeEnvelopes() lists and TakeFX_GetEnvelope() returns ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
				for parm_idx = 0, r.TakeFX_GetNumParams(take, fx_idx)-1 do
				local env = r.TakeFX_GetEnvelope(take, fx_idx, parm_idx, false) -- create false
					if env and r.CountEnvelopePoints(env) > 0 then -- real, not ghost envelope
					local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
						if chunk:match('GUID ({.-})') == GUID then
						return tr, item, take, take_idx, fx_idx, parm_idx, env, env_id end
					end
				end
			end
			for env_idx = 0, r.CountTakeEnvelopes(take)-1 do
			local env = r.GetTakeEnvelope(take, env_idx)
				if r.CountEnvelopePoints(env) > 0 then -- real, not ghost envelope
				local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
					if chunk:match('GUID ({.-})') == GUID then
					return tr, item, take, take_idx, fx_id, parm_id, env, env_idx end
				end
			end
		end
	end

end

--[[ TESTING Get_Obj_By_GUID()
local tr = r.GetSelectedTrack2(0,0, true)
--Msg(tr)
--local ret, GUID = table.unpack(tr and {r.GetSetMediaTrackInfo_String(tr, 'GUID', '', false)} or {})
--Msg(GUID, 'MASTER')
local item = r.GetSelectedMediaItem(0,0)
--Msg(item)
--local ret, GUID = table.unpack(item and {r.GetSetMediaItemInfo_String(item, 'GUID', '', false)} or {})
local take = item and r.GetActiveTake(item)
--Msg(take)
--local ret, GUID = table.unpack(take and {r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false)} or {})
local env = r.GetSelectedEnvelope(0)
--Msg(env)
--Msg(r.CountEnvelopePoints(env), 'points')
local retval, chunk = table.unpack(env and {r.GetEnvelopeStateChunk(env, '', false)} or {}) -- isundo false
--local GUID = chunk and chunk:match('GUID ({.-})')
--local GUID = r.TrackFX_GetFXGUID(tr, 2)
--local GUID = r.TakeFX_GetFXGUID(take, 2)
--tr, item, take, take_id, fx_id, parm_id, env, env_id = Get_Obj_By_GUID('take fx', GUID)
tr, item, take, take_id, fx_id, parm_id, env, env_id = Get_Obj_By_GUID(GUID)
Msg(tr, 'TRACK')
Msg(item, 'ITEM')
Msg(take, 'TAKE')
Msg(take_id, 'TAKE ID')
Msg(fx_id, 'FX ID')
Msg(parm_id, 'PARM ID')
Msg(env, 'ENV')
Msg(env_id, 'ENV ID')
--]]


function Cascade_To_Target_Object()
-- priority is as follows: take under mouse, track under mouse, selected envelope parent take, selected envelope parent track, active take of selected item, selected track, last touched track
local x, y = r.GetMousePosition()
local item, take = r.GetItemFromPoint(x, y, false) -- allow_locked false
local tr, info = r.GetTrackFromPoint(x, y)
	if not take and not tr then -- no object under mouse		
	tr, take = Is_Selected_Track_Or_Take_Env()
		if not take and not tr then -- no selected envelope
		local item = r.GetSelectedMediaItem(0,0)
		take = item and r.GetActiveTake(item)
		tr = not take and r.GetSelectedTrack(0,0) -- no selected item
		tr = tr or r.GetLastTouchedTrack() -- no selected track
		end
	end
return take, tr
end


--========================= O B J E C T S   E N D ============================


--=================================== T R A C K S ==================================

--[[ SEND SETTINGS
-- Between the quotes insert number corresponding
-- to the send mode:
-- 1 - Post-Fader (Post-Pan)
-- 2 - Pre-Fader (Post-FX)
-- 3 - Pre-Fader (Pre-FX)
-- empty or invalid defaults to 1 - Post-Fader (Post-Pan)
SEND_MODE = ""

local send_modes_t = {['1'] = 0, ['2'] = 3, ['3'] = 1}
Msg(send_modes_t[SEND_MODE])
local send_mode = send_modes_t[SEND_MODE] or 0
]]


r.TrackList_AdjustWindows(r.GetToggleCommandStateEx(0,41146) == 0) -- Mixer: Toggle autoarrange // isMinor arg depends on the setting to only auto-arrange in the Mixer when the setting is enabled


function Get_TCP_MCP_Under_Mouse(want_mcp)
-- takes advantage of the fact that the action 'View: Move edit cursor to mouse cursor'
-- doesn't move the edit cursor when the mouse cursor is over the TCP;
-- r.GetTrackFromPoint() covers the entire track timeline hence isn't suitable for getting the TCP;
-- master track is supported;
-- want_mcp is boolean to address MCP under mouse, supported in builds 6.36+

-- in builds < 6.36 the function also detects MCP under mouse regardless of want_mcp argument
-- because when the mouse cursor is over the MCP the action 'View: Move edit cursor to mouse cursor'
-- does move the edit cursor unless the focused MCP is situated to the left of the Arrange view start
-- or to the right of the Arrange view end depending on the 'View: Show TCP on right side of arrange'
-- setting, which makes 'new_cur_pos == edge or new_cur_pos == 0' expression true because the edit cursor
-- being unable to move to the mouse cursor is moved to the Arrange view start_time/end_time,
-- in later builds this is prevented by conditioning the return value with info:match('tcp')
-- so that the focus is solely on TCP if want_mcp arg is false

-- for builds 6.36+ where GetThingFromPoint() is supported
local tr, info = table.unpack(r.GetThingFromPoint and {r.GetThingFromPoint(r.GetMousePosition())} or {})
	if info then
	return (want_mcp and info:match('mcp') or not want_mcp and info:match('tcp')) and tr
	end

local right_tcp = r.GetToggleCommandStateEx(0,42373) == 1 -- View: Show TCP on right side of arrange
local curs_pos = r.GetCursorPosition() -- store current edit curs pos
local start_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false, screen_x_start, screen_x_end are 0 to get full arrange view coordinates // get time of the current Arrange scroll position to use to move the edit cursor away from the mouse cursor // https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and end_time should be on the screen when non-zero when isSet is true // when the Arrange is scrolled all the way to the start the function ignores project start time offset and any offset start still treats as 0
--local TCP_width = tonumber(cont:match('leftpanewid=(.-)\n')) -- only changes in reaper.ini when dragged
r.PreventUIRefresh(1)
local edge = right_tcp and start_time-5 or end_time+5
r.SetEditCurPos(edge, false, false) -- moveview, seekplay false // to secure against a vanishing probablility of overlap between edit and mouse cursor positions in which case edit cursor won't move just like it won't if mouse cursor is over the TCP // +/-5 sec to move edit cursor beyond right/left edge of the Arrange view to be completely sure that it's far away from the mouse cursor // if start_time is 0 and there's negative project start offset the edit cursor is still moved to the very start, that is past 0, the function ignores negative start offset therefore is fully compatible with GetSet_ArrangeView2()
r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping) // more sensitive than with snapping // works along the entire screen Y axis outside of the TCP regardless of whether the program window is under the mouse
local new_cur_pos = r.GetCursorPosition()
local tcp_under_mouse = new_cur_pos == edge or new_cur_pos == 0 -- if the TCP is on the right and the Arrange is scrolled all the way to the project start or close enough to it start_time-5 won't make the edit cursor move past the project start hence the 2nd condition, but it can move past the right edge
-- Restore orig. edit cursor pos
--[[
local min_val, subtr_val = table.unpack(new_cur_pos == edge and {curs_pos, edge} -- TCP found, edit cursor remained at edge
or new_cur_pos ~= edge and {curs_pos, new_cur_pos} -- TCP not found, edit cursor moved
or {0,0})
r.MoveEditCursor(min_val - subtr_val, false) -- dosel false = don't create time sel; restore orig. edit curs pos, greater subtracted from the lesser to get negative value meaning to move closer to zero (project start) // MOVES VIEW SO IS UNSUITABLE
--]]
--[-[ OR SIMPLY
r.SetEditCurPos(curs_pos, false, false) -- moveview, seekplay false // restore orig. edit curs pos
--]]
r.PreventUIRefresh(-1)

return tcp_under_mouse and r.GetTrackFromPoint(r.GetMousePosition())

end



function Track_Visible_In_Arrange_Or_Mixer(tr)
-- not suitable for all cases because the truth depends on Mixer window being open
return r.IsTrackVisible(tr, r.GetToggleCommandState(40078) == 1) -- View: Toggle mixer visible // whether vis in the Mixer if mixer toggle state is ON or in Arrange if it's OFF
end


function Get_Top_Left_most_Visible_Track(want_selected)

local mixer_vis = r.GetToggleCommandState(40078) == 1 -- View: Toggle mixer visible // when Mixer is open leftmost visible, otherwise topmost
local H_W = mixer_vis and 'I_MCPW' or 'I_TCPH'
local Y_X = mixer_vis and 'I_MCPX' or 'I_TCPY'

	for i = 0, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i)
		if r.IsTrackVisible(tr, mixer_vis)
		and (not want_selected or want_selected and r.IsTrackSelected(tr))
		then
		local H_W = r.GetMediaTrackInfo_Value(tr, H_W) -- excluding EVP for TCP
		local Y_X = r.GetMediaTrackInfo_Value(tr, Y_X)
			if Y_X >= 0 or Y_X + H_W/2 >= 0 -- OR (Y_X < 0 and Y_X*-1 <= H_W/2) OR (Y_X < 0 and Y_X*2*-1 <= H_W) -- // either entire TCP/MCP is visible or the visible part is greater or equal to the invisible one, *-1 to rectify the negative Y/X value for the sake of accurate comparison when TCP/MCP is partially visible
			then
			return tr, i
			end
		end
	end

end


function Get_First_Visible_Track(want_scroll_pos, want_arrange, want_selected)
-- if want_scroll_pos is false will return the very first visible
-- even if out of sight

local mixer_vis = r.GetToggleCommandState(40078) == 1 -- View: Toggle mixer visible

	if not mixer_vis and want_arrange then return -- prevents getting Arrange data twice in the main routine in actions targetting both contexts, because when mixer is closed there's no point in getting the Arrange data with the second instance of the function and want_arrange arg being true, as it would be returned by the first instance of the function
	elseif want_arrange then mixer_vis = false end -- to be able to get Arrange data on demand with want_arrange arg being true when mixer is open

local H_W = mixer_vis and 'I_MCPW' or 'I_TCPH'
local Y_X = mixer_vis and 'I_MCPX' or 'I_TCPY'
local Get = r.GetMediaTrackInfo_Value
	for i = 0, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i)
	local H_W = Get(tr, H_W)
	local Y_X = Get(tr, Y_X)
		if r.IsTrackVisible(tr, mixer_vis) and
		(not want_selected or want_selected and r.IsTrackSelected(tr))
		then
			if not want_scroll_pos or want_scroll_pos
			and (Y_X >= 0 or Y_X + H_W/2 >= 0) then -- either fully visible or mostly visible, i.e. at least half the height/width is visible
			return tr, Y_X end
		end
	end
end



function CountVisibleTracks(want_tcp, want_mcp)
local cnt = 0
	for i=0, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i)
	local tcp = r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1
	local mcp = r.GetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER') == 1
	-- OR
	-- tcp = r.IsTrackVisible(tr, false) -- mixer_vis false
	-- mcp = r.IsTrackVisible(tr, true) -- mixer_vis true
		if want_tcp and want_mcp and tcp and mcp
		or want_tcp and tcp or want_mcp and mcp then
		cnt = cnt+1
		end
	end
return cnt
end


function Get_Track_At_Mouse_Cursor_Y() -- covers the entire track timeline
local x, y = r.GetMousePosition()
local tr, info_code = reaper.GetTrackFromPoint(x, y)
return tr and info_code < 1 and tr -- not envelope and not docked FX window
end


function collapse_TCP1(tr) -- INSTEAD OF THE ACTON USE r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', 1)
-- Since botched track zoom overhaul in 6.76 https://forum.cockos.com/showthread.php?t=278646 only works invisibly with PreventUIRefresh(), but then monitoring of track height change won't work because the UI won't update, see alternative collapse_TCP2()
	repeat
	local tr_height = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
	r.Main_OnCommand(41326,0) -- View: Decrease selected track heights
	until r.GetMediaTrackInfo_Value(tr, 'I_TCPH') == tr_height -- until TCP height doesn't change after action is applied meaning it's been fully contracted
r.TrackList_AdjustWindows(true) -- -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275
end


-- VERY SLUGGISH, AND THAT'S JUST ONE TRACK
function collapse_TCP2(tr) -- INSTEAD OF THE ACTON USE r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', 1)
-- Since botched track zoom overhaul in 6.76 https://forum.cockos.com/showthread.php?t=278646 only works invisibly with PreventUIRefresh()
r.PreventUIRefresh(1)
local count = 0
	repeat
	r.Main_OnCommand(41326,0) -- View: Decrease selected track heights // in increments of 8 px
	count = count+1
	until count == 100 -- run 100 cycles which equals reduction by 800 px, should be plenty enough
r.PreventUIRefresh(-1)
r.TrackList_AdjustWindows(true) -- -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275
end


function Deselect_All_Tracks1()
	if r.CountTracks(0) > 0 then -- OR r.GetNumTracks() > 0
	local tr = r.GetTrack(0,0)
	r.SetOnlyTrackSelected(tr)
	r.SetTrackSelected(tr, false) -- selected false
	end
end


function Deselect_All_Tracks2() -- API alternative to the action 'Track: Unselect all tracks' (40297)
local master = r.GetMasterTrack(0) -- Master track because it's always there
r.SetOnlyTrackSelected(master)
r.SetTrackSelected(master, false) -- selected is false
end


function Track_Controls_Locked1(tr) -- locked is 1, not locked is nil
-- takes advantage of the inability to mute a track
-- whose controls are locked, even via API
	if tr == r.GetMasterTrack(0) then return end -- Master track controls cannot be locked
r.PreventUIRefresh(1)
local mute_state = r.GetMediaTrackInfo_Value(tr, 'B_MUTE')
r.SetMediaTrackInfo_Value(tr, 'B_MUTE', mute_state ~ 1) -- flip the state
local mute_state_new = r.GetMediaTrackInfo_Value(tr, 'B_MUTE')
local locked
	if mute_state == mute_state_new then locked = 1
	else r.SetMediaTrackInfo_Value(tr, 'B_MUTE', mute_state) -- restore
	end
r.PreventUIRefresh(-1)
return locked
end


function Track_Controls_Locked2(tr) -- Track_Controls_Locked1 is preferable because it doesn't rely on the chunk
local ret, chunk = r.GetTrackStateChunk(tr, '', false) -- isundo false
return chunk:match('NAME.-LOCK 1') -- when not locked LOCK attribute is absent in the chunk
end


function Preserve_TCP_Heights_When_Bot_Dock_Open()
-- TCP height isn't preserved when bottom dock is opened if the height was changed with vertical zoom
-- https://forum.cockos.com/showthread.php?t=267091#2 -- Edgemeal
	if r.GetToggleCommandStateEx(0,40279) == 1 then -- bottom docker open
	r.Main_OnCommand(40279, 0) -- View: Show docker / (toggle close it)
	else
	r.PreventUIRefresh(1)
	r.Main_OnCommand(reaper.NamedCommandLookup('_SWS_SAVESEL'), 0) -- SWS: Save current track selection
	r.Main_OnCommand(40296, 0) -- Track: Select all tracks
	r.Main_OnCommand(41327, 0) -- View: Increase selected track heights a little bit
	r.Main_OnCommand(41328, 0) -- View: Decrease selected track heights a little bit
	-- reaper.Main_OnCommand(40297, 0) -- Track: Unselect all tracks -- (Not Needed ?)
	r.Main_OnCommand(reaper.NamedCommandLookup('_SWS_RESTORESEL'), 0) -- SWS: Restore saved track selection
	r.Main_OnCommand(40279, 0) -- View: Show docker
	r.PreventUIRefresh(-1)
	end
end


function Re_Store_Track_Heights_Selection_x_Scroll(t, ref_tr_y) -- scroll state isn't restored
	if not t then
	local t = {}
		for i=0, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i)
		t[#t+1] = {height=r.GetMediaTrackInfo_Value(tr, 'I_TCPH'), sel=r.IsTrackSelected(tr)}
		end
	local ref_tr = r.GetTrack(0,0) -- reference track (any) to scroll back to in order to restore scroll state after track heights restoration
	local ref_tr_y = r.GetMediaTrackInfo_Value(ref_tr, 'I_TCPY')
	return t, ref_tr_y
	else
		for k, data in ipairs(t) do -- restore heights
		local height = data.height
		local tr = r.GetTrack(0,k-1)
		local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
			if tr_h ~= height then
			r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', height)
			r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275

			--[[ -- Since botched track zoom overhaul in 6.76 https://forum.cockos.com/showthread.php?t=278646 track heights cannot be changed smoothly with actions
			local bigger, smaller = tr_h > height, tr_h < height
			local action = bigger and 41326 -- View: Decrease selected track heights
			or smaller and 41325 -- View: Increase selected track heights
			r.SetOnlyTrackSelected(tr)
				repeat
				r.Main_OnCommand(action, 0)
				-- r.Main_OnCommand(41327, 0) -- View: Increase selected track heights a little bit
				-- r.Main_OnCommand(41328, 0) -- View: Decrease selected track heights a little bit
				local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
			until bigger and tr_h <= height or smaller and tr_h >= height
			]]
			end
		end
		for k, data in ipairs(t) do -- restore selection
		local tr = r.GetTrack(0,k-1)
		r.SetTrackSelected(tr, data.sel)
		end
	r.PreventUIRefresh(1)
		repeat
		r.CSurf_OnScroll(0, -1) -- y is negative to scroll up because after track heights restoration the tracklist ends up being scrolled all the way down // 1 vert scroll unit is 8 px
		until r.GetMediaTrackInfo_Value(ref_tr, 'I_TCPY') >= ref_tr_y
	r.PreventUIRefresh(-1)
	end

end



function Temp_Track_For_FX(obj, fx_idx, take_GUID)
-- instead of using take_GUID to condition selection of take related function use
-- local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')

r.PreventUIRefresh(1)

-- r.Main_OnCommand(40702, 0) -- Track: Insert new track at end of track list and hide it // creates undo point hence unsuitable
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0) -- hide in Mixer
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0) -- hide in Arrange

r.TrackFX_AddByName(temp_track, 'Video processor', 0, -1) -- insert
local copy = take_GUID and r.TakeFX_CopyToTrack(obj, fx_idx, temp_track, 0, false) or not take_GUID and r.TrackFX_CopyToTrack(obj, fx_idx, temp_track, 0, false) -- is_move false // difficult to work with r.TrackFX_AddByName() using plugin names as they can be renamed which will only be reflected in reaper-vstrenames(64).ini, not in the chunk; 'not take_GUID' cond is needed to avoid error when object is take which doesn't fit TrackFX_CopyToTrack() function // when copying FX envelopes don't follow, only when moving; since 6.37 TrackFX_AddByName() can be safely used after retrieving fx name displayed in the FX browser with r.Track/TakeFX_GetNamedConfigParm(obj, fx_idx, 'original_name') or 'fx_name'

-- DO STUFF --

local copy = take_GUID and r.TrackFX_CopyToTake(temp_track, 0, obj, fx_idx, false) or not take_GUID and r.TrackFX_CopyToTrack(temp_track, 0, obj, fx_idx, false) -- copy back from temp track

r.DeleteTrack(temp_track)

r.PreventUIRefresh(-1)

return -- STUFF

end



function Insert_Temp_Track(want_midi_editor, tr_name)

r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
local temp_tr = r.GetTrack(0,r.CountTracks(0)-1)
local name = tr_name and r.GetSetMediaTrackInfo_String(temp_tr, 'P_NAME', tr_name, true) -- setNewValue true
r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINMIXER', 0) -- hide in Mixer
	if not want_midi_editor then
	-- Must not be hidden in Arrange if a temp item on the temp track must be opened
	-- in the MIDI Editor, otherwise it may end up not being deleted after opening the MIDI Editor,
	-- it doesn't if the function is run on REAPER startup, may need testing in other scenarios
	r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINTCP', 0) -- hide in Arrange // IF TRACK IS HIDDEN IN ARRANGE ITEM CANNOT BE GLUED
	else -- insert temp MIDI item
	local ACT = reaper.Main_OnCommand
	ACT(40914, 0) -- Track: Set first selected track as last touched track (to make it the target for temp MIDI item insertion)
	ACT(40214, 0) -- Insert new MIDI item...
	ACT(40153, 0) -- Item: Open in built-in MIDI editor (set default behavior in preferences)
	end

-- DO STUFF --

r.DeleteTrack(temp_tr)

end




function Insert_Delete_Temp_Track(obj, input_fx, temp_tr)
-- the function was meant to be used for copying FX over to the temp track
-- and processing them there to prevent affecting their settings on the original object
-- input_fx is boolean to modify fx indices

	if not temp_tr then
	r.PreventUIRefresh(1)
	r.InsertTrackAtIndex(r.GetNumTracks(), false) -- insert new track at end of track list and hide it; action 40702 creates undo point
	local temp_tr = r.GetTrack(0,r.CountTracks(0)-1)
	r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINMIXER', 0) -- hide in Mixer
	r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINTCP', 0) -- hide in Arrange

	local countFX, copyFX = table.unpack(r.ValidatePtr(obj, 'MediaItem_Take*')
	and {r.TakeFX_GetCount, r.TakeFX_CopyToTrack}
	or r.ValidatePtr(obj, 'MediaTrack*')
	and {input_fx and r.TrackFX_GetRecCount or r.TrackFX_GetCount, r.TrackFX_CopyToTrack} or {})

		if countFX then
			for i=0, countFX(obj)-1 do
			local src_fx_idx = input_fx and i+0x1000000 or i
			copyFX(obj, src_fx_idx, temp_tr, i, false) -- is_move false
			end
		r.PreventUIRefresh(-1)
		return temp_tr
		end

	else
	r.DeleteTrack(temp_tr)
	end

end



function insert_get_delete_bckgrnd_track(scr_cmdID, delete)
-- scr_cmdID comes from r.get_action_context(), delete is boolean
local take_GUID = r.GetExtState(scr_cmdID, 'TAKE_GUID')
-- string gGUID = reaper.stringToGuid(string str, string gGUID)
local take = #take_GUID > 0 and r.GetMediaItemTakeByGUID(0, take_GUID)
local tr = take and r.GetMediaItemTake_Track(take)
	if not tr and not delete then -- create if not yet created or deleted
	local SET = r.SetMediaTrackInfo_Value
	r.PreventUIRefresh(1)
	r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false
	local idx = r.GetNumTracks()-1
	tr = r.GetTrack(0, idx)
	SET(tr, 'B_SHOWINTCP', 0); SET(tr, 'B_SHOWINMIXER', 0);	SET(tr, 'B_MAINSEND', 0)
	local item = r.AddMediaItemToTrack(tr) -- length is 0 so will be invisible
	local take = r.AddTakeToMediaItem(item) -- add take to be able to find track via the take and dispense with iterating over all tracks in the project
	local retval, take_GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
	r.SetExtState(scr_cmdID, 'TAKE_GUID', take_GUID, false) -- persist false
	r.PreventUIRefresh(-1)
	elseif tr and delete then
	r.DeleteTrack(tr) return
	end
return tr, take
end



function Get_Vis_TCP_Tracklist_Length_px_X_Topmost_Track(unhide, exclusive_track_display) -- return values are used to scroll tracklist all the way up and then, if needed, to restore the position of the track which was the topmost prior to that thereby restoring tracklist scroll position

--[[ -- UNHIDING AND GETTING TRACKLIST LENGTH IN THE SAME FUNCTION DOESN'T WORK
	for i = 0, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i)
	local name, flags = r.GetTrackState(tr)
	-- Unhide previosuly hidden with the script with -h operator
		if flags&512 == 512 then -- invisible in TCP -- OR r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 0
		local retval, ext_data = r.GetSetMediaTrackInfo_String(tr, 'P_EXT:'..cmdID, '', false) -- setNewValue false // find if it was hidden with this script
			if retval then r.GetSetMediaTrackInfo_String(tr, 'P_EXT:'..cmdID, '', true) -- setNewValue true // delete ext data
			r.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', 1) -- unhide in TCP
			end
		end
	end
r.TrackList_AdjustWindows(false) -- isMinor false - both TCP and MCP
--]]

	local function get_next_vis_track(cur_idx)
		for i = cur_idx, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i)-- or master_vis and r.GetMasterTrack(0)
		local name, flags = r.GetTrackState(tr)
			if flags&512 ~= 512 then return tr end
		end
	end

local master_vis = r.GetMasterTrackVisibility()&1 -- in TCP // OR r.GetToggleCommandStateEx(0,40075) == 1 -- View: Toggle master track visible

local tracklist_len, topmost_vis_tr
--	for i = 0, r.CountTracks(0)-1 do
	for i = master_vis and -1 or 0, r.CountTracks(0)-1 do -- -1 to account for the Master track if visible in the TCP
	local tr = r.GetTrack(0,i) or master_vis and r.GetMasterTrack(0)
	local name, flags = r.GetTrackState(tr) -- reget the state after unhiding (if ever) to account for in the TCP length
		if flags&512 ~= 512 then -- visible in TCP -- OR r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1
		local tr_TCPY = r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
			if not topmost_vis_tr and tr_TCPY + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') >= 0 -- find 1st track whose TCP top is at 0 px or which crosses from negative (partially hidden from view at the top) to positive pixel value
			then
				if math.abs(tr_TCPY) < r.GetMediaTrackInfo_Value(tr, 'I_WNDH')/2 -- store the top track as long as its TCPY value is less than the half of its height + envelopes, i.e. sticks out of the Arrange top edge by at least half of its height + envelopes and if less, the next track will be stored and scrolled to; math.abs to account for negative TCPY value when part of a track is hidden at the top // store only once, as long as topmost_vis_tr is nil
				and (not (unhide and exclusive_track_display) or unhide and exclusive_track_display and i~=-1) -- accounting for cases of 's' operator usage while not in exclusive display mode and its usage while in exclusive display mode with Master track being the topmost visible to ensure that the topmost media track is kept at the top instead when all tracks are unhidden
				then
				topmost_vis_tr = tr
				else -- if the top track is hidden by more than half or when going out of the exclusive display mode with Master track visible, store the next track
				topmost_vis_tr = get_next_vis_track(i+1) or tr -- store only once as long as topmost_vis_tr is nil // accounting for a case where there's no next track
				end
			end
		tracklist_len = tr_TCPY + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl envelopes // count
		end
	end

return tracklist_len, topmost_vis_tr

end
--[[ USE:

local tracklist_len, topmost_vis_tr = Get_Vis_TCP_Tracklist_Length_px_X_Topmost_Track(unhide, exclusive_track_display)

r.CSurf_OnScroll(0, tracklist_len*-1) -- scroll the tracklist all the way up, without division by 8, to the very start to then be able to scroll down from 0 (I_TCPY value of the 1st visible track) searching for a specific track

local topmost_vis_tr_I_TCPY = r.GetMediaTrackInfo_Value(topmost_vis_tr, 'I_TCPY')

r.CSurf_OnScroll(0, round(topmost_vis_tr_I_TCPY/8))
]]




--[[

-- In certain cases, scrolling may need to be preceded
-- by resetting the entire track list scroll position
-- to ensure that repeated scrolls don't cause drifts
-- in the TCP final Y coordinate, so do this

r.PreventUIRefresh(1)
Scroll_Track_To_Top(r.GetTrack(0,0)) -- first scroll the very 1st track to top resetting tracklist scroll position to ensure that the the target track scroll position doesn't drift with each script run which happens because after each scroll the Y coordinate it stops at slightly changes
Scroll_Track_To_Top(tr) -- scroll to the target track
r.PreventUIRefresh(-1)
]]


function Scroll_Track_To_Top1(tr, env) -- see more versatile v3 below
-- env arg is optional, only if the first envelope
-- displayed in its own lane needs to be scrolled to

-- calculate height of the pinned tracks (supported since 7.46)
-- only if pinned tracks are displayed in the pinned area
-- i.e. Track: Override/unpin all pinned tracks in TCP option is Off
local top_Y = 0
	if r.GetToggleCommandState(43573) == 0 then -- Track: Override/unpin all pinned tracks in TCP 
		for i=0, r.GetNumTracks()-1 do
		local tr = r.GetTrack(0,i)
			if r.IsTrackVisible(tr, false) -- mixer false
			and r.GetMediaTrackInfo_Value(tr, 'B_TCPPIN') == 1 then
			top_Y = top_Y + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl. envelopes
			end
		end
	top_Y = top_Y > 0 and top_Y+10 or top_Y -- 10 px is pinned track area separator width
	end

local GetValue = r.GetMediaTrackInfo_Value
local tr_y = GetValue(tr, 'I_TCPY')
--local tr_h = GetValue(tr, 'I_TCPH')
local env_y = env and r.GetEnvelopeInfo_Value(env, 'I_TCPY') or 0 -- the result is the same as with tr_h

local dir = tr_y < top_Y and -1 or tr_y > top_Y and 1 or 0 -- if less than 0 (out of sight above) the scroll must move up to bring the track into view, hence -1 and vice versa
r.PreventUIRefresh(1)
local cntr, Y_init = 0 -- to store track Y coordinate between loop cycles and monitor when the stored one equals to the one obtained after scrolling within the loop which will mean the scrolling can't continue due to reaching scroll limit when the track is close to the track list end or is the very last, otherwise the loop will become endless because there'll be no condition for it to stop
    repeat
    r.CSurf_OnScroll(0, dir) -- unit is 8 px
    local Y = GetValue(tr, 'I_TCPY')
		if Y ~= Y_init then Y_init = Y -- store
		else cntr = cntr+1
		end
	until not Y or dir > 0 and Y+env_y <= top_Y or dir < 0 and Y+env_y >= top_Y or cntr == 1 -- not Y if tr is invalid
--[[OR
	repeat
    r.CSurf_OnScroll(0, dir) -- unit is 8 px
    local Y = r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
		if Y ~= Y_init then Y_init = Y -- store
		else break end -- if scroll has reached the end before track has reached the destination to prevent loop becoming endless
	until dir > 0 and Y <= top_Y or dir < 0 and Y >= top_Y
--]]

r.PreventUIRefresh(-1)

end


function Scroll_Track_To_Top2(tr, env) -- see more versatile v3 below
-- env arg is optional, only if the first envelope
-- displayed in its own lane needs to be scrolled to

-- calculate height of the pinned tracks (supported since 7.46)
-- only if pinned tracks are displayed in the pinned area
-- i.e. Track: Override/unpin all pinned tracks in TCP option is Off
local top_Y = 0
	if r.GetToggleCommandState(43573) == 0 then -- Track: Override/unpin all pinned tracks in TCP 
		for i=0, r.GetNumTracks()-1 do
		local tr = r.GetTrack(0,i)
			if r.IsTrackVisible(tr, false) -- mixer false
			and r.GetMediaTrackInfo_Value(tr, 'B_TCPPIN') == 1 then
			top_Y = top_Y + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl. envelopes
			end
		end
	top_Y = top_Y > 0 and top_Y+10 or top_Y -- 10 px is pinned track area separator width
	end

local GetValue = r.GetMediaTrackInfo_Value
local tr_y = GetValue(tr, 'I_TCPY')
--local tr_h = GetValue(tr, 'I_TCPH')
local env_y = env and r.GetEnvelopeInfo_Value(env, 'I_TCPY') or 0 -- the result is the same as with tr_h

local dir = tr_y < top_Y and -1 or tr_y > top_Y and 1 -- if less than 0 (out of sight above) the scroll must move up to bring the track into view, hence -1 and vice versa
r.PreventUIRefresh(1)
local Y_init -- to store track Y coordinate between loop cycles and monitor when the stored one equals to the one obtained after scrolling within the loop which will mean the scrolling can't continue due to reaching scroll limit when the track is close to the track list end or is the very last, otherwise the loop will become endless because there'll be no condition for it to stop
	if dir then
		repeat
		r.CSurf_OnScroll(0, dir) -- unit is 8 px
		local Y = GetValue(tr, 'I_TCPY')
			if Y ~= Y_init then Y_init = Y -- store
			else break end -- if scroll has reached the end before track has reached the destination to prevent loop becoming endless
		until dir > 0 and Y+env_y <= top_Y or dir < 0 and Y+env_y >= top_Y
	end
r.PreventUIRefresh(-1)
end



function Scroll_Track_To_Top3(tr, item_Y)
-- scroll track to any Y coordinate within track, not necessarily to its own Y coordinate
-- tr is item parent track or track within which the item_Y coordinate is located
-- item_Y is item I_LASTY attribute or calculated item/take top edge
-- to scroll to track own Y coordinate item_Y must be 0, in which case 
-- pinned tracks height must be taken into account;
-- IN CERTAIN CASES OF SCROLLING DOWN (dir var is -1) TO THE COORDINATE WITHIN THE TRACK
-- THE FUNCTIOM MAY NEED TO BE PRECEDED WITH ANOTHER INSTANCE WHERE item_Y arg is 0
-- so that in the 2nd instance the scrolling starts from track Y coordinate being 0 
-- rather than negative because otherwise the condition 'dir > 0 and Y <= item_Y' 
-- will prevent scrolling since it becomes true at the very beginning of the loop

local item_Y = item_Y
	if item_Y == 0 and r.GetToggleCommandState(43573) == 0 -- Track: Override/unpin all pinned tracks in TCP
	then
		-- calculate height of the pinned tracks (supported since 7.46)
		for i=0, r.GetNumTracks()-1 do
		local tr = r.GetTrack(0,i)
			if r.IsTrackVisible(tr, false) -- mixer false
			and r.GetMediaTrackInfo_Value(tr, 'B_TCPPIN') == 1 then
			item_Y = item_Y + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl. envelopes
			end
		end
	item_Y = item_Y > 0 and item_Y+10 or item_Y -- 10 px is pinned track area separator width
	end

local item_Y = item_Y*-1 -- converting to negative to reliably compare with track Y coordinate in determining the scroll direction, as a result item_Y coordinate will always be smaller than positive track Y coordinate to condition direction +1 (upwards, scrollbar moves down), and will always be greater than negative track Y coordinate to condition scroll direction -1 (downwards, scrollbar moves up)
local GetValue = r.GetMediaTrackInfo_Value
local tr_y = GetValue(tr, 'I_TCPY')
local dir = tr_y < item_Y and -1 or tr_y > item_Y and 1 -- if less than 0 (out of sight above) the scroll must move up to bring the track into view, hence -1 and vice versa
r.PreventUIRefresh(1)
local Y_init -- to store track Y coordinate between loop cycles and monitor when the stored one equals to the one obtained after scrolling within the loop which will mean the scrolling can't continue due to reaching scroll limit when the track is close to the track list end or is the very last, otherwise the loop will become endless because there'll be no condition for it to stop
	if dir then
		repeat
		r.CSurf_OnScroll(0, dir) -- unit is 8 px
		local Y = GetValue(tr, 'I_TCPY')
			if Y ~= Y_init then Y_init = Y -- store
			else break end -- if scroll has reached the end before track has reached the destination to prevent loop becoming endless
	--	until dir > 0 and Y <= 0 or dir < 0 and Y >= 0
		until dir > 0 and Y <= item_Y or dir < 0 and Y >= item_Y
	end
r.PreventUIRefresh(-1)
end



function Scroll_Closest_Track_To_Top(last_idx)
-- relies on Scroll_Track_To_Top2()
-- first find first track which is likely visible, i.e. its TCP Y coordinate is >= top_Y
-- or Y < top_Y and Y+height > top_Y, to prevent changing the scroll state drastically,
-- where top_Y is either 0 or pinned tracks combined height (since build 7.46);
-- if within view nothing is found, first matching track (in this case a track with a visible envelope) 
-- out of sight at the bottom will be brought into view,
-- if such track couldn't be found, search is performed again from
-- the first visible track up in reverse,
-- that is among tracks out of sight at the top,
-- so that the track closest to the visible tracklist start
-- is always scrolled into view at the top

local tr_cnt = r.GetNumTracks()
local last_idx = last_idx
local st, fin, dir = table.unpack(not last_idx and {0,tr_cnt-1,1} or {last_idx-1,0,-1})

-- calculate height of the pinned tracks (supported since 7.46)
-- only if pinned tracks are displayed in the pinned area
-- i.e. Track: Override/unpin all pinned tracks in TCP option is Off
local top_Y = 0
	if r.GetToggleCommandState(43573) == 0 then -- Track: Override/unpin all pinned tracks in TCP 
		for i=0, r.GetNumTracks()-1 do
		local tr = r.GetTrack(0,i)
			if r.IsTrackVisible(tr, false) -- mixer false
			and r.GetMediaTrackInfo_Value(tr, 'B_TCPPIN') == 1 then
			top_Y = top_Y + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl. envelopes
			end
		end
	top_Y = top_Y > 0 and top_Y+10 or top_Y -- 10 px is pinned track area separator width
	end

	for i=st, fin, dir do
	local tr = r.GetTrack(0,i)
	local retval, flags = r.GetTrackState(tr)
		if flags&512 ~= 512 then -- visible in TCP
		local Y = r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
	--	local H = r.GetMediaTrackInfo_Value(tr, 'I_TCPH') -- excluding envelopes
		local H = r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl envelopes
			if not last_idx and (Y >= top_Y or Y < top_Y and Y+H > top_Y) or last_idx then
			last_idx = i
			------------- Script specific condition -----------------
			----- that determines which track needs scrolling, ------
			---------------- subject to change ----------------------
				for i=0, r.CountTrackEnvelopes(tr)-1 do
				local env = r.GetTrackEnvelope(tr,i)
					if Is_Env_Visible(env) then
			----------------------------------------------------------
					r.PreventUIRefresh(1)
					Scroll_Track_To_Top2(r.GetTrack(0,0)) -- first scroll the very 1st track to top resetting tracklist scroll position to ensure that the ECP scroll position doesn't drift with each script run which happens because after each scroll, the Y coordinate it stops at slightly changes
					Scroll_Track_To_Top2(tr,env) -- scroll to the target track ECP
					r.PreventUIRefresh(-1)
					return true
					end
				end
			end
		end
	end
	
return Scroll_Closest_Track_To_Top(last_idx) -- if not found after the first visible track, run the loop again from the first visible at last_idx backwards to the tracklist start

end



function Scroll_Track_To_Bottom(tr, arrange_h) -- arrange_h is the value returned by Get_Arrange_and_Header_Heights2()/GetSet_Track_Zoom_100_Perc() or Get_Arrange_Dims() functions
local tr_y = r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
local dir = tr_y < 0 and -1 or tr_y > 0 and 1 or 0 -- if less than 0 (out of sight above) the scroll must move up to bring the track into view, hence -1 and vice versa
r.PreventUIRefresh(1)
local cntr, Y_init = 0 -- to store track Y coordinate between loop cycles and monitor when the stored one equals to the one obtained after scrolling within the loop which will mean the scrolling can't continue due to reaching scroll limit when the track is close to the track list start or is the very first, otherwise the loop will become endless because there'll be no condition for it to stop
    repeat
    r.CSurf_OnScroll(0, dir) -- unit is 8 px
--  local tr = r.GetTrack(0, r.CSurf_TrackToID(tr, false)-3) -- 2nd prev track
    local tr = r.GetTrack(0, r.CSurf_TrackToID(tr, false)-2) -- prev track // otherwise the track list stops at the next track
    local Y = r.GetMediaTrackInfo_Value(tr, 'I_TCPY') -- mcpView false
		if Y ~= Y_init then Y_init = Y -- store
		else cntr = cntr+1
		end
--  local H = r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- mcpView false // only needed if 2nd prev track is used which is unnecessary
 -- until not Y or dir > 0 and Y+H <= arrange_h or dir < 0 and Y+H >= arrange_h or cntr == 1 // if 2nd prev track is used
	until not Y or dir > 0 and Y <= arrange_h or dir < 0 and Y >= arrange_h or cntr == 1 -- not Y if tr is invalid
r.PreventUIRefresh(-1)
end



function Scroll_Track_Into_View(tr, take, parent_tr_y)
-- parent_tr_y is original I_TCPY coordinate of the track
-- before it's affected by the function
-- relies on re_store_sel_trks1() function

-- scroll track vertically into view if out of sight
local tr = take and r.GetMediaItemTake_Track(take) or tr
local tr_h = tr and r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
local tr_top = tr and r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
local arrange_h, header_h, wnd_h_offset = Get_Arrange_Dims() -- only returns values if extensions are installed

	if tr_h and (parent_tr_y and tr_top ~= parent_tr_y -- track position changed
	or tr_h / 2 + tr_top < 0 -- fully or mainly out of sight at the top
	or arrange_h and tr_h / 2 + tr_top > arrange_h) -- fully or mainly out of sight at the bottom
	then
	local t = re_store_sel_trks1() -- store
	r.SetOnlyTrackSelected(tr) -- select track so that it can be affected by the action
	ACT(40913) -- Track: Vertical scroll selected tracks into view (Master isn't supported, scrolled with Scroll_Track_To_Top() ) // seems to clear take envelope selection, must be restored outside of the function
	re_store_sel_trks1(t) -- restore
	end

end



function Scroll_Visible_Track_Into_View(tr, tr_y_orig, want_middle, want_arrange)
-- want_middle is boolean to scroll to the middle of the tracklist
-- in Arrange, otherwise to the top
-- want_arrange is boolean to force the function target Arrange tracklist if the Mixer is open
-- relies on re_store_sel_trks1() function

	if not tr then return end

local is_Master = tr == r.GetMasterTrack(0)
local Get = r.GetMediaTrackInfo_Value
local mixer_vis = not want_arrange and r.GetToggleCommandState(40078) == 1 -- View: Toggle mixer visible
local PARAM = mixer_vis and 'B_SHOWINMIXER' or 'B_SHOWINTCP'
local tr_vis = is_Master and r.GetMasterTrackVisibility()&1 == 1 or Get(tr, PARAM) == 1 -- OR 'or r.IsTrackVisible(tr, mixer_vis)'

	if tr_vis then -- only scroll when track is visible that is has been unhidden
		if mixer_vis and not is_Master then -- in the Mixer Master track can't be scrolled to
		r.SetMixerScroll(tr) -- only works if Mixer is visible
		elseif not mixer_vis then -- Arrange context
			if is_Master then
			Scroll_Track_To_Top(tr)
			else
			-- scroll track vertically into view if out of sight
			local tr_h = Get(tr, 'I_TCPH')
			local tr_y = Get(tr, 'I_TCPY')
			local arrange_h, header_h, wnd_h_offset = Get_Arrange_Dims() -- only returns values if extensions are installed
				if tr_h and
				(tr_y_orig and tr_y ~= tr_y_orig -- track position changed
				or tr_y + tr_h/2 < 0) -- fully or mainly out of sight at the top
				or arrange_h and tr_h/2 + tr_y > arrange_h -- fully or mainly out of sight at the bottom
				or not arrange_h -- extensions aren't installed, will be scrolled even if sufficiently within view at the bottom
				then
					if not want_middle then
					Scroll_Track_To_Top(tr) -- SCROLL TO TOP
					else
					-- SCROLL TO THE MIDDLE OF THE TRACKLIST
					local t = re_store_sel_trks1() -- store
					r.SetOnlyTrackSelected(tr) -- select track so that it can be affected by the action
					ACT(40913) -- Track: Vertical scroll selected tracks into view (Master isn't supported, scrolled with Scroll_Track_To_Top() )
					re_store_sel_trks1(t) -- restore
					end
				end
			end
		end
	end

end




function Un_Collapse_All_Tracks_Temporarily(t) -- folders
local GET, SET = r.GetMediaTrackInfo_Value, r.SetMediaTrackInfo_Value
	if not t then -- uncollapse and store
	r.SetMediaTrackInfo_Value
	local t = {}
		for i = 0, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i)
			if GET(tr, 'I_FOLDERDEPTH') == 1 -- parent
			and GET(tr, 'I_FOLDERCOMPACT') == 2 -- tiny children
			then
			SET(tr, 'I_FOLDERCOMPACT', 1) -- small
			t[#t+1] = tr
			end
		end
	return t
	else -- restore
		for _, tr in ipairs(t) do
		SET(tr, 'I_FOLDERCOMPACT', 2) -- tiny children
		end
	end
end


function Create_Buss_Track()
-- select the source track, insert below a new one, create a pre-fader (post-fx) send
-- https://old.reddit.com/r/Reaper/comments/11clcho/is_there_a_shortcut_to_create_a_parallel_track/
local tr = r.GetSelectedTrack(0,0)
	if not tr then r.MB('No selected tracks', 'ERROR', 0) return end
local tr_idx = r.CSurf_TrackToID(tr, false) -- mcpView false
r.InsertTrackAtIndex(tr_idx, true) -- wantDefaults true
local buss_tr = r.CSurf_TrackFromID(tr_idx+1, false) -- mcpView false
r.CreateTrackSend(tr, buss_tr)
r.SetTrackSendInfo_Value(tr, 0, 0, 'I_SENDMODE', 3) -- category 0 (send), sendidx 0, newvalue 3 (pre fader post-fx)
end


function Find_And_Get_New_Tracks(t)
	if not t then
	local t = {}
		for i = 0, r.GetNumTracks()-1 do
		t[r.GetTrack(0,i)] = '' -- dummy field
		end
	return t
	elseif t then
	local t2 = {}
		for i = 0, r.GetNumTracks()-1 do
		local tr = r.GetTrack(0,i)
			if not t[tr] then -- track wasn't stored so is new // some conditions can be added here to only target certain new tracks
			t2[#t2+1] = {tr=tr, idx=i}
			end
		end
	return #t2 > 0 and t2
	end
end
-- USAGE EXAMPLE:
--local t = Find_And_Get_New_Tracks() -- store current tracks
--DO STTUFF
--local t = Find_And_Get_New_Tracks(t) -- get new if any, if none returns nil



function Get_Track_Minimum_Height1() -- may be different from 24 px in certain themes

-- OBSOLETE SINCE 6.76 when TCP zoom was overhauled which rendered actions to in/decrease track height unusable in reascript due to visible UI refresh and extreme slowness, see version 2 below

r.PreventUIRefresh(1)

local uppermost_tr, Y_init

	for i = 0, r.CountTracks(0)-1 do
	uppermost_tr = r.GetTrack(0,i)
	Y_init = r.GetMediaTrackInfo_Value(uppermost_tr, 'I_TCPY')
		if Y_init >= 0 -- store to restore scroll position after getting minimum track height because insertion of new track via API whether at the top or at the bottom makes the tracklist scroll to the end
		then break end
	end

local sel_tr_t = {} -- store currently selected tracks
	for i = 0, r.CountSelectedTracks(0)-1 do
	sel_tr_t[#sel_tr_t+1] = r.GetSelectedTrack(0,i)
	end

-- r.Main_OnCommand(40702, 0) -- Track: Insert new track at end of track list and hide it // creates undo point hence unsuitable
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetOnlyTrackSelected(temp_track)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0) -- hide in Mixer
--r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0) -- hide in Arrange // must appear in TCP otherwise the action 'View: Decrease selected track heights' won't affect it

r.PreventUIRefresh(-1)

-- find minimum height by fully collapsing // must be outside of PreventUIRefresh() because it also prevents change in height
--- PROBABLY THIS CAN BE USED INSTEAD because since 6.76 track heights cannot be changed smoothly with actions
-- r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', 1) -- 0 keeps height the same
-- r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275

local H_min = r.GetMediaTrackInfo_Value(temp_track, 'I_TCPH')
	repeat
	r.Main_OnCommand(41326,0) -- View: Decrease selected track heights // does 8 px // WON'T WORK PROPERLY IN BUILDS 6.76 ONWARDS, THE FUNCTION NEEDS OVERHAUL WITH r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', height) r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275 including scroll restoration routine
	local H = r.GetMediaTrackInfo_Value(temp_track, 'I_TCPH')
		if H < H_min then H_min = H
		elseif H_min == H then break end -- can't be changed to any lesser value
	until H == 0 -- this condition is immaterial since the loop exits earlier once minimum height is reached which is always greater than 0

r.PreventUIRefresh(1)

r.DeleteTrack(temp_track)

	for _, tr in ipairs(sel_tr_t) do -- restore originally selected tracks
	r.SetTrackSelected(tr, true) -- selected true
	end

	repeat -- restore scroll
	r.CSurf_OnScroll(0, -1) -- scroll up because so the tracklist is scrolled down
	until r.GetMediaTrackInfo_Value(uppermost_tr, 'I_TCPY') >= Y_init

r.PreventUIRefresh(-1)

return H_min

end



function Get_Track_Minimum_Height2() -- may be different from 24 px in certain themes
--r.PreventUIRefresh(1) -- prevents getting height so shouldn't be used
-- discussion of the topic https://forum.cockos.com/showthread.php?t=235862
local tr = r.GetTrack(0,0)
local H_orig = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
Msg(H_orig)
r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', 1) -- decrease height // 0 does nothing BUT disables height locked status without clearing the checkmark in the menu https://forum.cockos.com/showthread.php?p=2202082
r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275
local H_min = r.GetMediaTrackInfo_Value(tr, 'I_TCPH') -- store
Msg(H_min)
r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', H_orig) -- restore
r.TrackList_AdjustWindows(true)
--r.PreventUIRefresh(-1)
return H_min
end



function Reverse_Track_Order(tr_t) -- tr_t is a table of track pointers in their current order, must all be adjacent
local ref_idx = r.CSurf_TrackToID(t[#t], false) -- mcpView false // track which immediately follows the last stored track CSurf_TrackToID() returns 1-based index of the current track which equals 0-based index of the next track
local decrement = 0
	for _, tr in ipairs(t) do
	r.SetOnlyTrackSelected(tr)
	r.ReorderSelectedTracks(ref_idx-decrement, makePrevFolder) -- beforeTrackIdx is ref_idx-decrement
	decrement = decrement+1 -- at each cycle decrease beforeTrackIdx because each track will have to be placed before the previous and travel less places
	end

end


function Remove_Track_From_All_Groups(tr, high) -- high is boolean to target groups 33-64
-- the bits are counted as 1,2,4,8,16,32,64,128 etc. up to 4,294,967,295
-- each bit represents one of the first 32 groups with the function GetSetTrackGroupMembership()
-- and one of groups 33-64 with the function GetSetTrackGroupMembershipHigh()
-- to query states in a specific group, a bit which corresponds to such group must be used, e.g. to query states in group 6, the integer 32 must be used because decimal equvalent of a set bit 6 is 32, i.e.
-- 0000 0000 0000 0000 0000 0000 0010 0000 -- 1 occupies 6th place from the right, and 32 is the 6th number in the above list
-- but since for obtaining the corresponding integer 2 (the base) must be raised to a power, the exponent sequence begins with 0 to begin with bit 1 (2^0) and each following exponent is less than the group number by 1, i.e. 2 = 2^1 (group 2), 4 = 2^2 (group 3) ... 32 = 2^5 (group 6) etc
--[[
TOGGLE
local bitfield = r.GetSetTrackGroupMembership(r.GetSelectedTrack(0,0), 'VOLUME_LEAD', 0, 32) -- query group 6
--Msg(state&32==32)
local set = bitfield&32==32 and 0 or 32
r.GetSetTrackGroupMembership(r.GetSelectedTrack(0,0), 'VOLUME_LEAD', 32, set) -- set // setvalue 32 to set, 0 to unset
--OR
--r.GetSetTrackGroupMembership(r.GetSelectedTrack(0,0), 'VOLUME_LEAD', 32, bitfield~32) -- set if not set and vice versa
]]
local GetSet = high and r.GetSetTrackGroupMembershipHigh or r.GetSetTrackGroupMembership
local m, s = '_MASTER', '_SLAVE'
local parm_t = {'VOLUME','VOLUME_VCA','PAN','WIDTH','MUTE','SOLO',
'POLARITY','RECARM','AUTOMODE','VOLUME_REVERSE','PAN_REVERSE',
'WIDTH_REVERSE','VOLUME_VCA_FOLLOW_ISPREFX','NO_LEAD_WHEN_FOLLOW','NO_MASTER_WHEN_SLAVE'} -- 'NO_LEAD_WHEN_FOLLOW' is listed but doesn't work, 'NO_MASTER_WHEN_SLAVE' does
-- https://forum.cockos.com/showthread.php?t=277048
	for i = 0, 32 do -- 32 bits, each represents 1 of the 64 groups
	local bit = 2^i -- calculate the bit representing the group
		for k, parm in ipairs(parm_t) do
			if k <=9 then -- parms which have two roles, master and slave
			-- Master role
			local bitfield = GetSet(tr, parm..m, 0, bit) -- setmask is 0, query, setvalue is the target bit, returns current bitfield
				if bitfield&bit == bit then -- is set // mask is used to query the state
				GetSet(tr, parm..m, bit, bitfield~bit) -- setmask is the target bit, setvalue is 0, created with bitwise NOT
				end
			-- Slave role
			local bitfield = GetSet(tr, parm..s, 0, bit) -- query
				if bitfield&bit == bit then -- is set
				GetSet(tr, parm..s, bit, bitfield~bit) -- unset
				end
			else -- parms which don't have roles and are additional
			local bitfield = GetSet(tr, parm, 0, bit) -- query
				if bitfield&bit == bit then -- is set
				GetSet(tr, parm, bit, bitfield~bit) -- unset
				end
			end
		end
	end

end



function Remove_Track_Roles_From_All_Groups(tr, high, want_master, want_slave)
-- high is boolean to target groups 33-64 // to remove from Slave role comment out Master and additional parameter routines
-- want_master, want_slave are booleans to chose which role to remove, or both
-- the bits are counted as 1,2,4,8,16,32,64,128 etc. up to 4,294,967,295
-- each bit represents one of the first 32 groups with the function GetSetTrackGroupMembership()
-- and one of groups 33-64 with the function GetSetTrackGroupMembershipHigh()
-- to query states in a specific group, a bit which corresponds to such group must be used, e.g. to query states in group 6, the integer 32 must be used because decimal equvalent of a set bit 6 is 32, i.e.
-- 0000 0000 0000 0000 0000 0000 0010 0000 -- 1 occupies 6th place from the right, and 32 is the 6th number in the above list
-- but since for obtaining the corresponding integer, 2 (the base) must be raised to a power, the exponent sequence begins with 0 to begin with bit 1 (2^0) and each following exponent is less than the group number by 1, i.e. 2 = 2^1 (group 2), 4 = 2^2 (group 3) ... 32 = 2^5 (group 6) etc
--[[
TOGGLE
local bitfield = r.GetSetTrackGroupMembership(r.GetSelectedTrack(0,0), 'VOLUME_LEAD', 0, 32) -- query group 6
--Msg(state&32==32)
local set = bitfield&32==32 and 0 or 32
r.GetSetTrackGroupMembership(r.GetSelectedTrack(0,0), 'VOLUME_LEAD', 32, set) -- set// setvalue 32 to set, 0 to unset
--OR
--r.GetSetTrackGroupMembership(r.GetSelectedTrack(0,0), 'VOLUME_LEAD', 32, bitfield~32) -- set if not set and vice versa
]]
	if not want_master and not_want_slave then return end

local GetSet = high and r.GetSetTrackGroupMembershipHigh or r.GetSetTrackGroupMembership
local m, s = '_MASTER', '_SLAVE'
local parm_t = {'VOLUME','VOLUME_VCA','PAN','WIDTH','MUTE','SOLO',
'POLARITY','RECARM','AUTOMODE','VOLUME_REVERSE','PAN_REVERSE',
'WIDTH_REVERSE','VOLUME_VCA_FOLLOW_ISPREFX','NO_LEAD_WHEN_FOLLOW','NO_MASTER_WHEN_SLAVE'} -- 'NO_LEAD_WHEN_FOLLOW' is listed but doesn't work, 'NO_MASTER_WHEN_SLAVE' does
-- https://forum.cockos.com/showthread.php?t=277048
	for i = 0, 32 do -- 32 bits, each represents 1 of the 64 groups
	local bit = 2^i -- calculate the bit representing the group
		for k, parm in ipairs(parm_t) do
			if k <=9 then -- parms which have two roles, master and slave
				if want_master then
				-- Master role
				local bitfield = GetSet(tr, parm..m, 0, bit) -- setmask is 0, query, setvalue is the target bit, returns current bitfield
					if bitfield&bit == bit then -- is set // mask is used to query the state
				GetSet(tr, parm..m, bit, bitfield~bit) -- setmask is the target bit, setvalue is 0, created with bitwise NOT
					end
				end
				if want_slave then
				-- Slave role
				local bitfield = GetSet(tr, parm..s, 0, bit) -- query
					if bitfield&bit == bit then -- is set
					GetSet(tr, parm..s, bit, bitfield~bit) -- unset
					end
				end
			--[[
			else -- parms which don't have roles and are additional
			local bitfield = GetSet(tr, parm, 0, bit) -- query
				if bitfield&bit == bit then -- is set
				GetSet(tr, parm, bit, bitfield~bit) -- unset
				end
			--]]
			end
		end
	end

end



function Is_Track_Group_Disabled1(group_idx) -- see a more efficient version below
-- supported since build 6.53 based on availbility of Main_SaveProjectEx() function
-- group_idx is 1-based group index

-- save temporary project file
-- if project media directory is configured, a media folder will also be created
-- at the temporary path
local sys_temp_folder = os.getenv('TEMP')
local path = sys_temp_folder..sys_temp_folder:match('[\\/]')..'temp.RPP'
r.Main_SaveProjectEx(path, 0) -- options is 0, save but not associate the file with the currently open project tab
local bitfield
	for line in io.lines(path) do
		if line:match('GROUPS_DISABLED') then 
		bitfield  = line:match('%d+')
		break
		elseif line:match('<TRACK ') then return end -- global data have ended
	end
os.remove(path) -- delete temp proj file but the media folder created along with it, if any, will remain
local bit = 2^(group_idx-1)
return (bitfield+0)&bit = bit
end



function Is_Track_Group_Disabled2(group_idx)
-- group_idx is 1-based group index
-- !!! groups 65 - 128 are only supported since 7.43 due to bug
-- https://forum.cockos.com/showthread.php?t=301913
-- idea borrowed from OLSHALOM 
-- https://forum.cockos.com/showpost.php?p=2882448&postcount=1280

local cmd_ID = group_idx < 65 and 42511 or 43278
local group_idx = group_idx < 65 and group_idx or group_idx-64
return r.GetToggleCommandStateEx(0, cmd_ID+group_idx-1) == 0 -- -1 so that command ID of action for group 1 (42511) or 65 (43278) isn't offset and so on for the rest of command IDs

end



function Visible_Selected_Tracks_Exist()

local mixer_vis = r.GetToggleCommandState(40078) == 1 -- View: Toggle mixer visible // when Mixer is open only lists hidden in the Mixer, otherwise hidden in Arrange

	for i = 0, r.CountSelectedTracks2(0, true)-1 do -- wantmaster true
	local tr = r.GetSelectedTrack2(0,i, true) -- wantmaster true
	local master = tr == r.GetMasterTrack(0)
	local master_state = r.GetMasterTrackVisibility()
		if master
		and (not mixer_vis and master_state&1 == 1 -- visible in Arrange
		or mixer_vis and master_state&2 ~= 2) -- or in the Mixer
		or not master and r.IsTrackVisible(tr, mixer_vis) then -- 'not master' cond. is required in case the previous condition is false because IsTrackVisible() always returns true for the Master track and will produce false positive if used alone
		return true
		end
	end

end


function Is_TrackList_Hidden()
-- after double click the the divider between it and the Arrange view
-- or by actions 'View: Toggle show TCP area' 
-- and 'View: Toggle to alternate TCP area width (alternate is zero by default)'
-- supported since 7.16
	for line in io.lines(r.get_ini_file()) do
	local leftpane = line:match('leftpanewid=(%d+)')
		if leftpane then return leftpane == '0' end
	end
end



function Collect_Razor_Edit_Areas() -- relies on Parse_Razor_Edit_Data() function
local t, found = {}
	for i = 0, r.GetNumTracks()-1 do
	local tr = r.GetTrack(0,i)
	local exists, raz_edit_data = r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS', '', false) -- stringNeedBig empty string, setNewValue false // exists return value is useless because it's always true
		if #raz_edit_data > 0 then
		found = 1 -- 1 is enough
		t[tr] = Parse_Razor_Edit_Data(raz_edit_data)
		end
	end
return found and t
end


-- Still note names management is cleaner via chunk,
-- with the functions when note names are shifted blank name placeholders must be
-- left at their old locations which creates junk in the chunk
function Update_Track_MIDI_Note_Names(tr, shift_by, chan)
-- shift_by is either integer (pos or neg) or a table storing old pitch as table index and new pitch as value, both 0-based
-- shift_by as integer is only suitable for linear (uniform) shifts, i.e. all note names are shifted by the same amount
-- otherwise new number of each note is to be stored in a table and then their name assignments updated 1 by 1;
-- chan is either channel number integer in the range of  -1 - 15 (-1 = Omni), or array with channel numbers as values
-- if chan is nil or integer and is negative or greater than 15, defaults to Onmi (-1);
-- When there're note names assigned to both Omni and a specific MIDI channel, e.g.
--[[
1 47 "" 0 47 -------- blank
-1 47 "test 1" 0 47
1 48 "test 1" 0 48
-1 48 "test 2" 0 48
1 49 "test 2" 0 49
1 50 "" 0 50 ------- blank
-1 50 "test 3" 0 50
1 51 "test 3" 0 51
]]
-- note names assigned to a specific channel only appear when this channel is selected in the MIDI Editor channel filter,
-- if any other channel which doesn't have assigned note names is selected in the filter,
-- note names assigned to Omni will appear;
-- note names assigned to both Omni and a specific MIDI channel will appear side by side as long as there're no blank names
-- assigned to such specific channel which correspond to note names assigned to Omni, see chunk excerpt above;
-- under MIDINOTENAMES token in the chunk the note names don't have to be listed in a particular order channel wise;
-- if a note is assigned to Omni (-1), which is always the case in manual note name input,
-- the function GetTrackMIDINoteName(Ex) will get a note name even if it's channel argument integer is other than < 0

-- TrackMIDINoteNameEx(): channel < 0 assigns note name to all channels, pitch 128 assigns name for CC0, pitch 129 for CC1, etc.
-- contrary to the API doc any negative channel value is only recognized in the Get functions
-- Set functions only work successfully with -1, even though returns true if any other negative value is used
-- that must be because -1 and none other value signifies Onmi assignment in the track chunk
-- https://forum.cockos.com/showthread.php?t=250568&page=2#50

	if not tr or (tonumber(shift_by) and tonumber(shift_by) == 0)
	or (type(shift_by) == 'table' and not next(shift_by)) then return end

chan = tonumber(chan)
chan = (not chan or chan and (chan > 15 or chan < 0)) and -1 or chan -- if chan arg is nil, negative or greater than 15, default to Onmi
local cur_names_t = {}

	local function get_note_names(tr, shift_by, chan, cur_names_t, is_table) -- is_table is boolean, refers to chan argument of the main Update_Track_MIDI_Note_Names() function
		for i=0, 127 do
		local name = r.GetTrackMIDINoteNameEx(0, tr, i, chan)
			if name and #name > 0 then -- if no name is assigned the function above returns nil
				if is_table then
				cur_names_t[chan][i] = name -- pitch is stored as 0-based table index because it's likely to not be sequential anyway
				else
				cur_names_t[i] = name -- pitch is stored as 0-based table index
				end
				if tonumber(shift_by) then -- if shift_by is integer delete all
				r.SetTrackMIDINoteNameEx(0, tr, i, chan, '') -- name is empty string to delete current name
				elseif type(shift_by) == 'table' then -- if shift_by is a table only delete those whose note number match note numbers found in the table
					for note_orig_idx, note_new_idx in pairs(shift_by) do -- pairs because the indexing is likely non-sequential
						if note_orig_idx == i then
						r.SetTrackMIDINoteNameEx(0, tr, i, chan, '') -- name is empty string to delete current name
						end
					end
				end
			end
		end

	end

-- Collect named notes
	if tonumber(chan) then -- chan is integer
	chan = math.floor(chan+0.5)
	get_note_names(tr, shift_by, chan, cur_names_t)
	elseif type(chan) == 'table' then
		for _, chanNo in ipairs(chan) do
		cur_names_t[chanNo] = {}
		get_note_names(tr, shift_by, chanNo, cur_names_t, true) -- is_table true
		end
	end

-- Abort if named notes aren't found
local note_names_exist
	if tonumber(chan) and not next(cur_names_t) then return
	elseif type(chan) == 'table' then
		for chan, note_names_t in pairs(cur_names_t) do
			if next(note_names_t) then note_names_exist = 1 end
		end
		if not note_names_exist then return end
	end

	local function set_note_names(tr, shift_by, chan, cur_names_t, is_table) -- is_table is boolean, refers to chan argument of the main Update_Track_MIDI_Note_Names() function
		if tonumber(shift_by) then -- if shift_by is an integer
		local cur_names_t = is_table and cur_names_t[chan] or cur_names_t
			for pitch, name in pairs(cur_names_t) do -- pairs because the indexing is likely non-sequential
			r.SetTrackMIDINoteNameEx(0, tr, pitch+shift_by, chan, name)
			end
		elseif type(shift_by) == 'table' then -- if shift_by is a table storing old note idx as a table index and its new idx as the value, both shall be 0-based
			for note_orig_idx, note_new_idx in pairs(shift_by) do -- pairs because the indexing is likely non-sequential
			local cur_names_t = is_table and cur_names_t[chan] or cur_names_t
				for pitch, name in pairs(cur_names_t) do -- pairs because the indexing is likely non-sequential
					if note_orig_idx == pitch then -- both are 0-based
					r.SetTrackMIDINoteNameEx(0, tr, note_new_idx, chan, name)
					end
				end
			end
		end

	end

-- Update named note assignments
	if tonumber(chan) then -- chan is integer
	set_note_names(tr, shift_by, chan, cur_names_t)
	elseif type(chan) == 'table' then -- chan is a table
		for _, chanNo in ipairs(chan) do
		set_note_names(tr, shift_by, chanNo, cur_names_t, true) -- is_table true
		end
	end

end
-- USE
-- Update_Track_MIDI_Note_Names(tr, {[50]=48,[48]=46}, {0,1}) -- shift_by table, chan array
-- Update_Track_MIDI_Note_Names(tr, 3, 2) -- shift_by 3, chan 2


function Get_Track_MIDI_Note_Names(tr)
local note_names = '<MIDINOTENAMES'
	for note_idx = 0, 127 do -- note range
		for chan_idx = -1, 15 do -- MIDI channel range, -1 is omni
		local name = r.GetTrackMIDINoteNameEx(0, tr, note_idx, chan_idx)
			if name then
			-- enclose inside quotes if contains spaces as per REAPER format
			name = name:match(' ') and '"'..name..'"' or name
			-- concatenate <MIDINOTENAMES block line
			note_names = note_names..'\n'..chan_idx..' '..note_idx..' '..name..' 0 '..note_idx
			-- if name is found under onmi MIDI channel it will also be returned for all 16 channel
			-- so no point in continuing because this is not how the code looks in the track chunk
				if chan_idx == -1 then break end
			end
		end
	end
return note_names ~= '<MIDINOTENAMES' and note_names..'\n>'
end


function GetTrackState(tr)
--[[
&1=folder, &2=selected, &4=has fx enabled, &8=muted, &16=soloed, &32=SIP'd (with &16),
&64=rec armed, &128=rec monitoring on, &256=rec monitoring auto, &512=hide from TCP,
&1024=hide from MCP
]]
local name, flags = r.GetTrackState(tr) -- if not named returns empty string, if master returns 'MASTER'
local t = {name}
	for i = 0, 10 do
	t[#t+1] = flags&2^i == 2^i
	end
-- fx_On is false both if no FX and if FX chain is disabled, doesn't apply to input/monitor FX
-- add new parm after fx_On, fx_exist
table.insert(t, 5, r.TrackFX_GetCount(tr) > 0)
-- solo in place (SIP), only valid if solo is also true
-- it's false if Solo (ignore routing) is enabled
return table.unpack(t)
end
-- USE:
-- local name, folder, sel, fx_On, fx_exist, mute, solo, SIP, rec_arm, rec_mon, rec_mon_auto, TCP_hid, MCP_hid = GetTrackState(tr)



function GetTrackTree(idx, t, depth, menu)
-- the arguments are only used in the recursive loop, start out as nils
-- doesn't account for track visibility
local idx = idx or 0
local t = t or {}
local menu = menu or ''
local tr_cnt = r.CountTracks(0)
local depth_last = depth or 0

	for i = idx, tr_cnt-1 do
		if not t[i+1] then -- ensures that a track isn't stored twice if it was already stored in the folder recursive loop, because the main loop continues from the same track it was exited at into the recursive one // i+1 because table is indexed from 1
		local tr = r.GetTrack(0,i)
		local tr_name = r.GetTrackState(tr)
		tr_name = #tr_name:gsub(' ','') == 0 and 'Track #'..(i+1) or tr_name -- display track number if name is empty
		local tr_depth = r.GetTrackDepth(tr)
			if tr_depth < depth_last and tr_depth > 0 then
			break -- ensures exit in the folder recursive loop once current folder level is exited, while being false in the main loop to be able to store top level tracks whose depth is 0
			else
			t[#t+1] = tr
			local space = tr_depth > 0 and ' ' or ''
			menu = menu..(#menu > 0 and '|' or '')..(INDENT_TYPE):rep(INDENT_LENGTH):rep(tr_depth)..space..tr_name -- INDENT_TYPE (string punctuation mark) and INDENT_LENGTH (string integer) come from user settings
				if r.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH') == 1 then -- folder
				t, menu = GetTrackTree(i+1, t, tr_depth, menu) -- go recursive to scan folders // i+1 to start recursive loop from first child track
					if #t == tr_cnt then break end -- if track list ends with a folder, exit to prevent any higher level loop from continuing
				end
			end
		depth_last = tr_depth -- keep track of last track depth to use as a condition of exiting the recursive loop above
		end
	end

return t, menu

end


function Fixed_Lane_Comping_Enabled(tr)
-- not whether fixed item lanes mode is enabled, for which use
-- r.GetMediaTrackInfo_Value(tr, 'I_FREEMODE') == 2
--[[
FIXEDLANES 9 0 0 0 0 -- Big Lanes (lanes maximized)
FIXEDLANES 9 0 2 0 0 -- lanes collapsed (imploded) down to one visible lane, option 'Fixed item lanes' is disabled
FIXEDLANES token is absent if Small Lanes (lanes minimized)
FIXEDLANES 33 0 0 0 0 -- Small Lanes + Hide Lane Buttons
FIXEDLANES 41 0 0 0 0 -- Big Lanes + Hide Lane Buttons
LANESOLO 8 0 0 0 0 0 0 0 -- absent in track with no lanes, same as r.GetMediaTrackInfo_Value(tr, 'I_FREEMODE') ~= 2
]]
local ret, chunk = r.GetTrackStateChunk(tr, '', false) -- isundo false
return chunk:match('LANEREC [%-%d]+ 0 [%-%d]+') -- in the second string the 2nd flag is -1
end



function Get_Last_Sel_or_Last_Track()
-- only visible tracks are respected

local sel_tr_cnt = r.CountSelectedTracks2(0, true) -- wantmaster true
local master_tr = r.GetMasterTrack(0)
local master_vis = r.GetMasterTrackVisibility()&1 == 1 -- &1 is visibility in TCP
local last_sel_tr = sel_tr_cnt > 0 and r.GetSelectedTrack2(0, sel_tr_cnt-1, true) -- wantmaster true
	
	if last_sel_tr == master_tr and not master_vis -- &1 is visibility in TCP, if last selected is the Master this means it's the only one selected and since it's hidden the loop below won't start
	or last_sel_tr and r.GetMediaTrackInfo_Value(last_sel_tr, 'B_SHOWINTCP') == 0 then -- get last visible selected track
	last_sel_tr = nil -- reset to be able to fall back on the last visible track in the tracklist
		for i=sel_tr_cnt-2,0,-1 do -- -2 to exclude the last selected track which turned out to be hidden
		local tr = r.GetSelectedTrack2(0, i, true)
			if tr ~= last_sel_tr and (tr == master_tr and master_vis
			or tr ~= master_tr and r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1) then
			last_sel_tr = tr break
			end
		end		
	end
	
	if not last_sel_tr then -- if no visible selected track was found, opt for the last visible in the tracklist
		for i=r.GetNumTracks()-1,0,-1 do
		local tr = r.GetTrack(0,i)
			if r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1 then
			last_sel_tr = tr break
			end
		end
	end

local last_sel_tr_idx = 0
	if last_sel_tr then -- if no tracks in the project this var will be nil in which case index 0 will be used for the trig track
	last_sel_tr_idx = r.CSurf_TrackToID(last_sel_tr, false) -- mcpView false // OR r.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER')
	end
	
return last_sel_tr, last_sel_tr_idx -- idx is 1-based and is also index for inserting or moving a track after it to be used as is

end



function In_Visible_Tracks_Exist1(want_visible, want_sel_tracks)
-- want_visible is boolean to evaluate existence of visible tracks
-- otherwise invisible;
-- want_sel_tracks is boolean to only evaluate selected tracks
local state = want_visible and 1 or 0
	for i=0, r.GetNumTracks()-1 do
	local tr = r.GetTrack(0,i)
		if not want_sel_tracks or want_sel_tracks and r.IsTrackSelected(tr) then
			if r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == state then return true end
		end
	end
end


function In_Visible_Tracks_Exist1(want_visible, want_sel_tracks) -- more efficient
-- want_visible is boolean to evaluate existence of visible tracks
-- otherwise invisible;
-- want_sel_tracks is boolean to only evaluate selected tracks
local state = want_visible and 1 or 0
local TrackCount, GetTrack = table.unpack(want_sel_tracks and {r.CountSelectedTracks, r.GetSelectedTrack}
or {r.GetNumTracks, r.GetTrack})
	for i=0, TrackCount(0)-1 do
	local tr = GetTrack(0,i)
		if r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == state then return true end
	end
end



function Get_Last_Touched_Fixed_Item_Lane()
-- the function takes advantage of the fact
-- that with the paste action items are pasted
-- to the last touched lane;
-- last touched lane doesn't change if lane enable
-- button is clicked

	local function re_store_selected_items(t, keep_last_selected)
	-- at the restoration stage when evaluating whether any items 
	-- were saved into the table, 'if next(t) then' statement is used
	-- because the table isn't indexed and 'if #t > 0 then' won't work
		if not t then
		local t = {}
			for i=0, r.CountMediaItems(0)-1 do
			local item = r.GetMediaItem(0,i) 
				if r.IsMediaItemSelected(item) then
				t[item] = '' -- dummy entry
				end
			end
		r.SelectAllMediaItems(0, false) -- selected false // deselect all
		return t
		elseif t and next(t) then
			if not keep_last_selected then
			r.SelectAllMediaItems(0, false) -- selected false // deselect all
			end
			for item in pairs(t) do
			r.SetMediaItemSelected(item, true) -- selected true
			end
		end
	r.UpdateArrange()
	end

	local function act(ID)
	r.Main_OnCommand(ID, 0) -- Options: Trim content behind media items when editing
	end

local trim = r.GetToggleCommandStateEx(0, 41117) == 1 -- Options: Trim content behind media items when editing
	if trim then act(41117) end -- set to off to prevent overwriting items inder the pasted temporary item
	
-- store current item pointers
local t = {}
	for i=0, r.CountMediaItems(0)-1 do
	t[r.GetMediaItem(0,i)] = ''
	end
-- store selected items and clear selection to restore later
-- the selection is cleared so that only the temporary items
-- end up being selected, copied and pasted
local sel_itms = re_store_selected_items()
local tr = r.GetLastTouchedTrack()
-- insert temporary item on the last touched track,
-- by the function the item is always inserted in the last lane
-- so by itself the item is useless
local item = r.AddMediaItemToTrack(tr)
r.SetMediaItemSelected(item, true) -- selected true
act(40698) -- Edit: Copy items
r.DeleteTrackMediaItem(tr, item) -- delete temporary item
act(42398) -- Item: Paste items/tracks // paste copied item to the last touched track
local item = r.GetSelectedMediaItem(0,0) -- the pasted item is exclusively selected
local lane = r.GetMediaItemInfo_Value(item, 'I_FIXEDLANE')
r.DeleteTrackMediaItem(tr, item) -- delete pasted item
re_store_selected_items(sel_itms) -- restore original item selection
	if trim then act(41117) end -- restore On toggle state
return tr, lane
end



function Get_Index_of_Fixed_Item_Lane_Under_Mouse()
local tr, info = r.GetTrackFromPoint(r.GetMousePosition())
return info>>8
end



--================================ T R A C K S  E N D ================================



--===================== T R A C K   S E N D S / R E C E I V E S =======================


function Is_Send_Dest_Track(src_tr, dest_tr)
-- returns true if dest_tr is found
	for snd_idx=0,r.GetTrackNumSends(src_tr, 0)-1 do -- category 0 send
	local tr = r.GetTrackSendInfo_Value(src_tr, 0, snd_idx, 'P_DESTTRACK') -- category 0 send
		if tr == dest_tr then return true
		end
	end
end


-- alternative to Is_Send_Dest_Track(), instead of the src sends, dest receives are evaluated
function Is_Recv_Src_Track(src_tr, dest_tr)
-- returns true if src_tr is found
	for rcv_idx=0,r.GetTrackNumSends(dest_tr, -1)-1 do -- category -1 receive
	local tr = r.GetTrackSendInfo_Value(dest_tr, 0, rcv_idx, 'P_SRCTRACK') -- category -1 receive
		if tr == src_tr then return true
		end
	end
end


function Remove_Track_Receives(tr)
-- single loop isn't enough, if more than 2 receives
-- after the loop GetTrackNumSends() still returns a number greater than 0
-- probably due to sluggish update
-- the result is duplcation of send from the some tracks
-- since original send couldn't be deleted fast enough, before another one was created
	for i=0, r.GetTrackNumSends(tr, -1)-1 do -- category -1 receives
	r.RemoveTrackSend(tr, -1, i) -- category -1 receives
	end
	if r.GetTrackNumSends(tr, -1) > 0 then
	Remove_Track_Receives(tr)
	end
end


function Get_Track_MIDI_Send_Recv_Channels(tr, idx, send)
-- tr arg depends on the send arg, if true track is the send src track
-- otherwise it's send dest track
-- idx is index of send or receive
local category = send and 0 or -1 -- either send or receive
local data = r.GetTrackSendInfo_Value(tr, category, idx, 'I_MIDIFLAGS')
return
data&31, -- src ch
(data>>14)&255, -- OR &0xFF // src bus
data>>5&31, -- dest ch
(data>>22)&255 -- OR &0xFF // dest bus
end
-- USE:
-- src_ch, src_bus, dest_ch, dest_bus = Get_Track_MIDI_Send_Recv_Channels(tr, idx, send)



function Set_Track_MIDI_Send_Recv_Channels(tr, idx, src_ch, src_bus, dest_ch, dest_bus, send)
-- whether send or receive is the target depends on send arg, which is boolean
-- tr arg depends on the send arg, if true track is the send src track
-- otherwise it's send dest track
-- idx is index of send or receive
-- src_ch, dest_ch are 1-based MIDI channel indices, 0 is Omni
-- if either of them is -1 or both are nil MIDI send will be disabled
-- to disable first 3 arguments suffice
-- src_bus, dest_bus are 1-based MIDI bus indices, 0 no bus
	local function Get(tr, category, idx)
	return r.GetTrackSendInfo_Value(tr, category, idx, 'I_MIDIFLAGS')
	end
	local function Set(tr, category, idx, val)
	r.SetTrackSendInfo_Value(tr, category, idx, 'I_MIDIFLAGS', val)
	end
local category = send and 0 or -1 -- either send or receive
-- low 5 bits - src channel (midi_snd&31), next 5 bits - dest channel (midi_snd>>5&31) -- to get
local disable = (src_ch == -1 or dest_ch == -1) or not src_ch and not dest_ch
	if disable then
	-- https://forum.cockos.com/showthread.php?t=287292#2
	Set(tr, category, idx, 31) -- or -1<<5
	return end

local midi_snd = Get(tr, category, idx)

	if src_ch then
		if src_bus then -- must come before channel setting
		-- must be cleared before setting
		-- otherwise set bits are added to the newly set ones
		Set(tr, category, idx, (midi_snd&~(255<<14))|src_bus<<14)
		midi_snd = Get(tr, category, idx) -- for the next stage
		end
	-- midi_snd&~31|src_ch -- 'set new' syntax, before setting must be cleared
	-- otherwise set bits are added to the newly set ones
	-- 31 is low 5 bits mask, e.g. : 0000 0000 0001 1111 (the actual number is 32 bit)
	Set(tr, category, idx, (midi_snd&~31)|src_ch)
	midi_snd = Get(tr, category, idx) -- for the next stage
	end
	if dest_ch then
		if dest_bus then -- must come before channel setting
		Set(tr, category, idx, (midi_snd&~(255<<22))|dest_bus<<22)
		midi_snd = Get(tr, category, idx) -- for the next stage
		end
	-- (midi_snd&~992)|dest_ch<<5 -- 'set new' syntax, before setting must be cleared
	-- 992 is next 5 bits mask: 0000 0011 1110 0000 (the actual number is 32 bit)
	Set(tr, category, idx, (midi_snd&~992)|dest_ch<<5) -- shifting 5 places left ensures that low 5 bits of the src chan are not affected because with bitwise OR when zeros are applied set bits are retained
	--    0000 0000 0001 1111 -- src chan low 5 bits
	-- OR 0000 0011 1110 0000 -- dest chan next 5 bits
	end

end



function Insert_Track_With_One_Regular_And_One_HWOutput_Send(src_ch_st, src_ch_idx, dest_ch_st, dest_ch_idx, hwoutput_st, hwoutput_idx, dest_tr_idx)
-- audio only, MIDI hardware output is quieried/configured with Get/SetMediaTrackInfo_Value() 'I_MIDIHWOUT'
-- src_ch_st/dest_ch_st/hwoutput_st are booleans to select stereo channel/hw output, if false/nil mono will be selected
-- the rest are integers or strings
-- dest_ch_st and dest_ch_idx are only relevant if dest_tr_idx is valid
-- because with hardware send the actual hardware output hwoutput_idx is the destination channel,
-- hwoutput_idx is the index of either stereo or mono hw output, depending on hwoutput_st argument,
-- which must be counted separately, e.g. if there're 4 stereo followed by 8 mono,
-- for the putpose of the function the index of output 9 in the output list is 2,
-- when src_ch_st/dest_ch_st is valid src_ch_idx/dest_ch_idx refer to the left channel of a stereo pair,
-- e.g. 2 means 2/3, 4 means 4/5, 5 means 5/6, 6 means 6/7 etc
-- the track max number of channels must be greater than or equal to
-- the src_ch_idx/dest_ch_idx value so it will be adjusted if smaller,
-- hwoutput_idx or dest_tr_idx can be nil if only one send is needed, either to a hardware output or to a track;
-- virtual loopback output index range for hwoutput_st argument starts at 1-based number 513
-- (officially supported, named Loopback Output in the output list)
-- and 769 (unofficially supported via reaper.ini, named Aux Loopback), IF BOTH TYPES ARE ENABLED,
-- if only one type is enabled, the range start index is 513,
-- but before creating a send using the supplied index the configured number of outputs
-- must be looked up at <Preferences -> Audio -> Virtual loopback audio hardware>
-- and rearoute_loopback key in reaper.ini for each type respectively
-- to ensure that it's within range;
-- the function doesn't support src/dest multi-channel
-- when sending to hardware output the master send may need to be set to off
-- also send mode setting can be added with r.GetTrackSendInfo_Value(tr, snd_cat, snd_idx, 'I_SENDMODE', int);
-- creation of sends to hardware outputs is simpler with ReaInsert plugin
-- but one plugin is only able to send to 1 stereo hardware output, or 2 mono
-- https://forum.cockos.com/showthread.php?t=220361
-- https://old.reddit.com/r/Reaper/comments/1hsul96/new_track_outputs_default_is_it_possible/


-- errors need Error_Tooltip() to be displayed
	if not hwoutput_idx and not dest_tr_idx then -- error
	-- 'send destination wasn\'t specified'
	return
	elseif dest_tr_idx and dest_tr_idx > r.GetNumTracks() then -- error
--	'destination track index is out of range'
		if not hwoutput_idx then return end -- no point to continue
	elseif hwoutput_idx then
	local mono_hw_output_cnt = r.GetNumAudioOutputs() -- only counts mono physical outputs
	local st_hw_output_cnt = mono_hw_output_cnt/2 -- for every 2 mono outputs 1 stereo should be implied and accounted for because it's listed in the outputs menu
	local err = hw_output_cnt == 0 and 'no hardware outputs'
	or (not hwoutput_st and hwoutput_idx > mono_hw_output_cnt
	or hwoutput_st and hwoutput_idx > st_hw_output_cnt) and 'destination hardware output index is out of range'
	-- if hwoutput_idx exceeds the number of available outputs REAPER creates ghost output which is listed
	-- in the HW output pop-up menu, which is not what we need
	-- same with non-existent loopback outputs
		if err and not dest_tr_idx then return end -- no point to continue
	end

-- r.GetNumAudioOutputs() and r.GetOutputChannelName(channelIndex) -- only count and list mono physical outputs ignoring virtual loopback outputs
-- local retval, name = r.GetTrackSendName(tr, send_idx, '') -- for stereo hardware outputs only returns left channel name
-- local retval, name = r.GetTrackReceiveName(tr, recv_idx, '')


-- insert after the last touched or last selected or the last
local tr = r.GetLastTouchedTrack() or r.GetSelectedTrack(0, r.CountSelectedTracks(0)-1) or r.GetTrack(0,r.GetNumTracks()-1)
local idx = tr and r.CSurf_TrackToID(tr, false) or 0 -- mpcView false
r.InsertTrackAtIndex(idx , true) -- wantDefaults true
local tr = r.GetTrack(0,idx)

-- the src track max number of channels must be greater than or equal to
-- the src_ch_idx value so that the send isn't created from void
-- doing this before calculating final src_ch_idx because if mono if will be added 1024
local tr_ch_cnt = r.GetMediaTrackInfo_Value(tr, 'I_NCHAN')
	if tr_ch_cnt < (src_ch_idx + (src_ch_st and 1 or 0)) then -- adding 1 for stereo pair because src_ch_idx var only refers to the left channel
	tr_ch_cnt = (src_ch_idx + (src_ch_st and 1 or 0)) - tr_ch_cnt + tr_ch_cnt -- increase track channel count
	r.SetMediaTrackInfo_Value(tr, 'I_NCHAN', tr_ch_cnt&1 == 0 and tr_ch_cnt or tr_ch_cnt+1) -- if odd number make even because as per the API doc the value must be even
	end

local src_ch_idx = src_ch_st and src_ch_idx-1 or src_ch_idx-1+1024

-- When a send is just created it's automatically set to stereo 1/2, both for the src and for the dest channel

local CreateSnd, SetSnd = r.CreateTrackSend, r.SetTrackSendInfo_Value

	if dest_tr_idx then
	local dest_tr = r.GetTrack(0, dest_tr_idx-1)
	local snd_idx = CreateSnd(tr, dest_tr) -- if dest_tr were nil a hardware send would be created
	-- the dest track max number of channels must be greater than or equal to
	-- the dest_ch_idx value so that the send isn't created into void
	-- doing this before calculating final dest_ch_idx because if mono if will be added 1024
	local tr_ch_cnt = r.GetMediaTrackInfo_Value(dest_tr, 'I_NCHAN')
		if dest_ch_st and tr_ch_cnt < (dest_ch_st + (dest_ch_idx and 1 or 0)) then
		tr_ch_cnt = (dest_ch_idx + (dest_ch_st and 1 or 0)) - tr_ch_cnt + tr_ch_cnt -- increase track channel count
		r.SetMediaTrackInfo_Value(tr, 'I_NCHAN', tr_ch_cnt&1 == 0 and tr_ch_cnt or tr_ch_cnt+1) -- if odd number make even because as per the API doc the value must be even
		end
	local dest_ch_idx = dest_ch_st and dest_ch_idx-1 or dest_ch_idx-1+1024 -- not needed for hardware outputs
	SetSnd(tr, 0, snd_idx, 'I_SRCCHAN', src_ch_idx) -- 0 track send category
	SetSnd(tr, 0, snd_idx, 'I_DSTCHAN', dest_ch_idx)
	end

	if hwoutput_idx then
--	r.SetMediaTrackInfo_Value(tr, 'B_MAINSEND', 0) -- turn off master/parent send
	local snd_idx = CreateSnd(tr)
	SetSnd(tr, 1, snd_idx, 'I_SRCCHAN', src_ch_idx) -- 1 hardware output category
	-- hardware output indices convention see at https://github.com/ReaTeam/Doc/blob/master/State%20Chunk%20Definitions
	-- token HWOUT
	-- can be set with SetTrackSendInfo_Value() as well
	-- which is preferable if applying the function to an existing track
	-- to avoid messing with chunk and having to employ custom Get/SetObjChunk functions
	local hwoutput_idx = hwoutput_st and hwoutput_idx-1 or hwoutput_idx-1+1024 -- mono channel index starts from 1024
	local ret, chunk = r.GetTrackStateChunk(tr, '', false)
	chunk = chunk:gsub('HWOUT %d', 'HWOUT '..hwoutput_idx)
	r.SetTrackStateChunk(tr, chunk, false)
	end

end



function Collect_Snd_Data(tr) -- dest track and channels // blueprint of dealing with sends/receives
local t = {}
	for snd_idx = 0, r.GetTrackNumSends(tr, 0)-1 do -- 0 is sends
	local dest_tr = r.GetTrackSendInfo_Value(tr, 0, snd_idx, 'P_DESTTRACK') -- 0 is sends
	local src_ch = r.GetTrackSendInfo_Value(tr, 0, snd_idx, 'I_SRCCHAN') -- 0 is sends
-- St channel count: 0 = 1/2, 1 = 2/3, 2 = 3/4, 3 = 4/5 etc
-- To get stereo source both ch indices, 1-based, add 1 and 2 to the return value, e.g. 0+1, 0+2 = 1/2 (index 0), 3+1, 3+2 = 4/5 (index 3)
-- Mono channel count starts from 1024, to evaluate if channel is mono do src_ch&1024==1024
-- To get mono source regular ch index, 0-based, subtract 1024 from the return value (src_ch), e.g. 1024-1024 = 0 (ch 1), 1025-1024 = 1 (ch 2) etc.
	local mono = src_ch&1024 == 1024
	t[dest_tr] = mono and {(src_ch-1024)+1} or {src_ch+1, src_ch+2} -- saving 1-based channel indices
	end
return t
end



function GetSetTrackSendInfo_Value(tr, cat, send_idx, param, val) -- param is a string, last two args are for setting
	if not param or not val then
	local t = {B_MUTE = 0, B_PHASE = 0, B_MONO = 0, D_VOL = 0, D_PAN = 0, D_PANLAW = 0, I_SENDMODE = 0, I_AUTOMODE = 0, I_SRCCHAN = 0, I_DSTCHAN = 0, I_MIDIFLAGS = 0, P_DESTTRACK = 0, P_SRCTRACK = 0, ['P_ENV:<VOLENV'] = 0, ['P_ENV:<PANENV'] = 0, ['P_ENV:<MUTEENV'] = 0}
		for k in pairs(t) do
		t[k] = reaper.GetTrackSendInfo_Value(tr, cat, send_idx, k)
		end
	return t
	elseif param and val return reaper.SetTrackSendInfo_Value(tr, cat, send_idx, param, val)
	end
end


function Get_Set_Track_Snd_Rec_Src_Dest_Channel(tr, send, hw_output, idx, src_ch_idx, src_ch_mode, dest_ch_idx, dest_ch_mode)
-- only deals with audio routings, MIDI hardware output is quieried/configured 
-- with Get/SetMediaTrackInfo_Value() 'I_MIDIHWOUT';
-- send is boolean, if false/nil receive is addressed
-- hw_output is boolean, if valid send arg is ignored
-- idx is send/receive index
-- src_ch_idx/dest_ch_idx 0-based channel or hardware output index
-- src_ch_mode - false/nil/0 stereo, 1 mono, 2 - 4 channel multi-channel, 3 - 6 channel multi0channel, etc.
-- DEST CHANNEL MODE IS DETERMINED BY src_ch_mode
-- because send requires the same number of channels at source and at the destination
-- it's not allowed to route different channel counts, i.e. stereo/mono to multichannel, 
-- or one multichannel count to another, BUT IT'S ALLOWED TO MIX TO MONO AT THE DESTINATION
-- src_ch_idx, src_ch_mode, dest_ch_idx, dest_ch_mode must be ommitted at Get stage, they're irrelevant
-- if src_ch_mode is false/nil/0 (stereo) src_ch_idx/dest_ch_idx refer to the index of the left channel,
-- dest_ch_mode at Set stage is only needed to signal mixing to mono at the destination
-- if ommitted, it will be the same as src_ch_mode;
-- if src_ch_mode is an even number above 0 (multichannel), then src_ch_idx/dest_ch_idx
-- refer to the 0-based index of the first channel in a multichannel routing;
-- 0-based channel index: when the mode is mono it's straghtforward
-- in stereo mode index is left channel, index+1 is right channel
-- in multichan mode index is the first channel, index-1+mode*2 is last channel;
-- at Set stage besides other arguments only src_ch_idx/src_ch_mode or dest_ch_idx/dest_ch_mode can be specified
-- if only source or destination channel needs setting;
-- virtual loopback output index range for dest_ch_idx argument starts at 0-based number 512
-- (officially supported, named Loopback Output in the output list)
-- and 768 (unofficially supported via reaper.ini key rearoute_loopback=, 
-- named 'Aux Loopback' in the hw outputs list, 512 channels since build 6.69), 
-- PROVIDED BOTH TYPES ARE ENABLED,
-- if only one type is enabled, the range start index is 512,
-- but before creating a send using the supplied index the configured number of outputs
-- must be looked up at <Preferences -> Audio -> Virtual loopback audio hardware>
-- and rearoute_loopback key in reaper.ini for each type respectively
-- to ensure that it's within range;
-- when sending to hardware output the master send may need to be set to off
-- also send mode setting can be added with r.SetTrackSendInfo_Value(tr, snd_cat, snd_idx, 'I_SENDMODE', int);
-- creation of sends to hardware outputs is simpler with ReaInsert plugin
-- but one plugin is only able to send to 1 stereo hardware output, or 2 mono


-- local retval, name = r.GetTrackSendName(tr, send_idx) -- for stereo hardware outputs only returns left channel name which can be complemented using dest_ch_mode value, i.e. if stereo then add name with channel number incremented by 1, e.g. 'Output 1 / Output 2'; for hw outputs 0-based send_idx is in the range of 0 - r.GetTrackNumSends(tr, 1)-1 (category 1 hw outputs), for track sends r.GetTrackNumSends(tr, 1) - r.GetTrackNumSends(tr, 0)-1 (category 0 track sends)
-- local retval, name = r.GetTrackReceiveName(tr, recv_idx)

local routing_type = hw_output and 1 or send and 0 or -1 -- -1 receive
local GetSnd, SetSnd, GetTrackInfo, SetTrackInfo = r.GetTrackSendInfo_Value, r.SetTrackSendInfo_Value, r.GetMediaTrackInfo_Value, r.SetMediaTrackInfo_Value

	if not src_ch_idx and not dest_ch_idx then -- GET
	local bitfield = GetSnd(tr, routing_type, idx, 'I_SRCCHAN')
	local src_mode = bitfield>>10&0x3ffff -- shifting heigher 10 bits, applying 10 bit mask
	local src_ch_idx = bitfield&0x3ffff - src_mode*1024 -- bit-masking lower 10 bits, 0-based ch index increases by 1024 with each mode hence the subtraction
	local bitfield = GetSnd(tr, routing_type, idx, 'I_DSTCHAN')
--[[ this only works for HW outputs
	local dest_mode = bitfield>>10&0x3ffff
	local dest_ch_idx = bitfield&0x3ffff - dest_mode*1024
	]]
	local dest_mode = bitfield&1024==1024 and 1 or src_mode -- dest channel mode is always the same as the source's unless mono
	local dest_ch_idx = dest_mode == 1 and bitfield&0x3ffff-1024 or bitfield&0x3ffff -- subtracting 1024 if mono
	local is_rearoute = bitfield&512==512 -- seems useless for operations with sends, so just for info
	return src_mode, src_ch_idx, dest_mode, dest_ch_idx, is_reatoute -- dest_ch_idx 512+ is rearoute loopback output 0-based index
	else -- SET
		if src_ch_idx then
		local src_ch_mode = src_ch_mode or 0 -- if false/nil then stereo
		-- the src track max number of channels must be greater than or equal to
		-- the src_ch_idx value so that the send isn't created from void
		local tr_ch_cnt = GetTrackInfo(tr, 'I_NCHAN')
			if tr_ch_cnt < (src_ch_idx+1 + (src_ch_mode == 0 and 1 or src_ch_mode > 1 and src_ch_mode*2 or 0)) then -- src_ch_idx+1 to match 1-based track channel count because src_ch_idx var is 0-based // adding 1 to src_ch_idx for stereo pair (src_ch_mode 0) because src_ch_idx var only refers to the left channel, and double the src channel mode number for multichannel because as per the API doc 2 = 4, 3 = 6 etc.
			tr_ch_cnt = (src_ch_idx+1 + (src_ch_mode == 0 and 1 or src_ch_mode > 1 and src_ch_mode*2 or 0)) + tr_ch_cnt -- increase track channel count
			SetTrackInfo(tr, 'I_NCHAN', tr_ch_cnt&1 == 0 and tr_ch_cnt or tr_ch_cnt+1) -- if odd number make even because as per the API doc the channel count value must be even
			end
		local bitfield = (src_ch_mode << 10) | src_ch_idx -- mode number shifted 10 bits leftwards + 0-based channel index, if mode is stereo or multichannel, index of the left channel // if channel index exceeds the count of enabled channels the src ch readout isn't updated whle the I/O dialogue is open, to have it update either close and reopen or toggle REAPER window unfocused and focused
		SetSnd(tr, routing_type, idx, 'I_SRCCHAN', bitfield)
		end
		if dest_ch_idx then
		local dest_ch_mode = dest_ch_mode and 1 or src_ch_mode -- if not explicitly provided to signal mono routing (integer 1), use src_ch_mode as required by REAPER design
			if not hw_output then
			-- the dest track max number of channels must be greater than or equal to
			-- the dest_ch_idx value so that the send isn't created into void
			local dest_tr = GetSnd(tr, routing_type, idx, 'P_DESTTRACK') -- returns pointer, not index
			local tr_ch_cnt = GetTrackInfo(dest_tr, 'I_NCHAN')
				if tr_ch_cnt < (dest_ch_idx+1 + (dest_ch_mode == 0 and 1 or dest_ch_mode > 1 and dest_ch_mode*2 or 0)) then -- dest_ch_idx+1 to match 1-based track channel count because dest_ch_idx var is 0-based // adding 1 to dest_ch_idx for stereo pair (dest_ch_mode 0) because dest_ch_idx var only refers to the left channel, and double the src channel mode number for multichannel because as per the API doc 2 = 4, 3 = 6 etc.
				tr_ch_cnt = (dest_ch_idx+1 + (dest_ch_mode == 0 and 1 or dest_ch_mode > 1 and dest_ch_mode*2 or 0)) + tr_ch_cnt -- increase track channel count
				SetTrackInfo(dest_tr, 'I_NCHAN', tr_ch_cnt&1 == 0 and tr_ch_cnt or tr_ch_cnt+1) -- if odd number make even because as per the API doc the channel count value must be even
				end
			elseif dest_ch_idx < 512 then -- not rearoute loopback output
			local mono_hw_output_cnt = r.GetNumAudioOutputs() -- only counts mono physical outputs, ignored rearoute loopback outputs
			local st_hw_output_cnt = mono_hw_output_cnt/2 -- for every 2 mono outputs 1 stereo should be implied and accounted for because it's listed in the outputs menu
			-- errors need Error_Tooltip() to be displayed
			local err = hw_output_cnt == 0 and 'no hardware outputs'
			or (dest_ch_mode == 1 and dest_ch_idx > mono_hw_output_cnt -- mode 1 is mono
			or dest_ch_mode == 0 and dest_ch_idx > st_hw_output_cnt) -- mode 0 is stereo
			and 'destination hardware output index is out of range'
			-- if dest_ch_idx exceeds the number of available outputs REAPER creates ghost output which is listed
			-- in the HW output pop-up menu, which is not what we need
			-- same with non-existent loopback outputs;
			-- to ensure that loopback dest_ch_idx value doesn't exceed the loopback outputs count
			-- IF BOTH OFFICIAL AND UNOFFICIAL TYPES ARE ENABLED
			-- for indices 512 - 767 the value at Preferences -> Audio -> Virtual loopback audio hardware
			-- must be looked up which is value of loopback_size= key in reaper.ini,
			-- for indices 768 - 1023 it's the value of rearoute_loopback= key in reaper.ini,
			-- if either one is enabled the range of indices is 512 - 1023,
			-- that many (512) outputs are supported since 6.69
			end
			if hw_output then
		--	SetTrackInfo(tr, 'B_MAINSEND', 0) -- turn off master/parent send
			end
		local bitfield = (dest_ch_mode << 10) | dest_ch_idx
		SetSnd(tr, routing_type, idx, 'I_DSTCHAN', bitfield)
		end
	end

end



function Audio_Send_Exists(snd_type, src_tr, dest_tr, send_mode, snd_src_ch, snd_src_ch_mode, snd_dest_ch, snd_dest_ch_mode, loopback_mode)
-- snd_type < 0 receves, 0 track sends, > 0 hardware sends
-- if snd_type > 0 (hw outputs), dest_tr arg is irrelevant;
-- snd_dest_ch_mode arg must be valid only if evaluating mono routing at the destination (integer 1)
-- in all other cases it's identical to snd_src_ch_mode;
-- channel modes, i.e. snd_src_ch_mode and snd_dest_ch_mode: 0 - stereo, 1 mono, 2 - 4 channels, 3 - 6 channels etc.
-- 0-based channel index: when the mode is mono it's straghtforward
-- in stereo mode index is left channel, index+1 is right channel
-- in multichan mode index is the first channel, index-1+mode*2 is last channel
-- snd_src_ch and snd_dest_ch args are 0-based channel indices, 
-- for stereo routing only the left channel index
-- for multichannel routing only the lowest channel index;
-- loopback_mode arg is optional, 1 if evaluating rearoute loopback output channels
-- officially supported since REAPER v7, whose count starts from 0-based index of 512, 
-- or 2 if evaluating rearoute loopback channels supported unofficially 
-- in earlier builds via reaper.ini rearoute_loopback= key, since 6.69 supports 512 channels, 
-- whose count starts at 0-based index of 768 IF BOTH TYPES ARE ENABLED,
-- alternatively, to address rearoute outputs enabled via reaper.ini 
-- loopback_mode 1 could be used but snd_dest_ch index must start from 256,
-- i.e. 256 - 0, 257 - 1 etc.,
-- only applies to snd_dest_ch arg,
-- if loopback_mode arg is supplied snd_dest_ch index
-- args doesn't need adjustment, value 0 will be mapped to 512 for loopback_mode 1
-- or to 768 for loopback_mode 2, etc.

	local function is_ch_within_range(input_ch_idx, input_ch_mode, ch_idx, ch_mode)
	-- looking if a channel is already present in a send/receive
	-- input_ch_idx is a channel index which is evaluated
	-- ch_idx, ch_mode are props of the send/receive against which input_ch_idx is evaluated
	local key = function(ch_mode) return ch_mode > 1 and -1 or ch_mode end -- creating universal table key for all multichannel mode values for noth input and evaluated mode args
	local hi_t = {[0]=function(ch_idx)return ch_idx+1 end,[1]=function(ch_idx)return ch_idx end,
	[-1]=function(ch_idx,ch_mode)return ch_idx-1+ch_mode*2 end} -- using functions to be able to use the table for both types of arguments
	return input_ch_idx and input_ch_idx >= ch_idx -- lower channel in the range
	and hi_t[key(input_ch_mode)](input_ch_idx, input_ch_mode) <= hi_t[key(ch_mode)](ch_idx, ch_mode) -- upper channel in the range
	end

local snd_dest_ch_mode = snd_dest_ch_mode and 1 or snd_src_ch_mode -- if not explicitly provided, to signify mono routing (integer 1) use snd_src_ch_mode as required by REAPER design
local snd_dest_ch =  snd_dest_ch + (loopback_mode == 1 and 512 or loopback_mode == 2 and 768 or 0)
local SendInfo = r.GetTrackSendInfo_Value

	for i=0, r.GetTrackNumSends(src_tr, snd_type)-1 do
		if SendInfo(src_tr, 0, i, 'P_DESTTRACK') == dest_tr or snd_type > 0 then -- send to the dest_tr already exists or hardware output
		-- Evaluate properties, whether identical
--		local send_mode_cur = SendInfo(src_tr, snd_type, i, 'I_SENDMODE') -- irrelevant
		local bitfield = SendInfo(src_tr, snd_type, i, 'I_SRCCHAN')
		local snd_src_ch_mode_cur = bitfield>>10&0x3ffff -- shifting heigher 10 bits, applying 10 bit mask
		local snd_src_ch_cur = bitfield&0x3ffff - snd_src_ch_mode_cur*1024 -- bit-masking lower 10 bits, 0-based ch index increases by 1024 with each mode hence the subtraction
		local bitfield = SendInfo(src_tr, snd_type, i, 'I_DSTCHAN')
	--[[ this only works for HW outputs
		local snd_dest_ch_mode_cur = bitfield>>10&0x3ffff
		local snd_dest_ch_cur = bitfield&0x3ffff - snd_dest_ch_mode_cur*1024
		]]
		local snd_dest_ch_mode_cur = bitfield&1024==1024 and 1 or snd_src_ch_mode_cur -- dest channel mode is always the same as the source's unless mono
		local snd_dest_ch_cur = snd_dest_ch_mode_cur == 1 and bitfield&0x3ffff-1024 or bitfield&0x3ffff -- subtracting 1024 if mono
			if is_ch_within_range(snd_src_ch, snd_src_ch_mode, snd_src_ch_cur, snd_src_ch_mode_cur)
			and is_ch_within_range(snd_dest_ch, snd_dest_ch_mode, snd_dest_ch_cur, snd_dest_ch_mode_cur)
			then return true -- if the evaluated src and dest channels both feature in any send routing, such send is considered existing, no point in duplicating the signal by creating another send featuring these channels
			end
		end
	end

end



--===================== T R A C K   S E N D S / R E C E I V E S  E N D =======================


--================================== F O L D E R S ====================================


function Store_Children_And_Grandchildren(tr)
	if r.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH') == 0 then return end -- not a folder parent track
local depth = r.GetTrackDepth(tr)
local t = {}
	for i = r.CSurf_TrackToID(tr, false), r.CountTracks(0)-1 do -- mcpView false // starting loop from the 1st child
	local chld_tr = r.GetTrack(0, i)	
	--	if r.GetParentTrack(chld_tr) == tr then -- wrong since will be false for grandchildren in nested folders
		if r.GetTrackDepth(chld_tr) > depth then
		t[#t+1] = chld_tr
		else return t
		end
	end
end


function get_track_children_and_grandchildren(tr)
local st_idx = r.CSurf_TrackToID(tr, false) -- mcpView false // starting loop from the 1st child
local depth = r.GetTrackDepth(tr)
return function()
	local chld_tr = r.GetTrack(0,st_idx)
		if if chld_tr and r.GetTrackDepth(chld_tr) > depth then
		st_idx=st_idx+1
		return chld_tr
		end
	end
end
--[[ USE:
for child in get_track_children_and_grandchildren(tr) do

end
]]



function Store_Children(tr)
	if r.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH') == 0 then return end -- not a folder parent track
local t = {}
	for i = r.CSurf_TrackToID(tr, false), r.CountTracks(0)-1 do -- mcpView false // starting loop from the 1st child
	local chld_tr = r.GetTrack(0, i)
		if r.GetParentTrack(chld_tr) == tr then
		t[#t+1] = chld_tr
		else return t
		end
	end
end


function Are_All_Children_Selected(tr)
	for i = r.CSurf_TrackToID(tr, false), r.CountTracks(0)-1 do -- starting loop from the 1st child
	local chld_tr = r.GetTrack(0, i)
	local is_parent = r.GetParentTrack(chld_tr) == tr
		if is_parent and not r.IsTrackSelected(chld_tr) then
		return false
		elseif not is_parent then break
		end
	end
return true
end


function Count_And_Store_Siblings(chld_tr)
local parent_tr = r.GetParentTrack(chld_tr)
local t = {}
local cnt = 0
	for i = r.CSurf_TrackToID(parent_tr, false), r.CountTracks(0)-1 do -- starting the loop from the 1st child of the parent track // include the source child track in the table
	local sibl_tr = r.GetTrack(0, i)
		if r.GetParentTrack(sibl_tr) == parent_tr then
		t[#t+1] = sibl_tr
		cnt = cnt+1
		else return t, cnt
	end
end


function Are_All_Siblings_Selected(chld_tr)
local parent_tr = r.GetParentTrack(chld_tr)
-- starting loop from the 1st sibling
	for i = r.CSurf_TrackToID(parent_tr, false), r.CountTracks(0)-1 do -- starting the loop from the 1st child of the parent track
	local sibl_tr = r.GetTrack(0, i)
	local same_parent = r.GetParentTrack(sibl_tr) == parent_tr
		if same_parent and not r.IsTrackSelected(sibl_tr)
		then return false
		elseif not same_parent then break
		end
	end
return true
end


function Get_Folder_First_Track(child_idx) -- either idx or pointer
-- VISIBILITY IS NOT EVALUATED
local child_idx = tonumber(child_idx) or r.CSurf_TrackToID(child_idx, false)-1 -- mcpView false
local parent
	if child_idx then
	local i = child_idx
		repeat
		parent = r.GetTrack(0,i)
		i = i - 1
		until r.GetTrackDepth(parent) == 0 -- topmost parent found
	return parent
	end
end


function Get_Folder_Last_Track(child_idx) -- either idx or pointer
-- VISIBILITY IS NOT EVALUATED
local child_idx = tonumber(child_idx) or r.CSurf_TrackToID(child_idx, false)-1 -- mcpView false
	if child_idx then
		for i = child_idx, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i)
			if r.GetTrackDepth(tr) == 0 -- first track outside of the folder
			or not tr -- the last child was the last in the tracklist
			then return r.GetTrack(0,i-1) end
		end
	end
end


function Get_All_Track_Parents1(start_tr) -- see more efficient versions below
-- VISIBILITY IS NOT EVALUATED
local parent = r.GetParentTrack(start_tr)
local parents_t = {}
	for i = r.CSurf_TrackToID(start_tr, false)-2, 0, -1 do -- mcpView false // -2 to start from immediatedly preceding track
	local tr = r.GetTrack(0,i)
		if tr == parent then -- and itself has a parent
		parents_t[#parents_t+1] = tr
		parent = r.GetParentTrack(tr)
		end
	end
return parents_t
end


function Get_All_Track_Parents2(start_tr)
-- VISIBILITY IS NOT EVALUATED
local parent = r.GetParentTrack(start_tr)
local parents_t = {}	
	repeat
	parent = r.GetParentTrack(parent)
		if parent then
		parents_t[#parents_t+1] = parent
		end
	until not parent	
return parents_t
end



function get_track_parents(parent)
	return function()
	parent = r.GetParentTrack(parent) -- assigning to a global value (or upvalue passed as the argument) is crucial to make it work so that the var is constantly updated during the loop, returning r.GetParentTrack(parent) directly won't work because the var isn't updated, the var won't be accessible outside of the loop
	return parent
	end
end
--[[ USE:
	for parent in get_track_parents(r.GetSelectedTrack(0,0)) do	

	end
]]



function Get_Topmost_Uncollapsed_TCP_Parent(child_idx, child_tr, t) -- t is a table
-- VISIBILITY IS NOT EVALUATED
	for i = child_idx, 0, -1 do -- in reverse
	local tr = r.GetTrack(0,i)
		if tr == r.GetParentTrack(child_tr) then
			if r.GetMediaTrackInfo_Value(tr, 'I_FOLDERCOMPACT') == 2 -- parent track is fully collapsed // only valid for folders
			then
			t[#t+1] = tr
			end
		get_topmost_uncollapsed_parent(i, tr, t) -- repeat using current parent as a child to find its own parent, if any, and so on
		end
	end
return t, t[#t] -- return table to use for uncollapsing and the topmost uncollapsed track which ends up being the very last
end


function get_last_uncollapsed_parent(child_idx, child_tr, t, tcp)
-- t is a table; tcp is boolean to activate either the tcp or the mcp routine // last uncollapsed means that the parent itself isn't collapsed inside the folder it belongs to, unless it's the topmost level parent of the entire folder which cannot be collapsed, this is equal to the parent of the 1st/topmost (sub)folder whose child tracks are collapsed // equals parent of the 1st folder whose tracks are collapsed
-- relies on GetObjChunk2() for MCP routine, i.e. when tcp arg is nil

	if r.GetTrackDepth(child_tr) == 0 then return child_tr end -- if target track isn't a child

		if tcp then -- get in the TCP and store all parents of the found track
			for i = child_idx, 0, -1 do -- in reverse
			local tr = r.GetTrack(0,i)
				if tr == r.GetParentTrack(child_tr) then
					if r.GetMediaTrackInfo_Value(tr, 'I_FOLDERCOMPACT') == 2 -- parent track whose child tracks are fully collapsed // only valid for folders
					then
					t[#t+1] = tr
					end
				get_last_uncollapsed_parent(i, tr, t, tcp) -- go recursive, using current parent as a child to find its own parent, if any, and so on
				end
			end
			if #t > 0 then return t[#t], t -- return last uncollapsed track which ends up being the very last and the table to use for uncollapsing
			else return child_tr end -- if no parent track of a collapsed folder was found

		else -- search the leftmost uncollapsed parent in the MCP, if any, to select it if the context is not TCP (not TCP cond is applied outside of the function

		-- Collect all parents of the track to then find the last (rightmost) uncollapsed if any // uncollapsed means that the parent itself isn't collapsed inside the folder it belongs to, unless it's the topmost level parent of the entire folder which cannot be collapsed, this is equal to the parent of the leftmost (sub)folder whose child tracks are collapsed
		local parent = r.GetParentTrack(child_tr)
			for i = child_idx, 0, -1 do -- in reverse
			local tr = r.GetTrack(0,i)
				if tr == parent then
				t[#t+1] = tr -- in the table the leftmost track is at the end
				parent = r.GetParentTrack(tr)
				end
			end
			-- Find the leftmost collapsed parent, if any
			for i = #t, 1, -1 do -- in reverse since parent tracks were stored from right to left; if the table is empty the loop won't start
			local tr = t[i]
			local ret, chunk = GetObjChunk2(tr)
				if ret ~= 'err_mess' -- if parent track chunk is larger than 4.194303 Mb and no SWS extension to handle that to find out if it's collapsed
				and chunk:match('BUSCOMP %d (%d)') == '1' then -- child tracks are collapsed
				return tr -- as soon as parent with collapsed children is found; since the parents are traversed from the left, first parent with collapsed children means that lower level parents are all collapsed and are unsuitable for selection
				end
			end
		return child_tr -- if no parent track of a collapsed folder was found
		end

end


function Find_Last_Uncollapsed_MCP_Parent(targ_tr, GetTrackChunk)
-- returns parent of a collapsed folder (if any) of the target track in order to scroll to it, because child track of a collapsed folder can't be scrolled to
-- r.GetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER') doesn't indicate if it's under collapsed folder, only when it's explicitly hidden, r.CSurf_TrackToID(tr, true) -- mcpView true does returning in this case -1
-- last uncollapsed means that the parent itself isn't collapsed inside the folder it belongs to, unless it's the topmost level parent of the entire folder which cannot be collapsed, this is equal to the parent of the 1st/topmost (sub)folder whose child tracks are collapsed // equals parent of the 1st folder whose tracks are collapsed

	if r.GetTrackDepth(targ_tr) == 0 then return targ_tr end -- if target track isn't a child

-- Collect all parents of the track to then find the last (rightmost) uncollapsed if any // uncollapsed means that the parent itself isn't collapsed inside the folder it belongs to, unless it's the topmost level parent of the entire folder which cannot be collapsed, this is equal to the parent of the leftmost (sub)folder whose child tracks are collapsed
local targ_tr_idx = r.CSurf_TrackToID(targ_tr, false)-1 -- mcpView false
local parent = r.GetParentTrack(targ_tr)
local parents_t = {}
--------------------------------
	for i = targ_tr_idx-1, 0, -1 do -- in reverse // targ_tr_idx-1 to start from previous track
	local tr = r.GetTrack(0,i)
		if tr == parent then
		t[#t+1] = tr -- in the table the leftmost track is at the end
		parent = r.GetParentTrack(tr)
		end
	end
--[[ OR
local parent = r.GetParentTrack(targ_tr)
local parents_t = {}
local i = targ_tr_idx-1 -- start from previous track
	repeat
	local tr = r.GetTrack(0,i)
		if tr == parent then parents_t[#parents_t+1] = tr // OR = parent // in the table the leftmost track is at the end
		parent = r.GetParentTrack(tr)
		end
	i = i - 1
	until r.GetTrackDepth(parent) == 0 -- uppermost parent found
--]]---------------------------

	-- Find the leftmost collapsed parent, if any
	for i = #parents_t, 1, -1 do -- in reverse since parent tracks were stored from right to left; if the table is empty the loop won't start
	local parent_tr = parents_t[i]
	local ret, chunk = GetTrackChunk(parent_tr)
		if ret ~= 'err_mess' -- if parent track chunk is larger than 4.194303 Mb and no SWS extension to handle that to find out if it's collapsed
		and chunk:match('BUSCOMP %d (%d)') == '1' then -- child tracks are collapsed
		return parent_tr -- as soon as parent with collapsed children is found; since the parents are traversed from the left, first parent with collapsed children means that lower level parents are all collapsed and are unsuitable for selection
		end
	end

return targ_tr -- if no parent track of a collapsed folder was found return original track

end


function Get_Parent_Of_MCP_First_Uncollapsed_Folder1(tr) -- basically the same as the above Find_Last_Uncollapsed_MCP_Parent() with added visibility evaluation, stems from the same script
-- tr argument is a pointer of a track to scroll to, if it happens to be a child of a collapsed folder
-- return its parent track or first (from the left) uncollapsed parent of a nested folder
-- (which itself is a parent of collapsed folder), otherwise return tr
-- relies on GetObjChunk() function

-- Collect all parents of the found track to then find the first (leftmost) uncollapsed if any
local parent = r.GetParentTrack(tr)
local parents_t = {}
	for i = r.CSurf_TrackToID(tr, false)-2, 0, -1 do -- in reverse // mcpView false, allows to get it even if it's hidden in a collapsed folder // -2 to start from immediatedly preceding track as CSurf_TrackToID returns 1-based track index which is greater than the 0-based by 1
	local tr = r.GetTrack(0,i)
		if tr == parent
		and r.IsTrackVisible(tr, true) -- mixer true // VISIBILITY IS EVALUATED
		then -- and itself has a parent
		parents_t[#parents_t+1] = tr -- in the table the leftmost track is at the end
		end
	parent = r.GetParentTrack(tr)
	end
	-- Find the leftmost uncollapsed parent, if any ((un)collapsing Mixer tracks must be done via chunk which is too cumbersome and isn't worth the effort for this script)
	for i = #parents_t, 1, -1 do -- in reverse since parent tracks were stored from right to left; if the table is empty the loop won't start
	local parent_tr = parents_t[i]
	local ret, chunk = GetObjChunk(parent_tr)
		if ret ~= 'err_mess' -- if parent track chunk is larger than 4.194303 Mb and no SWS extension to handle that to find out if it's collapsed
		and chunk:match('BUSCOMP %d (%d)') == '1' then -- collapsed
		return parent_tr -- as soon as uncollapsed parent is found
		end
	end

return tr

end


function Get_Parent_Of_MCP_First_Uncollapsed_Folder2(tr) -- NO CHUNK IS REQUIRED, ONLY FOR TRACKS 100% VISIBLE IN THE MIXER AS when mcpView is true CSurf_TrackToID() returns -1 for both hidden completely and hidden in a collapsed folder in the Mixer
local parent = r.GetParentTrack(tr)
local tr_vis = r.IsTrackVisible(tr, true) -- mixer true
	if parent and tr_vis
	and r.CSurf_TrackToID(tr, true) == -1 -- mcpView true // the function doesn't return index if track is in a collapsed folder in the Mixer
	then return Get_Parent_Of_MCP_First_Uncollapsed_Folder2(parent) -- recursive
	elseif parent and tr_vis and r.IsTrackVisible(parent, true) -- mixer true
	then return parent
	end
end


function Is_Collapsed_MCP_Folder(tr)
-- relies on Get_All_Descendants() function, see below
-- tr is a parent track pointer
-- can only reliably identify a collapsed MCP folder if at least one child track is not explicitly hidden, for 100% reliability 'BUSCOMP' values from the chunk must be used

local decs_t = Get_All_Descendants(tr)
local depth = r.GetTrackDepth(tr)

	if #decs_t > 0 then
		for k, tr in ipairs(decs_t) do
			if r.GetTrackDepth(tr) - depth == 1 -- since Get_All_Descendants() returns ALL descendants, here only evaluating direct descendants, i.e. children (exactly 1 depth level below the parent), ignoring grandchildren because these have their own parent which may be collapsed
			and r.IsTrackVisible(tr, true) -- mixer true // visible
			and r.CSurf_TrackToID(tr, true) == -1 -- mixer true // doesn't return index if hidden explicitly or simply being located inside a collapsed folder, hence is preceded IsTrackVisible() to exclude truly hidden tracks
			then -- is a child of a collapsed MCP folder
			return true
			end
		end
	end

end



function Get_All_Descendants(...)
-- arg is either parent track idx or parent track pointer

local arg = {...}
local tr_idx, tr
	if #arg > 0 then
		if tonumber(arg[1]) then tr_idx = arg[1]
		elseif r.ValidatePtr(arg[1], 'MediaTrack*') then tr = arg[1]
		else return
		end
	else return
	end

	if not tr then tr = r.CSurf_TrackFromID(tr_idx, false) end -- mcpView false
	if not tr_idx then tr_idx = r.CSurf_TrackToID(tr, false)-1 end -- mcpView false

local desc_t = {}

	if r.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH') == 1 then -- parent
	local depth = r.GetTrackDepth(tr)
		for i = tr_idx+1, r.CountTracks(0)-1 do -- starting from the next track
		local tr = r.GetTrack(0,i)
		local tr_depth = r.GetTrackDepth(tr)
			if tr_depth > depth then
			desc_t[#desc_t+1] = tr
			elseif tr_depth <= depth then break
			end
		end
	end

return desc_t

end



function Get_All_Relatives(arg)
-- parent and siblings, NOT descendants
-- arg is either track idx or track pointer

	if not arg then return end

local tr_idx, tr

	if tonumber(arg) then tr_idx = arg
	elseif r.ValidatePtr(arg, 'MediaTrack*') then tr = arg
	else return
	end

	if not tr then tr = r.CSurf_TrackFromID(tr_idx, false) end -- mcpView false

local relative_t = {}

local parent = r.GetParentTrack(tr)
	if parent then -- source track is a child
	local idx = r.CSurf_TrackToID(parent, false) -- mcpView false // returns 1-based index which will correspond to the 1st child track
	local depth = r.GetTrackDepth(tr)
	relative_t[1] = parent
		for i = idx, r.CountTracks(0)-1 do -- starting from the 1st child track, the source track will be added during the loop
		local tr = r.GetTrack(0,i)
		local tr_depth = r.GetTrackDepth(tr)
			if tr_depth == depth then
			relative_t[#relative_t+1] = tr
			elseif tr_depth < depth then break -- one level above the source track
			end
		end
	end

return relative_t

end




function Is_TCP_MCP_Collapsed(tr_chunk)
-- TCP collapse state is direct value because there're 3: 0=not collapsed, 1=collapsed medium, 2=collapsed small
-- MCP collapse state is either true or false
	return tr_chunk:match('BUSCOMP (%d)'), tr_chunk:match('BUSCOMP %d (%d)') == '1'
-- to only return true or false for TCP as well:
-- return (match:tr_chunk('BUSCOMP (%d)') == '1' or tr_chunk:match('BUSCOMP (%d)') == '2'), tr_chunk:match('BUSCOMP %d (%d)') == '1'
end



function Dismantle_FolderOrSubfolder(parent_tr) -- nested folders are supported

	if r.GetMediaTrackInfo_Value(parent_tr, 'I_FOLDERDEPTH') ~= 1 then return end -- the track isn't folder parent

local first_child_idx = r.CSurf_TrackToID(parent_tr, false) -- mcpView false // returns 1-based index which corresponds to 0-based index of the 1st child
local child_t = {}
--[[VERSION 1 WORKS
	for i = first_child_idx, r.CountTracks(0)-1 do -- collect children to dismantle in reverse since it's easier
	local tr = r.GetTrack(0,i)
	local depth = r.GetTrackDepth(tr)
	local child_state = r.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH')
		if depth > 0 and (child_state == 1 or child_state < 0 and not r.GetParentTrack(parent_tr)) then -- parent of a children subfoler or the last track in the folder or a subfolder to prevent leaving the last track in the folder marked as such but only if the entire folder is being dismantled which is conditioned with not r.GetParentTrack(parent_tr), because otherwise dismantling a subfolder will bring track outside of the folder into it
		child_t[#child_t+1] = tr
		elseif depth == 0 then break -- first found track outside of the folder // OR not r.GetParentTrack(tr)
		end
	end
--]]
--[-[VERSION 2 WORKS
	for i = first_child_idx, r.CountTracks(0)-1 do -- collect children to dismantle in reverse since it's easier
	local tr = r.GetTrack(0,i)
		if r.GetTrackDepth(tr) > 0 and (r.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH') > 0 or not r.GetParentTrack(parent_tr)) then -- if not the entire folder is being dismantled which is conditioned with not r.GetParentTrack(parent_tr), exclude the last track in the folder because otherwise dismantling only the very last subfolder will bring track outside of the folder into it
		child_t[#child_t+1] = tr
		else break
		end
	end
--]]
	for i = #child_t, 1, -1 do
	r.SetMediaTrackInfo_Value(child_t[i], 'I_FOLDERDEPTH', 0)
	end
r.SetMediaTrackInfo_Value(parent_tr, 'I_FOLDERDEPTH', 0) -- parent must be dismantled as well but if it's dismantled first the depth of the 1st child track becomes 0, it won't satisfy the condition r.GetTrackDepth(tr) > 0 and the children loop won't be able to continue since it's supposed to break at first found track with 0 depth meaning the 1st found track outside of the folder
end



function Track_Is_Vis_And_Child_Of_Collapsed_MCP_Folder(tr)
return r.GetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER') == 1 -- track isn't hidden in the Mixer // same as r.IsTrackVisible(tr, true) -- mixer true
and r.CSurf_TrackToID(tr, true) == -1 -- mcpView true // when the track is inside a collaped MCP folder the function doesn't return its index // r.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER') doesn't work this way so not suitable
end


function Track_Is_Vis_And_Child_Of_Collapsed_TCP_Folder(tr)
return r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1 -- track isn't hidden in the TCP // same as r.IsTrackVisible(tr, false) -- mixer false
and r.GetParentTrack(tr) and r.GetMediaTrackInfo_Value(r.GetParentTrack(tr), 'I_FOLDERCOMPACT') == 2
end



function Track_Is_Child_Of_Collapsed_Folder(tr, wantMixer) -- wantMixer is boolean // visibility is not evaluated
	local function get_first_collapsed_tcp_fldr(tr) -- for Arrange
	local parent = r.GetParentTrack(tr)
		if parent and r.GetMediaTrackInfo_Value(parent, 'I_FOLDERCOMPACT') == 2 -- tiny children
		then return true
		elseif parent then
		return get_first_collapsed_tcp_fldr(parent) -- recursive
		end
	end
return wantMixer and r.CSurf_TrackToID(tr, true) == -1 -- mcpView true // when the track is inside a collapsed MCP folder the function doesn't return its index // r.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER') doesn't work this way so not suitable
or not wantMixer and get_first_collapsed_tcp_fldr(tr) -- in Arrange
end


function Track_Is_Vis_And_Child_Of_Collapsed_Folder(tr, wantMixer) -- wantMixer is boolean // visibility IS evaluated

	local function get_first_collapsed_tcp_fldr(tr) -- for Arrange
	--	if r.IsTrackVisible(tr, false) then -- mixer false // not needed here, evaluated in the main routine
		local parent = r.GetParentTrack(tr)
			if parent and r.GetMediaTrackInfo_Value(parent, 'I_FOLDERCOMPACT') == 2 -- tiny children
			then return true
			elseif parent then
			return get_first_collapsed_tcp_fldr(parent) -- recursive
			end
	--	end
	end

local parm = wantMixer and 'B_SHOWINMIXER' or 'B_SHOWINTCP'
return r.GetMediaTrackInfo_Value(tr, parm) == 1 -- track isn't hidden in Arrange/Mixer // same as r.IsTrackVisible(tr, false/true) -- mixer false/true
and (wantMixer and r.CSurf_TrackToID(tr, true) == -1 -- mcpView true // when the track is inside a collaped MCP folder the function doesn't return its index // r.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER') doesn't work this way so not suitable
not wantMixer and get_first_collapsed_tcp_fldr(tr)) -- in Arrange

end



function All_Parent_Folders_Uncollapsed(tr)
local parent = r.GetParentTrack(tr)
	if parent then
		if r.GetMediaTrackInfo_Value(parent, 'I_FOLDERCOMPACT') > 0
		then return false
		else return All_Parent_Folders_Uncollapsed(parent)
		end
	end
return true
end


function Create_Folder_For_Adjacent_Tracks(t, parent_name, want_many)
-- single depth folder
-- t is an array which either already contains tracks
-- or contains their start and end 1-based indices, e.g. {5,10}
-- allows creating folder for 1 track only if want_many is false

	if not t then return end

	if not r.ValidatePtr(t[1],'MediaTrack*') then -- the table doesn't contain tracks
	local st, fin = t[1],t[2]
		if not (tonumber(st) or tonumber(fin)) or st > fin then return end
	t = {}
		for i=st, fin do
		t[#t+1] = r.GetTrack(0,i-1)
		end
	end

	if #t == 0 or want_many and #t == 1 then return end -- no stored tracks or a single track

r.PreventUIRefresh(-1)

local idx = r.CSurf_TrackToID(t[1], false)-1 -- mpcView false
r.InsertTrackAtIndex(idx, true) -- wantDefaults true // create folder parent tr imediately above the first stored track
local parent_tr = r.GetTrack(0,idx)
r.SetMediaTrackInfo_Value(parent_tr, 'I_FOLDERDEPTH', 1) -- set depth to parent
r.GetSetMediaTrackInfo_String(parent_tr, 'P_NAME', parent_name, true) -- setNewValue true
r.SetMediaTrackInfo_Value(t[#t], 'I_FOLDERDEPTH', -1) -- close the folder at the last track

r.PreventUIRefresh(-1)

end


function Create_Folder_For_Selected_Tracks(t, parent_name, want_many)
-- single depth folder
-- t is an array of tracks
-- can be nil in which case currently selected tracks will be targeted
-- and ordered sequentially inside the folder
-- if t already contains tracks they must be arranged
-- in a particular order so it's recreated inside the folder;
-- allows creating folder for 1 track only if want_many is false

local t = t or {}
	if #t == 0 then -- the table doesn't contain tracks
		for i=0, r.CountSelectedTracks(0)-1 do
		t[#t+1] = r.GetSelectedTrack(0,i)
		end
	end

	if #t == 0 or want_many and #t == 1 then return end -- no stored tracks or a single track

r.PreventUIRefresh(1)

local idx = r.CSurf_TrackToID(t[1], false)-1 -- mpcView false
r.InsertTrackAtIndex(idx, true) -- wantDefaults true // create folder parent tr imediately above the first stored track
local parent_tr = r.GetTrack(0,idx)
r.SetMediaTrackInfo_Value(parent_tr, 'I_FOLDERDEPTH', 1) -- set depth to parent
r.GetSetMediaTrackInfo_String(parent_tr, 'P_NAME', parent_name, true) -- setNewValue true

local sel_tr = r.GetSelectedTrack(0,0)	-- store 1st selected track // ideally all selected should be (re)stored

	for k, tr in ipairs(t) do
	idx = idx+1
	r.SetOnlyTrackSelected(tr)
	r.ReorderSelectedTracks(idx, 0) -- makePrevFolder 0 no change in depth
	end

r.SetMediaTrackInfo_Value(t[#t], 'I_FOLDERDEPTH', -1) -- close the folder at the last track

local restore = sel_tr and r.SetOnlyTrackSelected(sel_tr) -- restore

r.PreventUIRefresh(-1)

-- seems to work fine without it, but just in case
r.TrackList_AdjustWindows(r.GetToggleCommandStateEx(0,41146) == 0) -- Mixer: Toggle autoarrange // isMinor arg depends on the setting to only auto-arrange in the Mixer when the setting is enabled

end


function Move_Outside_Tracks_Into_Existing_Folder(t, parent_tr)
-- single depth folder
-- t is an array of tracks which includes folder tracks and outside tracks
-- which must be arranged in a particular order so it's recreated inside the folder;
-- parent_tr is the target folder parent track

-- look for index of the first track in the target folder
local idx

	for k, tr in ipairs(t) do
	local parent = r.GetParentTrack(tr)
		if parent == parent_tr then
		idx = r.CSurf_TrackToID(tr, false)-1 -- mpcView false, index of the first Notes track
		break end
	end

local sel_tr = r.GetSelectedTrack(0,0)	-- store 1st selected track // ideally all selected should be (re)stored

r.PreventUIRefresh(1)

	for k, tr in ipairs(t) do
		if r.GetParentTrack(tr) ~= parent_tr then -- only move tracks whose parent track is different, i.e. outside of the folder or in the subfolder
		r.SetOnlyTrackSelected(tr)
		r.ReorderSelectedTracks(idx, 0) -- makePrevFolder 0 no change in depth
		idx = r.CSurf_TrackToID(tr, false)-1 -- mpcView false, get new index of the moved track to move the next above it // this accommodates cases when tracks are brought in from both downstream and upstream of the track list, with tracks from upstream simple incremention of the idx var won't work because when they're moved the count of preceding tracks changes
		end
	end

r.SetMediaTrackInfo_Value(t[#t], 'I_FOLDERDEPTH', -1) -- close the folder at the last track

local restore = sel_tr and r.SetOnlyTrackSelected(sel_tr) -- restore

r.PreventUIRefresh(-1)

-- seems to work fine without it, but just in case
r.TrackList_AdjustWindows(r.GetToggleCommandStateEx(0,41146) == 0) -- Mixer: Toggle autoarrange // isMinor arg depends on the setting to only auto-arrange in the Mixer when the setting is enabled

end


function Sort_Tracks_Inside_Folder(t)
-- single depth folder
-- t is an array of tracks which includes folder tracks
-- which must be arranged in a particular order so it's restored inside the folder;

-- look for index of the first track in the target folder
local idx

	for k, tr in ipairs(t) do
	local parent = r.GetParentTrack(tr)
		if parent == parent_tr then
		local idx_ = r.CSurf_TrackToID(tr, false)-1 -- mpcView false, index of the first Notes track
		idx = idx and idx_ < idx and idx_ or idx -- looking for smallest index, that is the closest to the parent track, because if tracks come in sorted the first found won't necessarily have the smallest index
		end
	end

local sel_tr = r.GetSelectedTrack(0,0)	-- store 1st selected track // ideally all selected should be (re)stored

r.PreventUIRefresh(1)

	for k, tr in ipairs(t) do
-- OR in reverse
--	for i=#t,1,-1 do
	local tr = props.tr
--	OR in reverse
--	local tr = t[i]
	r.SetOnlyTrackSelected(tr)
	r.ReorderSelectedTracks(idx, 0) -- makePrevFolder 0 no change in depth
	r.SetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH', 0) -- set depth to regular until all tracks are sorted // must be placed here because if the folder isn't followed by a regular track, more than one child track may end up being set to folder last track mode, not sure how this happens if the function precedes the re-ordering, perhaps REAPER sets the last track mode automatically after order changing because it does this when tracks order is changed by dragging
	idx = idx+1
--	OR in reverse
--	idx = r.CSurf_TrackToID(tr, false)-1 -- mpcView false, get new index of the moved track to move the next above it
	end

r.SetMediaTrackInfo_Value(t[#t], 'I_FOLDERDEPTH', -1) -- close the folder at the last track

local restore = sel_tr and r.SetOnlyTrackSelected(sel_tr) -- restore

r.PreventUIRefresh(-1)

-- seems to work fine without it, but just in case
r.TrackList_AdjustWindows(r.GetToggleCommandStateEx(0,41146) == 0) -- Mixer: Toggle autoarrange // isMinor arg depends on the setting to only auto-arrange in the Mixer when the setting is enabled

end



--================================ F O L D E R S  E N D =================================


--================================ E N V E L O P E S ==================================

--[[
-- using Envelope manager or envelope window
-- track envelopes can remain selected even when hidden
-- selection of track fx envelopes is cleared once they become hidden
-- both take and take fx envelopes can remain selected when hidden
-- however take fx envelope selection is cleared when take envelopes state changes:
-- from hidden to visible but not vice versa, from active to inactive AND vice versa
]]


function Is_Valid_Envelope(env, want_state)
-- want_state is boolean to get additional properties: visible, bypassed, armed and GUID
-- envelope GUID isn't necessarily unique, their GUIDs are retained in track and take copies
-- in REAPER builds prior to 7.06 CountTrack/TakeEnvelopes() lists ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
-- SUCH VALIDATION WORKS FOR VISIBLE TRACK BUILT-IN ENVELOPES EVEN WITHOUT USER CREATED POINTS
-- FOR HIDDEN TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS
-- HIDDEN PROGRAMMATICALLY IT'S FALSE
-- THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE
-- i.e. 'not env_chunk:match('\nPT %d')'
-- BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER 
-- THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, 
-- FUNCTIONS DO RETURN THEIR POINTER,
-- HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES BECOME INVALID
-- an open envelope by default has 1 point at position 0
-- in track built-in envelopes without user created points 
-- such point is ignored when the envelope is closed
-- while with user created points it's included 
-- in the total point count regardless of the visibility
-- without user created points track enevelope chunk doesn't list any points;
-- THIS ALSO WORKS FOR TRACK FX ENVELOPES AND ALL TAKE ENVELOPES BOTH VISIBLE AND HIDDEN
-- because their point count doesn't depend on visibility
-- and presence of user created points;
-- IN BUILDS OLDER THAN 7.38 ENVELOPE GUIDs WEREN'T NECESSARILY UNIQUE
-- IN TRACK/TAKE COPIES CREATED BY COPY/PASTE ENVELOPES KEPT THE THE SAME 
-- GUIDs AS IN THE SOURCE TRACK/TAKE, 
-- IN TAKES THEY ONLY WOULD UPDATE IF COPIED BY CTRL + MOUSE DRAG
-- bug report https://forum.cockos.com/showthread.php?t=300279
-- IN THOSE BUILDS IF UNIQUENESS IS REQUIRED FOR EVALUATION THE POINTER 
-- MUST BE USED INSTEAD

	local function get_hidden_built_in_track_env(env)
	local env_name_t = {
	-- regular track
	Volume='', ['Volume (Pre-FX)']='', ['Trim Volume']='', ['Send Volume']='', 
	Pan='', ['Pan (Pre-FX)']='', ['Pan (Left)']='', ['Pan (Right)']='', ['Send Pan']='', 
	Width='', ['Width (Pre-FX)']='', Mute='', ['Send Mute']='',
	 -- master track
	Playrate='', --['Tempo map']='' -- excluding tempo map envelope because when inactive and has no points at all it cannot be opened even though the chunk is there
	}
	local ret, env_name = r.GetEnvelopeName(env)
		if env_name_t[env_name] then
		local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			if not chunk:match('\nPT %d') then return env end
		end
	end

local build = tonumber(r.GetAppVersion():match('[%d%.]+'))

	if env and build < 7.06
	and r.CountEnvelopePoints(env) > 0
	or env or get_hidden_built_in_track_env(env) then
		if not want_state then return env
		else
			if build < 7.19 then
			local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			return env, chunk:match('\nVIS 1'), chunk:match('\nACT 1'), chunk:match('\nARM 1'),
			chunk:match('{.-}') -- OR chunk:match('EGUID (.-)\n')
			else
			local t = {'VISIBLE', 'ACTIVE', 'ARM'}
				for k, attr in ipairs(t) do
				local retval, state = r.GetSetEnvelopeInfo_String(env, attr, '', false) -- setNewValue false
				t[k] = state == '1'
				end
			return table.unpack(t)
			end
		end
	end
end
-- USE:
-- local env, vis, bypassed, armed, GUID = Is_Valid_Envelope(env, want_state)


function Is_Env_Visible(env)
	local function get_hidden_built_in_track_env(env)
	local env_name_t = {
	-- regular track
	Volume='', ['Volume (Pre-FX)']='', ['Trim Volume']='', ['Send Volume']='', 
	Pan='', ['Pan (Pre-FX)']='', ['Pan (Left)']='', ['Pan (Right)']='', ['Send Pan']='', 
	Width='', ['Width (Pre-FX)']='', Mute='', ['Send Mute']='',
	 -- master track
	Playrate='', --['Tempo map']='' -- excluding tempo map envelope because when inactive and has no points at all it cannot be opened even though the chunk is there
	}
	local ret, env_name = r.GetEnvelopeName(env)
		if env_name_t[env_name] then
		local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			if not chunk:match('\nPT %d') then return env end
		end
	end
	if r.CountEnvelopePoints(env) > 0 or get_hidden_built_in_track_env(env) then -- validation of fx envelopes in REAPER builds prior to 7.06 // SUCH VALIDATION IS ALWAYS TRUE FOR VALID TRACK FX ENVELOPES AND ALL TAKE ENVELOPES REGARDLESS OF VISIBILITY, FOR VISIBLE BUILT-IN TRACK ENVELOPES REGARDLESS OF PRESENCE OF USER CREATED POINTS AND FOR HIDDEN BUILT-IN TRACK ENVELOPES WHICH HAVE USER CREATED POINTS; FOR TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS HIDDEN PROGRAMMATICALLY IT'S FALSE THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE i.e. 'not env_chunk:match('\nPT %d')', BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, FUNCTIONS DO RETURN THEIR POINTER, HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES MAY BECOME INVALID
	local retval, chunk, is_vis
			if tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.19 then
			retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			else
			retval, is_vis = r.GetSetEnvelopeInfo_String(env, 'VISIBLE', '', false) -- setNewValue false
			end
	return is_vis and is_vis == '1' or env_chunk and env_chunk:match('\nVIS 1 ')
	end
end


function Set_Env_In_Visible(env, vis) -- can be expanded to armed and active
-- vis is boolean, if true the envelope will be set to visible
-- if false env will be set to hidden

	local function get_hidden_built_in_track_env(env)
	local env_name_t = {
	-- regular track
	Volume='', ['Volume (Pre-FX)']='', ['Trim Volume']='', ['Send Volume']='', 
	Pan='', ['Pan (Pre-FX)']='', ['Pan (Left)']='', ['Pan (Right)']='', ['Send Pan']='', 
	Width='', ['Width (Pre-FX)']='', Mute='', ['Send Mute']='',
	 -- master track
	Playrate='', --['Tempo map']='' -- excluding tempo map envelope because when inactive and has no points at all it cannot be opened even though the chunk is there
	}
	local ret, env_name = r.GetEnvelopeName(env)
		if env_name_t[env_name] then
		local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			if not chunk:match('\nPT %d') then return env end
		end
	end
	
	if not env then return end
	if r.CountEnvelopePoints(env) > 0 or get_hidden_built_in_track_env(env) then -- validation of fx envelopes in REAPER builds prior to 7.06 // SUCH VALIDATION IS ALWAYS TRUE FOR VALID TRACK FX ENVELOPES AND ALL TAKE ENVELOPES REGARDLESS OF VISIBILITY, FOR VISIBLE BUILT-IN TRACK ENVELOPES REGARDLESS OF PRESENCE OF USER CREATED POINTS AND FOR HIDDEN BUILT-IN TRACK ENVELOPES WHICH HAVE USER CREATED POINTS; FOR TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS HIDDEN PROGRAMMATICALLY IT'S FALSE THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE i.e. 'not env_chunk:match('\nPT %d')', BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, FUNCTIONS DO RETURN THEIR POINTER, HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES MAY BECOME INVALID
	-- Changes produced with the function GetSetEnvelopeInfo_String() in builds 7.19+ aren't registered so undo point cannot be created, bug report https://forum.cockos.com/showthread.php?t=303814, and setting must be done via a chunk, or with actions 
	-- Envelope: Toggle hide/display selected envelope 40884
	-- Envelope: Toggle bypass for selected envelope 40883
	-- Envelope: Toggle record arm for selected envelope 40863
	-- that require selecting envelope which may not be the optimal solution
	-- this bug should not prevent change from being registered when it includes 
	-- data besides envelope attributes
		if tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.19 then
		local retval, env_chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
		local state = vis and 0 or 1 -- invert the value for the sake of evaluation
			if env_chunk:match('\nVIS '..state) then -- only change if differs
			env_chunk = env_chunk:gsub('\nVIS %d', '\nVIS '..(state~1)) -- ~1 bitwise NOT, flip 0 to 1 or 1 to 0
			r.SetEnvelopeStateChunk(env, env_chunk, false) -- isundo false
			end
		else
		r.GetSetEnvelopeInfo_String(env, 'VISIBLE', vis and '1' or '0', true) -- setNewValue true
		end
	end
end



function Is_Env_Bypassed(env)
	local function get_hidden_built_in_track_env(env)
	local env_name_t = {
	-- regular track
	Volume='', ['Volume (Pre-FX)']='', ['Trim Volume']='', ['Send Volume']='', 
	Pan='', ['Pan (Pre-FX)']='', ['Pan (Left)']='', ['Pan (Right)']='', ['Send Pan']='', 
	Width='', ['Width (Pre-FX)']='', Mute='', ['Send Mute']='',
	 -- master track
	Playrate='', --['Tempo map']='' -- excluding tempo map envelope because when inactive and has no points at all it cannot be opened even though the chunk is there
	}
	local ret, env_name = r.GetEnvelopeName(env)
		if env_name_t[env_name] then
		local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			if not chunk:match('\nPT %d') then return env end
		end
	end
	if r.CountEnvelopePoints(env) > 0 or get_hidden_built_in_track_env(env) then -- validation of fx envelopes, in REAPER builds before 7.06 fx param envelopes are valid if param modulation was enabled at least once without any actual envelope, such ghost envelopes don't have points // SUCH VALIDATION IS ALWAYS TRUE FOR VALID TRACK FX ENVELOPES AND ALL TAKE ENVELOPES REGARDLESS OF VISIBILITY, FOR VISIBLE BUILT-IN TRACK ENVELOPES REGARDLESS OF PRESENCE OF USER CREATED POINTS AND FOR HIDDEN BUILT-IN TRACK ENVELOPES WHICH HAVE USER CREATED POINTS; FOR TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS HIDDEN PROGRAMMATICALLY IT'S FALSE THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE i.e. 'not env_chunk:match('\nPT %d')', BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, FUNCTIONS DO RETURN THEIR POINTER, HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES MAY BECOME INVALID
	local retval, env_chunk, is_bypassed
		if tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.19 then
		retval, env_chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false		
		else
		retval, is_bypassed = r.GetSetEnvelopeInfo_String(env, 'ACTIVE', '', false) -- setNewValue false
		end
	return is_bypassed and is_bypassed == '0' or env_chunk and env_chunk:match('\nACT 0 ')	
	end
end



function Get_Env_State(env, attr)
-- attr is integer:
-- 1 - visibility, 2 - bypass state, 3 - armed state
local old_build = tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.19
local attr = attr == 1 and (old_build and 'VIS' or 'VISIBLE') or attr == 2 and (old_build and 'ACT' or 'ACTIVE')
or attr == 3 and 'ARM' -- same in chunk and as a function attribute
local retval, chunk, state
	if old_build then
	retval, env_chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
	else
	retval, state = r.GetSetEnvelopeInfo_String(env, attr, '', false) -- setNewValue false
--Msg(state, 'state')
	end
return state and state == '1' or env_chunk and env_chunk:match('\n'..attr..' 1') or false
end


function Toggle_Env_State(arg, attr, state)
-- arg is either an envelope pointer or an array of envelope pointers
-- attr is integer:
-- 1 - visibility, 2 - bypass state, 3 - armed state
-- state: nil - set the state signified by attr argument of all envelopes to off, true/false - toggle
-- if state is valid (true/false) its value stems from Get_Env_State()

local old_build = tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.50 -- in older builds changes produced with the function GetSetEnvelopeInfo_String() aren't registered so undo point cannot be created, bug report https://forum.cockos.com/showthread.php?t=303814, and toggling must be done via a chunk, or with actions listed above that require selecting envelope which may not be the optimal solution
local attr = attr == 1 and (old_build and 'VIS' or 'VISIBLE') or attr == 2 and (old_build and 'ACT' or 'ACTIVE')
or attr == 3 and 'ARM' -- same in chunk and as a function attribute
local t, env = type(arg) == 'table' and arg, r.ValidatePtr(arg, 'TrackEnvelope*') and arg
local hide = state == nil -- only for visibility state
local state = state and 0 or 1
local st, fin = 1, env and 1 or t and #t
	for i=st, fin do
	local env = env or t[i].env
		if old_build then
		local retval, env_chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
		-- when using chunk, arm state cannot be toggled
		-- in a bypassed envelope, because arm flag 1 isn't cleared
		-- on bypassing, so it first must be unbypassed,
		-- this is not a problem when using GetSetEnvelopeInfo_String() function
			if attr == 'ARM' and env_chunk:match('\nACT 0') then
			env_chunk = env_chunk:gsub('\nACT 0', '\nACT 1')
			end
		env_chunk = env_chunk:gsub('\n'..attr..' %d', '\n'..attr..' '..(hide and 0 or state))
		r.SetEnvelopeStateChunk(env, env_chunk, false) -- isundo false
		else
		r.GetSetEnvelopeInfo_String(env, attr, hide and 0 or state, true) -- setNewValue true
		local take = r.Envelope_GetParentTake(env)
		-- redraw the graphics
			if take then
			r.UpdateItemInProject(r.GetMediaItemTake_Item(take))
			else
			r.TrackList_AdjustWindows(true) -- isMinor true, TCP only
			end
		end
	end
end



function Get_Active_Envelopes(obj)

	local function get_hidden_built_in_track_env(env)
	local env_name_t = {
	-- regular track
	Volume='', ['Volume (Pre-FX)']='', ['Trim Volume']='', ['Send Volume']='', 
	Pan='', ['Pan (Pre-FX)']='', ['Pan (Left)']='', ['Pan (Right)']='', ['Send Pan']='', 
	Width='', ['Width (Pre-FX)']='', Mute='', ['Send Mute']='',
	 -- master track
	Playrate='', --['Tempo map']='' -- excluding tempo map envelope because when inactive and has no points at all it cannot be opened even though the chunk is there
	}
	local ret, env_name = r.GetEnvelopeName(env)
		if env_name_t[env_name] then
		local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			if not chunk:match('\nPT %d') then return env end
		end
	end

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')
local Count_Envs, GetEnv = table.unpack(take and {r.CountTakeEnvelopes, r.GetTakeEnvelope}
or tr and {r.CountTrackEnvelopes, r.GetTrackEnvelope})

local t = {}
	for i=0, Count_Envs(obj)-1 do
	local env = GetEnv(obj, i)
		if 
		r.CountEnvelopePoints(env) > 0 or get_hidden_built_in_track_env(env)	then -- validation of fx envelopes in REAPER builds prior to 7.06 when ghost envelopes would be detected for fx parameters for which parameter modulation was enabled at least once // SUCH VALIDATION IS ALWAYS TRUE FOR VALID TRACK FX ENVELOPES AND ALL TAKE ENVELOPES REGARDLESS OF VISIBILITY, FOR VISIBLE BUILT-IN TRACK ENVELOPES REGARDLESS OF PRESENCE OF USER CREATED POINTS AND FOR HIDDEN BUILT-IN TRACK ENVELOPES WHICH HAVE USER CREATED POINTS; FOR TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS HIDDEN PROGRAMMATICALLY IT'S FALSE THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE i.e. 'not env_chunk:match('\nPT %d')', BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, FUNCTIONS DO RETURN THEIR POINTER, HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES MAY BECOME INVALID
		local ret, name = r.GetEnvelopeName(env)
		t[#t+1] = {name=name, env=env}
		end
	end
return t
end




function Delete_Env(env)
-- deletes with automation items
	if not env then return end
r.SetEnvelopeStateChunk(env, '.', false) -- isundo false
r.TrackList_AdjustWindows(true) -- isMinor true // update tracklist if env was visible
end


function Get_Env_GUID(env, want_vis)
-- want_vis is boolean to only get GUID if the env is visible

-- in REAPER builds prior to 7.06 CountTrack/TakeEnvelopes() lists ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
-- SUCH VALIDATION WORKS FOR VISIBLE TRACK BUILT-IN ENVELOPES EVEN WITHOUT USER CREATED POINTS
-- FOR HIDDEN TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS 
-- HIDDEN PROGRAMMATICALLY IT'S FALSE
-- THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE 
-- i.e. 'not env_chunk:match('\nPT %d')'
-- BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER 
-- THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, 
-- FUNCTIONS DO RETURN THEIR POINTER,
-- HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES BECOME INVALID
-- an open envelope by default has 1 point at position 0
-- in track built-in envelopes without user created points 
-- such point is ignored when the envelope is closed
-- while with user created points it's included in the total point count regardless of the visibility
-- without user created points track enevelope chunk doesn't list any points;
-- IT ALSO WORKS FOR TRACK FX ENVELOPES AND ALL TAKE ENVELOPES BOTH VISIBLE AND HIDDEN
-- because their point count doesn't depend on visibility
-- and presence of user created points
-- IN BUILDS OLDER THAN 7.38 ENVELOPE GUIDs WEREN'T NECESSARILY UNIQUE
-- IN TRACK/TAKE COPIES CRATED BY COPY/PASTE ENVELOPES KEPT THE THE SAME 
-- GUIDs AS IN THE SOURCE TRACK/TAKE, 
-- IN TAKES THEY ONLY WOULD UPDATE IF COPIED BY CTRL + MOUSE DRAG
-- bug report https://forum.cockos.com/showthread.php?t=300279
-- IN THOSE BUILDS IF UNIQUENESS IS REQUIRED FOR EVALUATION THE POINTER 
-- MUST BE USED INSTEAD

local build = tonumber(r.GetAppVersion():match('[%d%.]+'))
	if not env
	or env and build < 7.06
	and r.CountEnvelopePoints(env) == 0
	then return end

local retval, GUID, chunk, is_vis
	if build >= 6.24 then
	retval, GUID = r.GetSetEnvelopeInfo_String(env, 'GUID', '', false) -- setNewValue false
		if want_vis then
			if build < 7.19 then
			retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
			else
			retval, is_vis = r.GetSetEnvelopeInfo_String(env, 'VISIBLE', '', false) -- setNewValue false
			is_vis = is_vis == '1'
			end
		end
	else
	retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
	GUID = chunk:match('{.-}') -- OR chunk:match('EGUID (.-)\n')
	end

GUID = (want_vis and (is_vis or chunk and chunk:match('\nVIS 1 ')) or not want_vis) and GUID
return GUID and #GUID > 0 and GUID

end



function Get_Vis_Env_GUID(env)
-- IN BUILDS OLDER THAN 7.38 ENVELOPE GUIDs WEREN'T NECESSARILY UNIQUE
-- IN TRACK/TAKE COPIES CRATED BY COPY/PASTE ENVELOPES KEPT THE THE SAME 
-- GUIDs AS IN THE SOURCE TRACK/TAKE, 
-- IN TAKES THEY ONLY WOULD UPDATE IF COPIED BY CTRL + MOUSE DRAG
-- bug report https://forum.cockos.com/showthread.php?t=300279
-- IN THOSE BUILDS IF UNIQUENESS IS REQUIRED FOR EVALUATION THE POINTER 
-- MUST BE USED INSTEAD
	if tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.19 then
	local retval, chunk = r.GetEnvelopeStateChunk(env, '', false) -- isundo false
	return chunk:match('\nVIS 1 ') and chunk:match('{.-}') -- OR chunk:match('EGUID (.-)\n')
	else
	local retval, vis = r.GetSetEnvelopeInfo_String(env, 'VISIBLE', '', false) -- setNewValue false
	local retval, GUID = r.GetSetEnvelopeInfo_String(env, 'GUID', '', false) -- setNewValue false
	return vis == '1' and GUID
	end
end



function Re_Store_Env_Selection(...)
-- after setting a chunk and reordering envelopes, originally selected envelope pointer ends up belonging to another envelope, so in order to keep the original envelope selected its new pointer must be retrieved because now it will differ from the originally selected envelope pointer
-- 1st function run is without arguments, returns 3 values
-- 2nd function run is with all 3 arguments, re-selects originally selected env
local tr, fx_idx, parm_idx = table.unpack(...)
	if not tr then -- store
	local sel_env = r.GetSelectedTrackEnvelope(0)
	return r.Envelope_GetParentTrack(sel_env) -- tr, fx_idx, parm_idx
	else -- restore
	local env = r.GetFXEnvelope(tr, fx_idx, parm_idx, false)
	r.SetCursorContext(2, env)
	end
end


function Manipulate_Envelope_With_Actions(env, act_t) -- act_t an indexed table with action IDs
-- selects target env, which is the only way to affect it with actions
local sel_env = r.GetSelectedEnvelope(0) -- store currently selected env // gets both track and take envs
-- sel_env = r.GetSelectedTrackEnvelope(0) -- only track envs
r.SetCursorContext(2, env) -- select target env
	if act_t then
		for _, act_id in ipairs(act_id) do -- manipulale
		r.Main_OnCommand(act_id, 0)
		end
	end
r.SetCursorContext(2, sel_env) -- restore original env selection
end



function Count_FX_Envelopes() -- NO CONTAINER FX SUPPORT

local env_cnt = 0
-- Regular tracks
	for i = -1, r.CSurf_NumTracks(false)-1 do -- mcpView false // start from -1 to target the Master track
	local tr = r.GetTrack(0,i) or r.GetMasterTrack(0)
--	env_cnt = env_cnt + r.CountTrackEnvelopes(tr)
		for j = 0, r.TrackFX_GetCount(tr)-1 do
			for k = 0, r.TrackFX_GetNumParams(tr, j)-1 do
			local env = r.GetFXEnvelope(tr, j, k, false) -- create is false; for env to be valid it suffices that param mod be enabled
			env_cnt = env and r.CountEnvelopePoints(env) > 0 and env_cnt + 1 or env_cnt -- When param modulation was enabled at least once, GetFXEnvelope() returns parameter envelope even if there's none, if it's a ghost envelope ValidatePtr() always returns 'true' therefore are useless
			end
		end
	end
--[[ Master track // moved to the track loop above
local tr = r.GetMasterTrack(0)
--env_cnt = env_cnt + r.CountTrackEnvelopes(tr) -- includes Tempo Map env
	for i = 0, r.TrackFX_GetCount(tr)-1 do
		for k = 0, r.TrackFX_GetNumParams(tr, j)-1 do
		env_cnt = r.GetFXEnvelope(tr, j, k, false) -- create is false; for env to be valid it suffices that param mod be enabled
		and env_cnt + 1 or env_cnt
		end
	end
	]]
-- Items
	for i = 0, r.CountMediaItems(0)-1 do
	local item = r.GetMediaItem(0,i)
		for i = 0, r.CountTakes(item)-1 do
		local take = r.GetTake(item,i)
		env_cnt = env_cnt + r.CountTakeEnvelopes(take)
			for j = 0, r.TakeFX_GetCount(take)-1 do
				for k = 0, r.TakeFX_GetNumParams(take, j)-1 do
				local env = r.TakeFX_GetEnvelope(tr, j, k, false) -- create is false
				env_cnt = r.CountEnvelopePoints(env) > 0 and env_cnt + 1 or env_cnt -- When param modulation was enabled at least once, in REAPER builds prior to 7.06 TakeFX_GetEnvelope() returns parameter envelope even if there's none, if it's a ghost envelope there're no points // SUCH VALIDATION IS ALWAYS TRUE FOR VALID TRACK FX ENVELOPES AND ALL TAKE ENVELOPES REGARDLESS OF VISIBILITY, FOR VISIBLE BUILT-IN TRACK ENVELOPES REGARDLESS OF PRESENCE OF USER CREATED POINTS AND FOR HIDDEN BUILT-IN TRACK ENVELOPES WHICH HAVE USER CREATED POINTS; FOR TRACK BUILT-IN ENVELOPES WITHOUT USER CREATED POINTS HIDDEN PROGRAMMATICALLY IT'S FALSE THEREFORE THEY MUST BE VALIDATED VIA CHUNK IN WHICH CASE IT LACKS PT (point) ATTRIBUTE i.e. 'not env_chunk:match('\nPT %d')', BECAUSE EVEN THOUGH IN THE ENVELOPE MANAGER THEY'RE NOT MARKED AS ACTIVE WHILE BEING HIDDEN, FUNCTIONS DO RETURN THEIR POINTER, HIDDEN VIA THE ENVELOPE MANAGER SUCH ENVELOPES BECOME INVALID
				end
			end
		end
	end
return env_cnt

end


local function Get_Env_Point_At_Time(env, item, take) -- autom items are ignored
-- the mouse cursor must be to the right of the point vertical axis, not necessarily near the point
r.PreventUIRefresh(1)
local x, y = r.GetMousePosition()
local cur_pos = r.GetCursorPosition()
r.Main_OnCommand(40514, 0) -- View: Move edit cursor to mouse cursor (no snapping)
local pt_time = r.GetCursorPosition()
	if item then -- convert cursor project time to time within item
	local item_pos = r.GetMediaItemInfo_Value(r.GetMediaItemTake_Item(take), 'D_POSITION')
	local offset = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
	local playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE') -- affects take start offset and take env point pos
	pt_time = (pt_time - item_pos + offset)*playrate
	end
local pt_idx = r.GetEnvelopePointByTimeEx(env, -1, pt_time) -- autoitem_idx -1 for the envelope points
local retval, time, value, shape, tens, is_sel = r.GetEnvelopePointEx(env, -1, pt_idx) -- autoitem_idx -1 for the envelope points
r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false // restore orig edit cursor pos
r.PreventUIRefresh(-1)
return pt_idx, value, is_sel
end


local function Count_Sel_Points(env, pt_idx) -- and evaluate is specific point is selected
local sel_pt_cnt, is_pt_idx_sel = 0
local pt_cnt = r.CountEnvelopePointsEx(env, -1) -- autoitem_idx -1 for the envelope points
	for idx = 0, pt_cnt-1 do
	local retval, time, value, shape, tens, is_sel = r.GetEnvelopePointEx(env, -1, idx) -- autoitem_idx -1 for the envelope points
	sel_pt_cnt = is_sel and sel_pt_cnt+1 or sel_pt_cnt
	is_pt_idx_sel = idx == pt_idx and is_sel or is_pt_idx_sel
	end
return pt_cnt, sel_pt_cnt, is_pt_idx_sel -- cannot iterate exclusively over selected points so the actual point count is necessary to then filter points by their selection state
end


-- USE Envelope_GetParentTrack() or Envelope_GetParentTake() INSTEAD
function Get_FX_Env_Src_Parameter(env) -- get fx parameter the envelope belongs to
local tr = r.GetEnvelopeInfo_Value(env, 'P_TRACK') -- if take env is selected returns 0.0, otherwise pointer
local take = r.GetEnvelopeInfo_Value(env, 'P_TAKE') -- if track env is selected returns 0.0, otherwise pointer
local tr, take = tr ~= 0 and tr, take ~= 0 and take -- validate
local retval, env_name = r.GetEnvelopeName(env)
-- capture fx name displayed in the fx chain, fx env name format is 'parm name / displayed fx name'
local fx_name = env_name:match('.+ / (.+)') -- clean name, without the plugin type prefix
local cur_val, minval, maxval, step
local CountFX, GetFXName, GetNumParams, GetFXEnvelope, GetFXParam, GetParamStepSizes = table.unpack(tr and {r.TrackFX_GetCount, r.TrackFX_GetFXName, r.TrackFX_GetNumParams, r.GetFXEnvelope, r.TrackFX_GetParam, r.TrackFX_GetParameterStepSizes} or take and {r.TakeFX_GetCount, r.TakeFX_GetFXName, r.TakeFX_GetNumParams, r.TakeFX_GetEnvelope, r.TakeFX_GetParam, r.TakeFX_GetParameterStepSizes})
local obj = take or tr
	for fx_idx = 0, CountFX(obj)-1 do
	local retval, name = GetFXName(obj, fx_idx)
		if name:match(': (.+) %(') == fx_name or name == fx_name then -- either default or custom plugin name
			for parm_idx = 0, GetNumParams(obj, fx_idx)-1 do
			local parm_env = GetFXEnvelope(obj, fx_idx, parm_idx, false) -- create false
				if parm_env == env then
				local cur_val, minval, maxval = GetFXParam(obj, fx_idx, parm_idx)
				local retval, step, smallstep, largestep, istoggle = GetParamStepSizes(obj, fx_idx, parm_idx) -- if no step retval is false
				return cur_val, minval, maxval, step ~= 0 and step
				end
			end
		end
	end

end


function Get_Take_Pitch_Env_Snap()
-- Preferences -> Editing behavior -> Envelope display -> Default per take pitch envelope ... snap:
-- get_config_var_string() can be used instead of io.open
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local val = cont:match('pitchenvrange=(.-)\n')
local val = #val > 0 and tonumber(val)
local snap
-- Thanks to Mespotine
-- https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
-- 'pitchenvrange' value is the sum of the range integer and then snap integer
-- snap integer is an 8 bit value and is changed by 8 bit increments
-- statring from 0, so if the value is 328 the settings are
-- 72 (range) + 256 (1 st snap)
-- the range cannot be equal to or greater than 256,
-- because when added to the snap value it will cause clash with the next snap value
	if val > 256 and val < 512 then snap = 1
	elseif val > 512 and val < 768 then snap = 0.5
	elseif val > 768 and val < 1024 then snap = 0.25
	elseif val > 1024 and val < 1280 then snap = 0.1
	elseif val > 1280 and val < 1537 then snap = 0.05
	elseif val > 1537 or val < 256 then snap = 0.01 end
-- if snap is OFF (< 256) natively pitch can be set
-- by as little as 1/1000st which isn't practical
-- so in this case the unit is 0.01st i.e. 1 cent
return snap
end


function Get_Vol_Env_Range()
-- Preferences -> Editing behavior -> Envelope display -> Volume envelope range
-- get_config_var_string() can be used instead of io.open
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local val = cont:match('volenvrange=(.-)\n')
local val = tonumber(val)
-- Thanks to Mespotine
-- https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
	if val then
	local bit1, bit2 = val&1, val&4
--Msg(bit1) Msg(bit2)
	-- the lower limit is -inf so it doesn't have to be returned
	-- the lower limit is set within the routine to another value
	return bit1 == 1 and bit2 == 0 and 0
	or bit1 == 0 and bit2 == 0 and 6
	or bit1 == 0 and bit2 == 4 and 12
	or bit1 == 1 and bit2 == 4 and 24
	end
end



function Is_Track_FX_Envelope(env) -- 1st return val being nil means not a track FX envelope
-- to verify further the next function Is_Track_Or_Take_Env() can be used
local tr, fx_idx, parm_idx = r.Envelope_GetParentTrack(env)
	if fx_idx > -1 then return tr, fx_idx, parm_idx end
end


function Is_Track_Or_Take_Env(env)
--[[ special case
local env = r.GetCursorContext() == 2
local env = env and r.GetSelectedEnvelope(0)
]]
local env = not env and r.GetSelectedEnvelope(0) or env -- arg either is or is not provided
local is_tr_env = env and r.GetEnvelopeInfo_Value(env, 'P_TRACK') -- if take env is selected returns 0.0, otherwise pointer
local is_take_env = env and r.GetEnvelopeInfo_Value(env, 'P_TAKE') -- if track env is selected returns 0.0, otherwise pointer
return is_tr_env ~= 0 and is_tr_env,  is_take_env ~= 0 and is_take_env
-- OR
-- return env and r.GetEnvelopeInfo_Value(env, 'P_TRACK') ~= 0 and env,
-- env and r.GetEnvelopeInfo_Value(env, 'P_TAKE') ~= 0 and env
end
-- OR
-- take, fx_idx, parm_idx = r.Envelope_GetParentTake(env)
-- tr, fx_idx, parm_idx = r.Envelope_GetParentTrack(env)


function Is_Selected_Track_Or_Take_Env()
local env = r.GetSelectedEnvelope(0)
local take_env = r.GetSelectedTrackEnvelope(0) ~= env
return env and not take_env, env and take_env -- track env, take env // 2 return values
-- OR
-- return env and (not take_env and 'track' or 'take') -- track env, take env // 1 return value
-- OR
-- local take_env = env and r.GetSelectedTrackEnvelope(0) ~= env
-- return env, take_env
-- OR
--	if env then
-- return r.Envelope_GetParentTrack(env), r.Envelope_GetParentTake(env)
-- end
end


function FX_Or_Native_Envelope(env)
-- if env arg isn't valid, selected env is evaluated
local env = not env and r.GetSelectedEnvelope(0) or env
local take_env = r.GetSelectedTrackEnvelope(0) ~= env
-- after getting return values use r.ValidatePtr() to find out whether track or take
	if env and not take_env then -- track env
	local tr, fx_idx, parm_idx = r.Envelope_GetParentTrack(env)
	return tr, fx_idx, parm_idx -- if fx_idx is -1 native env
	elseif env and take_env then -- take env
	local take, fx_idx, parm_idx = r.Envelope_GetParentTake(env)
	return take, fx_idx, parm_idx
	end
end



function Envelopes_Locked()
return r.GetToggleCommandStateEx(0, 40585) == 1, -- Locking: Toggle track envelope locking mode
r.GetToggleCommandStateEx(0, 41851) == 1 -- Locking: Toggle take envelope locking mode
end
-- USE:
-- tr, take = Envelopes_Locked() -- booleans


function Deselect_All_Env_Points(env) -- incl. automation items

	local function Deselect_Points_In_Env_All_AIs(env, AI_idx)
	-- accounting for points in all loop iterations, visible or not
		for i = 0, r.CountEnvelopePointsEx(env, AI_idx|0x10000000)-1 do
		r.SetEnvelopePointEx(env, AI_idx, i, timeIn, valueIn, shapeIn, tensionIn, false, noSortIn) -- selectedIn false, deselect
		end
	end
	-- in the envelope
	for i = 0, r.CountEnvelopePoints(env)-1 do -- ignoring automation items
	r.SetEnvelopePointEx(env, -1, i, timeIn, valueIn, shapeIn, tensionIn, false, noSortIn) -- autoitem_idx -1, ignore, selectedIn false, deselect
	end
	-- in the automation items
	for AI_idx = 0, r.CountAutomationItems(env)-1 do -- accounting for all points in all loop iterations, visible or not
	Deselect_Points_In_Env_All_AIs(env, AI_idx)
	end

end



function Get_Env_Segment_At_Cursor(env, cur_pos, item, take)
-- relies on Item_Time_2_Proj_Time() for getting take env points
-- returns indices of segment start and end points which then can be gotten with
-- r.GetEnvelopePoint(env, i)
-- and set with r.SetEnvelopePoint(env, -1, i, timeIn, valueIn, shapeIn, tensionIn, true, noSortIn)
-- the routine can be re-purposed to getting env point under cursor, within time selection or razor edit area

	local function Get_Props_Of_AI_Overlapping_Env_Segm(env, pt_pos_st, pt_pos_end, cur_pos)
		for i = 0, r.CountAutomationItems(env)-1 do
		local pos = r.GetSetAutomationItemInfo(env, i, 'D_POSITION', -1, false) -- value -1, is_set false
		local fin = pos + r.GetSetAutomationItemInfo(env, i, 'D_LENGTH', -1, false) -- value -1, is_set false
			if pos <= pt_pos_st and fin >= pt_pos_st -- start point is overlapped
			or pos <= pt_pos_end and fin >= pt_pos_end -- end point is overlapped
			-- segment is overlapped and the cursor is located within the AI bounds
			or pos >= pt_pos_st and fin <= pt_pos_end
			and pos <= cur_pos and fin > cur_pos
			then
			return i, pos, fin
			end
		end
	end

	for i = 0, r.CountEnvelopePoints(env)-1 do -- look for segment points
		local retval, pos_end, val, shape, tens, sel = r.GetEnvelopePointEx(env, -1, i) -- autoitem_idx -1, ignore // OR r.GetEnvelopePoint()
		pos_end = take and Item_Time_2_Proj_Time(pos_end, item, take) or pos_end
			if pos_end and not end_pt_idx and pos_end >= cur_pos then -- pos_end can be nil if take env and the item is trimmed, because only pos of points within view is returned by Item_Time_2_Proj_Time() function
			end_pt_idx, st_pt_idx = i, i-1
				-- for track env only return points which aren't overlapped by an automation item
				if not take and st_pt_idx > -1 then -- more than 1 point in the track env
			-------------------------------------------------------
				--[[ THIS ROUTINE ALLOWS SELECTING MAIN ENV SEGMGENT POINTS EVEN IF ONE OF THEM IS OVERLAPPED BY AN AI
				local AI_idx, AI_st, AI_end = Get_Props_Of_AI_Intersecting_Cur_Pos(env, cur_pos)
					if AI_idx then -- overlapping AI found
					local retval, pos_start, val, shape, tens, sel = r.GetEnvelopePointEx(env, -1, st_pt_idx) -- autoitem_idx -1, ignore // OR r.GetEnvelopePoint()
						if pos_start >= AI_st or pos_end <= AI_end then
						end_pt_idx, st_pt_idx = nil -- reset as if the points weren't found
						end
					end
				]]
				-- THIS ROUTINE ENSURES THAT SEGMENT WHOSE POINTS ARE OVELAPPED BY AN AUTOMATION ITEM IS IGNORED
			--	local overlap = Get_Props_Of_AI_Overlapping_Env_Pt(env, pos_end)
				local retval, pos_start, val, shape, tens, sel = r.GetEnvelopePointEx(env, -1, st_pt_idx) -- autoitem_idx -1, ignore // OR r.GetEnvelopePoint()
				local overlap = Get_Props_Of_AI_Overlapping_Env_Segm(env, pos_start, pos_end, cur_pos)
					if overlap then
					end_pt_idx, st_pt_idx = nil -- reset as if the points weren't found
					end
				end
			------------------------------------------------------
			break end
		end
	end

return st_pt_idx, end_pt_idx

end



function Get_Env_Custom_Colors()
-- suffices that the custom String is included in the FX param name
-- color associated with the first string match is applied
local path = r.GetResourcePath()
local sep = path:match('[\\/]')
local path = path..sep..'reaper-env-colors.ini'
	if r.file_exists(path) then
	local f = io.open(path,'r')
	local data = f:read('*a')
	f:close()
	local t = {}
		for line in data:gmatch('[^\n\r]+') do
			if line and line:match('%d') == '1' then -- enabled
			local name, hex = line:match('%d "?(.*)"? (.+)')
				if name and hex then
				t[name] = hex
				end
			end
		end
	return t
	end
end



function Check_env_scaling(src, dst, val)
-- by Sexan https://forum.cockos.com/showpost.php?p=2275821&postcount=2002
  local mode_s = reaper.GetEnvelopeScalingMode( src )
  local mode_d = reaper.GetEnvelopeScalingMode( dst )

  if mode_s ~= mode_d then
    if mode_s == 1 and mode_d == 0 then
      val = reaper.ScaleFromEnvelopeMode(1, val)
    else
      val = reaper.ScaleToEnvelopeMode(1, val)
    end
  end

  return val
end



function Active_Track_Envelopes_Exist1(want_sel_tracks)
-- want_sel_tracks is boolean to only evaluate selected tracks
	for i=0, r.GetNumTracks()-1 do
	local tr = r.GetTrack(0,i)
		if not want_sel_tracks or want_sel_tracks and r.IsTrackSelected(tr) then
			if tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.06 then
				if r.CountTrackEnvelopes(tr) > 0 then return true end
			else
			-- in REAPER builds prior to 7.06 CountTrack/TakeEnvelopes() lists ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
				for i=0, r.CountTrackEnvelopes(tr)-1 do
				local env = r.GetTrackEnvelope(tr,i)
					if r.CountEnvelopePoints(env) > 0 then return true end
				end
			end
		end
	end
end


function Active_Track_Envelopes_Exist2(want_sel_tracks) -- more efficient
-- want_sel_tracks is boolean to only evaluate selected tracks
local TrackCount, GetTrack = table.unpack(want_sel_tracks and {r.CountSelectedTracks, r.GetSelectedTrack}
or {r.GetNumTracks, r.GetTrack})
	for i=0, TrackCount(0)-1 do
	local tr = GetTrack(0,i)	
		if tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.06 then
			if r.CountTrackEnvelopes(tr) > 0 then return true end
		else
		-- in REAPER builds prior to 7.06 CountTrack/TakeEnvelopes() lists ghost envelopes when fx parameter modulation was enabled at least once without the parameter having an active envelope, hence must be validated with CountEnvelopePoints(env) because in this case there're no points; ValidatePtr(env, 'TrackEnvelope*'), ValidatePtr(env, 'TakeEnvelope*') and ValidatePtr(env, 'Envelope*') on the other hand always return 'true' therefore are useless
			for i=0, r.CountTrackEnvelopes(tr)-1 do
			local env = r.GetTrackEnvelope(tr,i)
				if r.CountEnvelopePoints(env) > 0 then return true end
			end
		end
	end
end



--============================ E N V E L O P E S   E N D ==================================


--============================ A U T O M A T I O N  I T E M S ================================

--[[

DEALING WITH AI ENVELOPE POINTS

AI startoffset affects points count

When startoffset is not 0 (which is always just to be on the safe side) the count
must be based on one full loop iteration including hidden points in case AI is trimmed, i.e.
CountEnvelopePointsEx(env, AI_idx|0x10000000)

this naturally applies to getting an AI env pount, i.e.
GetEnvelopePointEx(env, AI_idx|0x10000000, pt_idx)

as it turns out for setting this isn't necessary and AI_idx doesn't have to be added 0x10000000 (decimal 268435456)

When the count is based on the number of visible points incl. all loop iterations, i.e.
CountEnvelopePointsEx(env, AI_idx)
if there're hidden points due to trimming the visible point count will be smaller
than the count based on one full loop iteration and as a result loop iteration
which starts from 0 won't reach the last visible point or more (depending on
how many are hidden)
So for now not sure when getting visible point count is useful

]]



function UnTrim_AutomItem_LeftEdge(env, autoitem_idx, val) -- rather mimics trim by shifting contents, changing length and position
-- val in sec, positive val trim [->, negative val untrim <-[
	if not env or not autoitem_idx or not val then return end
local props = {D_POSITION = 0, D_LENGTH = 0, D_STARTOFFS = 0, D_PLAYRATE = 0}
local GetSetAI = r.GetSetAutomationItemInfo
	for k in pairs(props) do
	props[k] = GetSetAI(env, autoitem_idx, k, -1, false) -- value -1, is_set false
	end
	for k, v in pairs(props) do
		if props.D_LENGTH <= val then return end -- don't apply if AI is too short, otherwise it will keep changing position
		if k ~= 'D_PLAYRATE' then -- playrate is only required for startoffs calculation and shouldn't be set
		local val = k == 'D_LENGTH' and v-val
		or k == 'D_STARTOFFS' and v+val*props.D_PLAYRATE -- minus val*playrate is shift rightwards (forward), plus is shift leftwards (backwards)
		or v+val -- D_POSITION
		GetSetAI(env, autoitem_idx, k, val, true)
		end
	end
--[[ OR
local pos = GetSetAI(env, autoitem_idx, 'D_POSITION', -1, false) -- val -1, is_set false
local len = GetSetAI(env, autoitem_idx, 'D_LENGTH', -1, false)
local startoffs = GetSetAI(env, autoitem_idx, 'D_STARTOFFS', -1, false)
local playrate = GetSetAI(env, autoitem_idx, 'D_PLAYRATE', -1, false)
GetSetAI(env, autoitem_idx, 'D_STARTOFFS', startoffs+val*playrate, true) -- is_set true
GetSetAI(env, autoitem_idx, 'D_LENGTH', len-val, true)
GetSetAI(env, autoitem_idx, 'D_POSITION', pos+val, true)
]]
end


function Trim_AutomItem_LeftEdge(env, autoitem_idx, pos) -- genuine trim but no way to untrim // make sure no other autom items are selected
r.PreventUIRefresh(1)

-- Split
local cur_pos = r.GetCursorPosition() -- store current edit cur pos
r.GetSetAutomationItemInfo(env, autoitem_idx, 'D_UISEL', 1, true) -- value 1 (select), ise_set true
r.SetEditCurPos(pos, false, false) -- restore edit cur pos // moveview & seekplay false
r.Main_OnCommand(42087,0) -- Envelope: Split automation items
r.GetSetAutomationItemInfo(env, autoitem_idx+1, 'D_UISEL', 0, true) -- unselect to prevent deletion of the righthand part of the split // autoitem_idx+1 is righthand part of the split being a new autom item, value 0 (unselect), ise_set true
r.SetEditCurPos(cur_pos, false, false) -- restore edit cur pos // moveview & seekplay false
--r.SetMediaItemSelected(item, true) -- re-select media item

-- Delete the lefthand part of the split
r.Main_OnCommand(42086,0) -- Envelope: Delete automation items

r.PreventUIRefresh(-1)
end



function Insert_AI_with_Unique_Pool_ID(env, item)
-- based on https://forum.cockos.com/showthread.php?t=304784
-- if no selected items on the track inserts at all items

local env = env or r.GetSelectedTrackEnvelope(0)
local tr = r.GetEnvelopeInfo_Value(env, 'P_TRACK')
local tr_itm_cnt = tr ~= 0 and r.CountTrackMediaItems(tr)
	if not env or tr == 0 or tr_itm_cnt == 0 then 
--	reaper.MB('No envelope is selected','',0) 
	return end

local itm_t, sel_exist = {}
	for i=0, tr_itm_cnt-1 do
	local item = r.GetTrackMediaItem(tr, i)
	sel_exist = sel_exist or r.IsMediaItemSelected(item)
	t[#t+1] = item
	end
	
	if sel_exist then -- remove all non-selected
		for i=#itm_t,1,-1 do
			if not r.IsMediaItemSelected(itm_t[i]) then
			table.remove(itm_t, i)
			end
		end
	end
	
local pool_ID = math.floor(tonumber(os.date('%X'):gsub('[^0-9]',''))) -- time hh:mm:ss; removing all but digits and truncating decimal zeros with math.floor
	
--r.Undo_BeginBlock2(0)
	for k, item in ipairs(itm_t) do
	local item_pos = GetVal(item, 'D_POSITION')
	local item_len = GetVal(item, 'D_LENGTH')
	local AI_idx = r.InsertAutomationItem(env, pool_ID, item_pos, item_len)
	pool_ID = pool_ID+1 -- increment explicitly for the next cycle, because since pool_ID value is taken from time value with resolution down to seconds it won't be naturally updated by the next cycle because script runs much faster
	end
--reaper.Undo_EndBlock2(0,'Insert pooled AI stretched to '..tostring(items)..' selected items', 1)
end



-- STORE, UNSELECT AND RESTORE SELECTED ITEMS (incl. autom items)
function Delete_AutomItem(item, env, AI_idx, length, limit, keep_points) 
-- length and limit are optional;
-- keep points is boolean;
-- can be deleted via envelope chunk as well
-- but keeping points will be challenging

	if length and limit and length < limit  -- minimum length allowed is 0.1 sec when set programmatically or via input
	or not length or not limit
	then
	-- https://forum.cockos.com/showpost.php?p=2239082&postcount=9 thanks to X-Raym for the tip
	r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 1, true) -- value 1 (select), ise_set true
	local cmdID = keep_points and 42088 or 42086 -- Envelope: Delete automation items, preserve points OR Envelope: Delete automation items
	r.Main_OnCommand(cmdID,0)
	r.SetMediaItemSelected(item, true) -- re-select media item
	end

end


function Split_AutomItem(item, item_start_init, env, autoitem_idx)
r.PreventUIRefresh(1)
local cur_pos = r.GetCursorPosition() -- store current edit cur pos
r.GetSetAutomationItemInfo(env, autoitem_idx, 'D_UISEL', 1, true) -- value 1 (select), ise_set true
r.SetEditCurPos(item_start_init, false, false) -- restore edit cur pos // moveview & seekplay false
r.Main_OnCommand(42087,0) -- Envelope: Split automation items
r.GetSetAutomationItemInfo(env, autoitem_idx+1, 'D_UISEL', 0, true) -- unselect to prevent deletion when media item length is being changed // autoitem_idx+1 is righthand part of the split being a new autom item, value 0 (unselect), ise_set true
r.SetEditCurPos(cur_pos, false, false) -- restore edit cur pos // moveview & seekplay false
r.SetMediaItemSelected(item, true) -- re-select media item
r.PreventUIRefresh(-1)
end


local Re_Store_Sel_AIs1(sel_AI)
-- sel_AI is a table storing indices of originally selected AI
local is_AI_sel
	if not sel_AI then
	local sel_AI = {}
		for tr_idx = 0, r.CountTracks(0)-1 do -- check if there're selected AI and save them because they'll have to be deselected below in order to not be affected by duplication of media items directly above them
		local tr = r.GetTrack(0,tr_idx)
			for env_idx = 0, r.CountTrackEnvelopes(tr)-1 do
			local env = r.GetTrackEnvelope(tr, env_idx)
				for AI_idx = 0, r.CountAutomationItems(env)-1 do
					if r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', -1, false) > 0 -- selected; is_set false
					then
					sel_AI[env] = not sel_AI[env] and {idx = {}, pos = {}} or sel_AI[env] -- only create table if there're selected AIs
					local len = #sel_AI[env].idx -- for brevity
					sel_AI[env].idx[len+1] = AI_idx -- saving indices as well for simplicity of code in AI de-selecton routine if needed
						if r.GetToggleCommandStateEx(0, 40070) == 1 -- Options: Move envelope points with media items and razor edits
						then -- if the option is ON and context is 'Items' and the media items have AIs attached to them, the AIs will be duplicated along with media items so their total count will change and their indices won't be reliable to restore their selection at the end of the script which is especially true with leftward duplication because count starts from the left; position seems the only most reliable piece of data in this case which is still not failproof because AI start might get trimmed with another overlapping AI during duplication
						local len = #sel_AI[env].pos -- for brevity
						sel_AI[env].pos[len+1] = r.GetSetAutomationItemInfo(env, AI_idx, 'D_POSITION', -1, false) -- is_set false
						end
					is_AI_sel = 1 -- if at least 1 AI is selected
					end
				end
			end
		end
	return is_AI_sel, sel_AI
	else -- re-select originally selected AIs if 'Items' context because in this case AIs are deselected to prevent possible glitches; or select all last duplicate instances if 'Automation items' context, otherwise only the very last ends up being selected
		for env in pairs(sel_AI) do
			if ctx == 'Items' and r.GetToggleCommandStateEx(0, 40070) == 1 -- use position data to restore selection because that's what was saved in the loop at the beginning of the script under the GetToggleCommandStateEx condition
			then
				for _, AI_pos in ipairs(sel_AI[env].pos) do
					for AI_idx = 0, r.CountAutomationItems(env)-1 do
					local pos = r.GetSetAutomationItemInfo(env, AI_idx, 'D_POSITION', -1, false) -- is_set false
						if pos == AI_pos then r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 1, true) -- is_set true
						break end -- to jump to the next AI_data value
					end
				end
			else -- context 'Automation items', if context is 'Tracks' the table is empty // LESS RELEVANT FOR GENERAL USE
				for _, AI_idx in ipairs(sel_AI[env].idx) do
				r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 1, true) -- is_set true
				end
			end
		end
	end

end



function Re_Store_Selected_AIs2(store, env)
-- !!! ONLY WORKS RELIABLY WITH NON-POOLED AIs because 'P_POOL_EXT' arg
-- stores selection mark within all pooled AIs regardless of their actual selection
-- and on the restoration stage if one pooled was selected all pooled get selected;
-- store is boolean to trigger storage routine;
-- env is passed at the restoration stage
-- stemming from the currently selected env pointer the function returns at the storage stage
	if store then
		for tr_idx = 0, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,tr_idx)
			for env_idx = 0, r.CountTrackEnvelopes(tr)-1 do
			local env = r.GetTrackEnvelope(tr, env_idx)
				for AI_idx = 0, r.CountAutomationItems(env)-1 do
					if r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', -1, false) > 0 -- selected; is_set false
					then -- mark as selected with extended data
					r.GetSetAutomationItemInfo_String(env, AI_idx, 'P_POOL_EXT:D_UISEL', '1', true) -- is_set true
					r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 0, true) -- is_set true // de-select
					end
				end
			end
		end
	return r.GetSelectedEnvelope()
	else -- restore
		if env then r.SetCursorContext(2, env) end -- re-select originally selected ennvelope
		for tr_idx = 0, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,tr_idx)
			for env_idx = 0, r.CountTrackEnvelopes(tr)-1 do
			local env = r.GetTrackEnvelope(tr, env_idx)
				for AI_idx = 0, r.CountAutomationItems(env)-1 do
				local ret, sel = r.GetSetAutomationItemInfo_String(env, AI_idx, 'P_POOL_EXT:D_UISEL', '', false) -- is_set false
					if ret then -- originally selected
					-- !!! at this stage if the originally selected AI was pooled all other AIs in its pool
					-- are also re-selected because 'P_POOL_EXT' data are pool-specific rather than AI specific
					r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 1, true) -- is_set true // re-select
					end
				end
				-- deleted the mark
				for AI_idx = 0, r.CountAutomationItems(env)-1 do
				local ret, sel = r.GetSetAutomationItemInfo_String(env, AI_idx, 'P_POOL_EXT:D_UISEL', '', false) -- is_set false
					if ret then -- originally selected
					r.GetSetAutomationItemInfo_String(env, AI_idx, 'P_POOL_EXT:D_UISEL', '', true) -- is_set true // clear mark
					end
				end
			end
		end
	end
end
-- USE:
-- local curr_env = Re_Store_Selected_AIs2(1) -- store true // store
-- DO STUFF
-- local curr_env = Re_Store_Selected_AIs2(nil, curr_env) -- store false // restore



function Deselect_Selected_AIs(sel_AI) -- arg is a table from prev function
	for env in pairs(sel_AI) do
		for _, AI_idx in ipairs(sel_AI[env].idx) do
		r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 0, true) -- is_set true
		end
	end
end


function Get_Sel_AI_St_And_End(t) -- t from previous function
-- get the start of the first and the end of the last amongst selected AIs
local first_start = math.huge
local last_end = math.huge*-1
	for env in pairs(t) do
		for _, AI_idx in ipairs(t[env].idx) do
			if r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', -1, false) > 0 then -- selected; is_set false
			local pos = r.GetSetAutomationItemInfo(env, AI_idx, 'D_POSITION', -1, false) -- is_set false
			local fin = pos + r.GetSetAutomationItemInfo(env, AI_idx, 'D_LENGTH', -1, false) -- is_set false
			first_start = pos < first_start and pos or first_start
			last_end = fin > last_end and fin or last_end
			end
		end
	end
return first_start, last_end
end



function Delete_Or_Unpool_Selected_AI(env, AI_idx, tmp_pool_ID, delete, keep_points)
-- MUST BE PRECEDED AND FOLLOWED BY Re_Store_Selected_AIs2(), see USE above,
-- OR by Re_Store_Selected_AIs1() modified to offset AI indices on the target envelope
-- in case AI was deleted
-- that's needed because the actions only affect selected AI on selected envelope
-- which requires de-selection of all other AIs and subsequent restoration of their selection;
-- tmp_pool_ID stems from the table field tmp_data_t.tmp_pool_ID
-- returned by Re_Store_Selected_AIs2() preceding this function;
-- if delete is false AI will be unpooled
-- in case AI was deleted;
-- when unpooling the new pool ID will be greater by 1 than it's supposed to be
-- due to presence of the temp AI created by Re_Store_Selected_AIs2() which will
-- will be assigned 1st available poold ID before unpooling
local env = not env and r.GetSelectedTrackEnvelope() or env
r.SetCursorContext(2, env) -- in case it's not selected
local cmd = delete and
(keep_points and 42088 -- Envelope: Delete automation items, preserve points
or 42086) -- Envelope: Delete automation items
or 42084 -- Envelope: Remove automation items from pool (un-pool)
--local pool_ID = r.GetSetAutomationItemInfo(env, AI_idx, 'D_POOL_ID', -1, false) -- is_set false
local selected = r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', -1, false) -- is_set false
r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 1, true) -- is_set true // select in case not selected because the actions only affect selected AIs
r.Main_OnCommand(cmd,0)
	if not delete then -- de-select here, if was originally selected will be re-selected inside Re_Store_Selected_AIs2() using the return values
	r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 0, true) -- is_set true
		if selected then
		return env, AI_idx -- to use in re-selection inside Re_Store_Selected_AIs2() at the restoration stage, essentially redundant due to the above condition, but just in case
		end
	end

end



function RESOLVE_AI_OVERLAPS()

local sel_AI_t = {}

	for i = 0, r.CountTracks(0)-1 do -- store selected AIs and deselect
	local tr = r.GetTrack(0,i)
		for i = 0, r.CountTrackEnvelopes(tr)-1 do
		local env = r.GetTrackEnvelope(tr, i)
			for i = 0, r.CountAutomationItems(env)-1 do -- backwards because some AIs may need to be deleted
				if r.GetSetAutomationItemInfo(env, i, 'D_UISEL', 0, false) ~= 0 then -- is_set false
				sel_AI_t[env] = not sel_AI_t[env] and {} or sel_AI_t[env]
				sel_AI_t[env][1] = r.CountAutomationItems(env) -- store count to collate later to allow deciding whether to restore
				local len = #sel_AI_t[env] -- for brevity
				sel_AI_t[env][len+1] = i
				r.GetSetAutomationItemInfo(env, i, 'D_UISEL', 0, true) -- is_set true // deselect
				end
			end
		end
	end

local cur_pos = r.GetCursorPosition()

local func = r.GetSetAutomationItemInfo

	local function Find_First_Overlap(env, AI_idx, pos_curr) -- addresses cases when one AI overlaps several other AIs and have index which is not immediately precedes current AI index
		for i = AI_idx-1, 0, -1 do -- start from previous
		local fin_prev = func(env, i, 'D_POSITION', 0, false) + func(env, i, 'D_LENGTH', 0, false) -- is_set false
		local diff = fin_prev - pos_curr
			if diff > 0 then return diff, fin_prev end
		end
	end


	local function Trim_AI_By_Splitting(env, AI_idx, fin_prev)
	func(env, AI_idx, 'D_UISEL', 1, true) -- is_set true // select AI
	r.SetEditCurPos(fin_prev, false, false) -- oveview, seekplay false // set cur to the end of prev AI which overlaps
	r.Main_OnCommand(42087, 0) -- Envelope: Split automation items
	func(env, AI_idx+1, 'D_UISEL', 0, true)-- is_set true // deselect right part of the split
	func(env, AI_idx, 'D_UISEL', 1, true) -- is_set true // select left part of the split
	r.Main_OnCommand(42086, 0) -- Envelope: Delete automation items // delete left part
	end

	for i = 0, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i)
		for i = 0, r.CountTrackEnvelopes(tr)-1 do
		local env = r.GetTrackEnvelope(tr, i)

local ret, chunk = r.GetEnvelopeStateChunk(env, '', false) -- MONITORING ONLY
--Msg(chunk)

			for i = r.CountAutomationItems(env)-1, 0, -1 do -- backwards because some AIs may need to be deleted
			local func = r.GetSetAutomationItemInfo
			local pos_curr = func(env, i, 'D_POSITION', 0, false) -- is_set false
			local len_curr = func(env, i, 'D_LENGTH', 0, false) -- is_set false
			local startoffs_curr = func(env, i, 'D_STARTOFFS', 0, false) -- is_set false
			local playrate = func(env, i, 'D_PLAYRATE', 0, false) -- is_set false
			local fin_curr = pos_curr + len_curr
			local diff, fin_prev = Find_First_Overlap(env, i, pos_curr) -- addresses cases when one AI overlaps several which don't overlap each other
				if diff and diff > 0 then -- AIs overlap
					if len_curr < 0.02 -- delete because it cannot be shortened or split, AI length cannot be set to less than 100 ms via API (when setting length shorter that 100 ms to a an already shorter AI it ends up being exactly 100 ms) and it cannot be split with action if the edit cursor is at less than 10 ms from either of AI edges // must be deleted with action because setting length to 0 only shortens AI down to 100 ms // requires preemptive deselection of all AIs
					or fin_prev >= fin_curr -- prev AI fully overlaps current one, delete current
					or fin_curr - fin_prev < 0.01 -- overlaps almost completely shy of 10 ms, delete because there'll be no way to shorten the AI or to split and keep that extra non-overlapped length of under 10 ms // same as len_curr - diff < 0.01
					then
					func(env, i, 'D_UISEL', 1, true) -- is_set true // select
					r.Main_OnCommand(42086, 0) -- Envelope: Delete automation items
					elseif len_curr - diff >= 0.1 then -- can be shortened via API since certainly won't get shorter than 100 ms
					func(env, i, 'D_POSITION', fin_prev, true) -- is_set true // shift rightwards
					func(env, i, 'D_LENGTH', len_curr-diff, true) -- is_set true // shorten
					func(env, i, 'D_STARTOFFS', startoffs_curr+diff*playrate, true) -- is_set true // shift contents leftwards so that it looks as if the AI start (pos) was cut off
					elseif diff >= 0.01 and fin_curr-fin_prev >= 0.01 -- // same as len_curr - diff >= 0.01
					then -- can't be shortened via API hence must be split provided the edit cursor can be placed farther than or at 0.01 from either edge of the AI; select, split with action, delete left hand part // action splits all selected AI crossed by the edit cursor so requires preemptive deselection of all, after split always selects right
					Trim_AI_By_Splitting(env, i, fin_prev)
					else -- the overlapped part is shorter than 10 ms which prevents splitting, hence lengthen the AI, shift left increasing the overlapped part to or to over 10 ms so it could be split and moving contents to original pos where they should end up after splitting
					local ext = 0.1-len_curr -- minimum length to which an AI shorter than 100 ms can be set is 100 ms
					func(env, i, 'D_LENGTH', len_curr+ext, true) -- is_set true // lengthen up to 100 ms
					func(env, i, 'D_POSITION', pos_curr-ext, true) -- is_set true // offset by shifting left by the same amount
					func(env, i, 'D_STARTOFFS', startoffs_curr-ext*playrate, true) -- is_set true // move contents rightwards by the same amount to restore their orig pos after split
					Trim_AI_By_Splitting(env, i, fin_prev)
					end
				end

			end -- AI loop end
		end -- env loop end
	end -- track loop end


r.SetEditCurPos(cur_pos, false, false) -- oveview, seekplay false // restore cur pos in case changed

	-- Restore AI selection
	for env in pairs(sel_AI_t) do
	local AI_cnt = r.CountAutomationItems(env)
		if AI_cnt == sel_AI_t[env][1] then -- if count didn't change in the interim
			for k, AI_idx in ipairs(sel_AI_t[env]) do -- restore AI selection
			local re_sel = k ~= 1 and r.GetSetAutomationItemInfo(env, AI_idx, 'D_UISEL', 1, true) -- is_set true // excluding 1st field because it holds total count
			end
		end
	end

end -- RESOLVE_AI_OVERLAPS() end


function Get_AI_At_Mouse_Cursor(env) -- returns AI index
local cur_pos = r.GetCursorPosition()
local x, y = r.GetMousePosition()
r.Main_OnCommand(40514, 0) -- View: Move edit cursor to mouse cursor (no snapping)
local pos_at_mouse = r.GetCursorPosition()
local AI
	for ai_idx = 0, r.CountAutomationItems(env)-1 do
	local start = r.GetSetAutomationItemInfo(env, ai_idx, 'D_POSITION', 0, false) -- is_set false, value 0
	local fin = start + r.GetSetAutomationItemInfo(env, ai_idx, 'D_LENGTH', 0, false) -- is_set false, value 0
		if start <= pos_at_mouse and fin >= pos_at_mouse then AI = ai_idx break end
	end
r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false // restore orig edit cursor pos
return AI
end


function Deselect_Points_In_Env_All_AIs1(tr_env, AI_idx) -- see version 2 below
	-- respecting points in full loop iteration incl. hidden
	for i = 0, r.CountEnvelopePointsEx(tr_env, AI_idx|0x10000000)-1 do
	r.SetEnvelopePointEx(tr_env, AI_idx, i, timeIn, valueIn, shapeIn, tensionIn, false, noSortIn) -- selectedIn false, deselect
	end
	-- only respecting visible points incl. all loop iterations
	for i = 0, r.CountEnvelopePointsEx(tr_env, AI_idx)-1 do
	r.SetEnvelopePointEx(tr_env, AI_idx, i, timeIn, valueIn, shapeIn, tensionIn, false, noSortIn) -- selectedIn false, deselect
	end
end
-- USE:
--[[
	for AI_idx = 0, r.CountAutomationItems(env)-1 do
	Deselect_Points_In_Env_All_AIs1(env, AI_idx)
	end
]]


function Deselect_Points_In_Env_All_AIs2(tr_env)
	for AI_idx = 0, r.CountAutomationItems(tr_env)-1 do
		-- respecting points in full loop iteration incl. hidden
		for i = 0, r.CountEnvelopePointsEx(tr_env, AI_idx|0x10000000)-1 do
		r.SetEnvelopePointEx(tr_env, AI_idx, i, timeIn, valueIn, shapeIn, tensionIn, false, noSortIn) -- selectedIn false, deselect // when setting 0x10000000 addition isn't needed
		end
		-- only respecting visible points incl. all loop iterations
		for i = 0, r.CountEnvelopePointsEx(tr_env, AI_idx)-1 do
		r.SetEnvelopePointEx(tr_env, AI_idx, i, timeIn, valueIn, shapeIn, tensionIn, false, noSortIn) -- selectedIn false, deselect
		end
	end
end


function Get_Props_Of_AI_Intersecting_Cur_Pos(env, cur_pos)
-- AI start is considered intersecting cursor while its end isn't
	for i = 0, r.CountAutomationItems(env)-1 do
	local pos = r.GetSetAutomationItemInfo(env, i, 'D_POSITION', -1, false) -- value -1, is_set false
	local fin = pos + r.GetSetAutomationItemInfo(env, i, 'D_LENGTH', -1, false) -- value -1, is_set false
		if pos <= cur_pos and fin > cur_pos then -- only AI start is considered belonging to AI
		return i, pos, fin
		end
	end

end


function Get_Props_Of_AI_Overlapping_Env_Pt(env, pt_pos)
	for i = 0, r.CountAutomationItems(env)-1 do
	local pos = r.GetSetAutomationItemInfo(env, i, 'D_POSITION', -1, false) -- value -1, is_set false
	local fin = pos + r.GetSetAutomationItemInfo(env, i, 'D_LENGTH', -1, false) -- value -1, is_set false
		if pos <= pt_pos and fin >= pt_pos then
		return i, pos, fin
		end
	end
end


function Get_AI_Env_Segment_At_Cursor(env, cur_pos, AI_idx)
-- returns indices of segment start and end points which then can be gotten with
-- r.GetEnvelopePointEx(env, AI_idx|0x10000000, i)
-- and set with r.SetEnvelopePointEx(env, AI_idx, i, timeIn, valueIn, shapeIn, tensionIn, true, noSortIn) -- here adding 0x10000000 isn't necessary
-- the routine can be re-purposed to getting AI point under cursor, within time selection or razor edit area

local st = r.GetSetAutomationItemInfo(env, AI_idx, 'D_POSITION', -1, false) -- value -1, is_set false
local len = r.GetSetAutomationItemInfo(env, AI_idx, 'D_LENGTH', -1, false)-- value -1, is_set false
local fin = st + len
local startoffs = r.GetSetAutomationItemInfo(env, AI_idx, 'D_STARTOFFS', -1, false) -- value -1, is_set false
local loop_len_QN = r.GetSetAutomationItemInfo(env, AI_idx, 'D_POOL_QNLEN', -1, false) -- value -1, is_set false
local playrate = r.GetSetAutomationItemInfo(env, AI_idx, 'D_PLAYRATE', -1, false) -- value -1, is_set false
local loop_len = r.TimeMap_QNToTime(loop_len_QN)/playrate -- convert to sec
local loop_cnt = len/loop_len < 1 and 1 or math.floor(len/loop_len) -- count number of loop iterations within AI length; only integer is required

-- calculate loop iteration which falls under the cursor,
-- if loop is disabled or AI length < one loop iteration, loop_iter var will be 0
local loop_iter
	for i=0,loop_cnt do
		if cur_pos >= st-startoffs+loop_len*i and cur_pos < fin
		then loop_iter = i
		end
	end

	-- look for segment points
	for i = 0, r.CountEnvelopePointsEx(env, AI_idx|0x10000000)-1 -- points in full loop iteration incl. hidden
	local retval, end_pos, val, shape, tens, sel = r.GetEnvelopePointEx(env, AI_idx|0x10000000, i) -- respecting points in full loop iteration incl. hidden
	end_pos = end_pos+loop_len*loop_iter -- offset by the number of loop iterations before the cursor retrieved above
		if not end_pt_idx and end_pos > cur_pos and end_pos <= fin then -- making sure that the end_pos is within view
		end_pt_idx, st_pt_idx = i, i-1
			if st_pt_idx > -1 then -- make sure that start point is within view
			local retval, st_pos, val, shape, tens, sel = r.GetEnvelopePointEx(env, AI_idx|0x10000000, st_pt_idx) -- respecting points in full loop iteration incl. hidden
			st_pos = st_pos+loop_len*loop_iter -- offset by the number of loop iterations before the cursor retrieved above
				if st_pos < st then
				end_pt_idx, st_pt_idx = nil -- reset as if the points weren't found
				end
			end
		break end
	end

return st_pt_idx, end_pt_idx

end



--=========================== A U T O M A T I O N  I T E M S  E N D ==========================


--================================= C H U N K ========================================

local function GetObjChunk1(retval, obj, obj_type) -- retval stems from r.GetFocusedFX(), value 0 is only considered at the pasting stage because in the copying stage it's error caught before the function
-- https://forum.cockos.com/showthread.php?t=193686
-- https://raw.githubusercontent.com/EUGEN27771/ReaScripts_Test/master/Functions/FXChain
-- https://github.com/EUGEN27771/ReaScripts/blob/master/Various/FXRack/Modules/FXChain.lua
	if not obj then return end
	if retval == 0 then retval = tonumber(obj_type) end -- for pasting stage when fx chains/floating windows are closed or not in focus
-- Try standard function -----
local t = retval == 1 and {r.GetTrackStateChunk(obj, '', false)} or {r.GetItemStateChunk(obj, '', false)} -- isundo = false // https://forum.cockos.com/showthread.php?t=181000#9
local ret, obj_chunk = table.unpack(t)
	if ret and obj_chunk and #obj_chunk >= 4194303 and not r.APIExists('SNM_CreateFastString') -- OR not r.SNM_CreateFastString
	then return 'err_mess'
	elseif ret and obj_chunk and #obj_chunk < 4194303 then return ret, obj_chunk -- 4194303 bytes (4.194303 Mb) = (4096 kb * 1024 bytes) - 1 byte // since build 4.20 http://reaper.fm/download-old.php?ver=4x
	end
-- If chunk_size >= max_size, use wdl fast string --
local fast_str = r.SNM_CreateFastString('')
	if r.SNM_GetSetObjectState(obj, fast_str, false, false) -- setnewvalue and wantminimalstate = false
	then obj_chunk = r.SNM_GetFastString(fast_str)
	end
r.SNM_DeleteFastString(fast_str)
	if obj_chunk then return true, obj_chunk end
end


local function GetObjChunk2(obj)
-- https://forum.cockos.com/showthread.php?t=193686
-- https://raw.githubusercontent.com/EUGEN27771/ReaScripts_Test/master/Functions/FXChain
-- https://github.com/EUGEN27771/ReaScripts/blob/master/Various/FXRack/Modules/FXChain.lua
	if not obj then return end
local t = {}
-- 'TrackEnvelope*' works for take envelope as well
	for k, typename in ipairs({'MediaTrack*', 'MediaItem*', 'TrackEnvelope*'}) do
	t[#t+1] = r.ValidatePtr(obj, typename)
	end
local tr, item, env = table.unpack(t)
-- Try standard function -----
local t = tr and {r.GetTrackStateChunk(obj, '', false)} or item and {r.GetItemStateChunk(obj, '', false)} or env and {r.GetEnvelopeStateChunk(obj, '', false)} -- isundo = false // https://forum.cockos.com/showthread.php?t=181000#9
local ret, obj_chunk = table.unpack(t)
-- OR
-- local ret, obj_chunk = table.unpack(tr and {r.GetTrackStateChunk(obj, '', false)} or item and {r.GetItemStateChunk(obj, '', false)} or env and {r.GetEnvelopeStateChunk(obj, '', false)} or {x,x}) -- isundo = false // https://forum.cockos.com/showthread.php?t=181000#9
	if ret and obj_chunk and #obj_chunk >= 4194303 and not r.APIExists('SNM_CreateFastString') -- OR not r.SNM_CreateFastString
	then return 'err_mess'
	elseif ret and obj_chunk and #obj_chunk < 4194303 then return ret, obj_chunk -- 4194303 bytes (4.194303 Mb) = (4096 kb * 1024 bytes) - 1 byte // since build 4.20 http://reaper.fm/download-old.php?ver=4x
	end
-- If chunk_size >= max_size, use wdl fast string --
local fast_str = r.SNM_CreateFastString('')
	if r.SNM_GetSetObjectState(obj, fast_str, false, false) -- setnewvalue and wantminimalstate = false
	then obj_chunk = r.SNM_GetFastString(fast_str)
	end
r.SNM_DeleteFastString(fast_str)
	if obj_chunk then return true, obj_chunk end
end



function Err_mess() -- if chunk size limit is exceeded and SWS extension isn't installed
local sws_ext_err_mess = "            The size of the data requires\n\n  the SWS/S&M extension to handle them.\n\nIf it's installed then it needs to be updated.\n\n         After clicking \"OK\" a link to the\n\n SWS extension website will be provided\n\n\tThe script will now quit."
local sws_ext_link = 'Get the SWS/S&M extension at\n\nhttps://www.sws-extension.org/\n\nOR\n\nhttps://github.com/reaper-oss/sws/tags'
local resp = r.MB(sws_ext_err_mess,'ERROR',0)
	if resp == 1 then r.ShowConsoleMsg(sws_ext_link, r.ClearConsole()) return end
end


local function SetObjChunk1(retval, obj, obj_type, obj_chunk) -- retval stems from r.GetFocusedFX(), value 0 is only considered at the pasting stage because in the copying stage it's error caught before the function
	if not (obj and obj_chunk) then return end
	if retval == 0 then retval = tonumber(obj_type) end -- for pasting stage when fx chains/floating windows are closed or not in focus
return retval == 1 and r.SetTrackStateChunk(obj, obj_chunk, false) or r.SetItemStateChunk(obj, obj_chunk, false) -- isundo is false // https://forum.cockos.com/showthread.php?t=181000#9
end


local function SetObjChunk2(obj, obj_chunk)
	if not (obj and obj_chunk) then return end
local t = {}
-- 'TrackEnvelope*' works for take envelope as well
	for k, typename in ipairs({'MediaTrack*', 'MediaItem*', 'TrackEnvelope*'}) do
	t[#t+1] = r.ValidatePtr(obj, typename)
	end
local tr, item, env = table.unpack(t)
return tr and r.SetTrackStateChunk(obj, obj_chunk, false) or item and r.SetItemStateChunk(obj, obj_chunk, false) or env and r.SetEnvelopeStateChunk(obj, obj_chunk, false) -- isundo is false // https://forum.cockos.com/showthread.php?t=181000#9
end


function Replace_GUIDs_in_Chunk(chunk)
	return chunk:gsub('{[%-%w]+}', function() return r.genGuid('') end)
end
-- OR
local fx_chunk = fx_chunk:gsub('{[%-%w]+}', function() return r.genGuid('') end) -- replace GUIDs making them unique



function Remove_Track_Chunk_By_Criteria(code, pattern)
-- from project file or track template content where ther're multiple track chunks
-- code is string contaning project file or track template content
-- pattern is string for string.match() function
-- to evaluate the chunk content, i.e.
-- '^%s*SHOWINMIX %d [%.%d]+ [%.%d]+ 0' -- for hidden track
-- '^%s*SEL 0' -- for selected track

local reassembled, chunk, criteria, item
local removed
	for line in code:gmatch('[^\n\r]+') do
		if line:match('^%s*<ITEM') then item = 1 end -- item is used to disambiguate track attributes from item atrributes which are likely to produce false positives otherwise, one such attribute is SEL
		if line:match(pattern) and not item then criteria = 1; removed = 1
		elseif criteria and line:match('^%s*<TRACK') then -- next track chunk has come along
		chunk = nil -- reset latest track chunk because it belongs to a non-selected track
		criteria = nil -- reset because new chunk has come along
		item = nil
		end
		if chunk and line:match('^%s*<TRACK') then -- next track chunk has come along
		reassembled = reassembled and reassembled..'\n'..chunk or chunk -- add to the rest of the chunks
		chunk = line -- restart chunk collection
		item = nil -- reset
		else
		chunk = chunk and chunk..'\n'..line or line
		end		
	end

-- if last track matches the criteria its chunk won't be reset within the loop
-- because line:match('^%s*<TRACK') condition for reset won't be met, so criteria 
-- var remains true in which case return reassembled right away;
-- if last track doesn't match the criteria its chunk won't be added to reassembled
-- within the loop likewise because line:match('^%s*<TRACK') condition won't be met
-- so add it inline;
-- if only one track is being saved the loop won't reach reassembled concatenation stage
-- hence fall back on chunk var whether valid or not, so may be nil if track matched
-- the criteria
return criteria and reassembled or reassembled and reassembled..'\n'..chunk or chunk, removed

end



function Remove_Chunks(file_path, chunk, want_items, want_envs)
-- removes item and envelope chunks
-- can be modified to include criteria by which these will be removed;
-- file_path and chunk args are mutually exclusive
-- while file_path has priority if both are valid;

	if not file_path and not chunk then return end

local t, chunk_start = {}

	-- collect the code to the exclusion of extended data
	for line in (file_path and io.lines(file_path) or chunk and chunk:gmatch('[^\r\n]*')) do -- or gmatch('(.-)\n') to capture empty lines
		if line:match('<EXTENSIONS') or line:match('<EXTSTATE') then break -- these, if any, come at the bottom of the .RPP file so ignore them
		elseif line:match('^%s*<TRACK') or chunk_start then -- track chunk start, in project file TRACK token is followed by GUID unlike in the track template, but that's immaterial
		chunk_start = 1
		t[#t+1] = line
		end
	end
	
	if want_items then -- weed out item chunks
	local item
		for k, line in ipairs(t) do
			if line:match('^%s*<TRACK') or k == #t then item = nil -- reset, k==#t ensures preservation of the last track block closure which is the last field in the table
			elseif (line:match('^%s*<ITEM') or item) -- in some track template files the <ITEM block start may not include the GUID as it doesn't in the project file
			and t[k+1] and not t[k+1]:match('^%s*<TRACK') then -- preventing deletion of the current track block closure if the next track block starts on the next line
			item = 1
			t[k] = ''
			items_removed = 1
			end
		end
	end
	
	if want_envs then -- weed out envelope chunks
	local env
		for k, line in ipairs(t) do
			if line:match('^%s*<.-ENV[%w]*%s*') or #line > 0 and env then -- ignoring empty fields from items loop, if any
			env = 1
			t[k] = ''
			env_removed = 1
			env = not line:match('^%s*>') -- if closure, reset, there're no nested blocks within envelope blocks so weeding them out is simple // ternary expression of 'env = line:match('^%s*>') and nil/false or env' to reset won't work because true env will always end up being selected and this will keep being true
			-- OR
			--	if line:match('^%s*>') then env = nil end
			end
		end
	end

-- remove empty lines, although works with them as long as blocks integrity is preserved
local length = #t -- store the original table length because it will get shorter during the loop
	for i = length, 1, -1 do
		if t[i] == '' then table.remove(t,i) end
	end

return table.concat(t,'\n') -- reconstruct

end



function Get_Take_Chunk(take, item)
-- item is optional
-- relies on Esc() function
local ret, GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- isset false
local item = item or r.GetMediaItemTake_Item(take)
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo false
local GUID = Esc(GUID)
local take_chunk, take = {}
	for line in chunk:gmatch('[^\n\r]+') do
		if take and line:match('^TAKE') then break -- new take has come along, if no next take the loop will continue until chunk and and the table will include item chunk closure which will be discarded below
		elseif not take and line and line:match('^NAME') or take then
		take = 1
		take_chunk[#take_chunk+1] = line
		elseif take and line:match('GUID') and not line:match(GUID) then 
		-- reset, wrong take
		take_chunk = {}
		take = nil
		end
	end
	if #take_chunk > 0 then
	local len = #take_chunk
		if take_chunk[len] == take_chunk[len-1] then -- the lines will be equal if both include block closure >, in which case the last closure will belong to item chunk so must be discared
		table.remove(take_chunk, len)
		end
	end
return #take_chunk > 0 and table.concat(take_chunk,'\n')
end


function Replace_Take_Chunks(item, take_chunk)
-- in this function empty take is replaced by a MIDI take chunk
-- can be repurposed

	local function update_guid(chunk)
	local chunk = chunk:gsub('E*GUID {.-}','GUID '..r.genGuid('')) -- update GUID, uncluding envelopes, so it's unique
	chunk = chunk:gsub('POOLEDEVTS {.-}','POOLEDEVTS '..r.genGuid('')) -- update pool GUID so it's unique, otherwise take copies will end up becoming pooled
	chunk = chunk:gsub('FXID {.-}','FXID '..r.genGuid(''))
	return chunk
	end

local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo false
local take_chunk = take_chunk:gsub('%%','%%%%') -- escape percent signs if any
chunk = chunk:gsub('TAKE NULL', function() return 'TAKE\n'..update_guid(take_chunk) end) -- unique GUIDs at each replacement cycle are only generated if replacement argument is a function
r.SetItemStateChunk(item, chunk)

end


function Collect_Take_Chunks(item)
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo false
local take_cnt = r.CountTakes(item)
local chunk_t = {chunk:match('(NAME[%W].-)'..string.rep('(TAKE[%W].-)', take_cnt-2)..'(TAKE[%W].+)>')} -- repeat as many times as take count -2 since first and last take chunks are different; [%W] makes sure that only 'TAKE' tag is captured disregarding words which contain it, of which there're a few, i.e. must be followed by anything but alphanumeric characters
	if #chunk_t == take_cnt then
	local last_take = chunk_t[#chunk_t]
		if last_take:match('.+>\n>') then -- if last take chunk includes item chunk closure, which it likely will, removed it
		chunk_t[#chunk_t] = last_take:sub(1,-3)
		end		
	return chunk_t
	end
end


-- see also Get_FX_Chain_Chunk and Get_FX_Chunk in F X


--================================= C H U N K  E N D ========================================


--===================================== R A Z O R  E D I T ======================================

function Re_Store_Razor_Edit_Areas(t)

--[[--only for storage as extended state
local sect = '(Re)Store Razor edit areas'
local slot = 'SLOT'..slot
]]
local tr_cnt = r.CountTracks(0)

	if not t then
	local t = {}
--	local data = ''
		for i=0, tr_cnt-1 do
		local tr = r.GetTrack(0,i)
		local retval, raz_edit = r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS_EXT', '', false) -- setNewValue false
		-- retval is always true as long as the param name is correct so unreliable
			if #raz_edit > 0 then
		--	data = data..tostring(tr)..':'..raz_edit..';' -- only for storage as extended state
			t[tostring(tr)] = raz_edit
			end
		end
	--[[ -- only relevant for storage as extended state
		if #data == 0 then
		Error_Tooltip('\n\n no razor edit areas to store \n\n', 1, 1) -- caps, spaced true
		return end
	r.SetExtState(sect, slot, data, false) -- persist false
	]]
	return t
	elseif t and next(t) then
	--[[ -- only relevant for storage as extended state
	local data = r.GetExtState(sect, slot)
		if #data == 0 then
		Error_Tooltip('\n\n no stored razor edit \n\n    areas in the slot \n\n', 1, 1) -- caps, spaced true
		end
	local t = {}
		for data in data:gmatch('(.-);') do
			if #data > 0 then
			local tr, raz_edits = data:match('(.+):'), data:match('.+:(.+)')
			t[tr] = raz_edits
			end
		end
	]]
		for i=0, tr_cnt-1 do
		local tr = r.GetTrack(0,i)
			if t[tostring(tr)] then
			r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS_EXT', t[tostring(tr)], true) -- setNewValue true
			end
		end

	end

end



function Parse_Razor_Edit_Data(data)
-- data is a string returned by 
-- r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS', '', false) -- setNewValue false
local t = {}
	for st, fin in data:gmatch('([%.%d]+) ([%.%d]+)') do
	t[#t+1] = {st, fin}
	end
return t
end


function Collect_Raz_Edit_Data(razor_edit)
-- razor_edit is a string returned by 
-- r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS', '', false) -- setNewValue false
local t = {env = {}, itm = {} }
	for area in raz_edit:gmatch('[%d%.]+ [%d%.]+ ".-"') do
		if area:match('{') then t.env[#t.env+1] = area -- envelope GUID is enclosed within quotes
		else
		t.itm[#t.itm+1] = area
		end
	end
return t
end


function Find_And_Remove_Raz_Edit_Overlaps(t1, t2, tr, raz_edit)
-- t1 contains raz edit areas which need removal
-- if overlapping raz edit areas contained in t2 table
-- razor_edit is a string returned by
-- r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS', '', false) -- setNewValue false
	for i=#t1, 1, -1 do
	local area = t1[i]
	local st, fin = area:match('([%d%.]+) ([%d%.]+)')
	local cntr = 0
		for _, itm_area in ipairs(t2) do
		local itm_area_st, itm_area_end = itm_area:match('([%d%.]+) ([%d%.]+)')
			if st < itm_area_st and fin <= itm_area_st
			or fin > itm_area_end and st >= itm_area_end
			then -- don't overlap
			cntr = cntr+1
			end
		end
		if cntr == #t2 then -- no overlaps found in t2 table, hence remove from t1 table because it won't have to be removed from razor edit data
		table.remove(t1,i)
		end
	end
	if #t1 > 0 then
		for _, area in ipairs(t1) do
		local area = Esc(area) -- escaping env GUID
		raz_edit = raz_edit:gsub(area, '')
		end
	r.GetSetMediaTrackInfo_String(tr, 'P_RAZOREDITS', raz_edit, true) -- setNewValue true
	end
end


--================================= R A Z O R  E D I T  E N D ===================================


--============================================ F X ===============================================

--[[
-- Summary of FX selection functions

-- applies equally to take FX functions

r.TrackFX_GetFloatingWindow(tr, fx_idx) -- helps to determine if fx is open in a floating window

r.TrackFX_GetOpen(tr, fx_idx)
true:
1. fx UI is shown in the open fx chain
2. fx UI is shown in a floating window regardless of being shown in fx chain and of fx chain visibility
false:
1. fx UI is not shown both in fx chain and in a floating window while fx chain is open
2. fx UI is not shown in a floating window while fx chain is closed

r.TrackFX_GetChainVisible(tr)
-- DOES NOT SUPPORT INPUT and MONITORING FX CHAINS, use Get_InputMonFX_Chain_Truely_SelectedFX()
>= 0 index of fx whose UI is shown in the open fx chain; !!!! returns index of selected fx even if its UI is open in a floating window
-1 the fx chain is closed
-2 the fx chain is open but is empty

r.TrackFX_SetOpen(tr, fx_idx, open)

1. open is false:
A. fx is floating - closes its floating window;
B. fx isn't floating regardless of its UI being shown fx chain - closes the fx chain;
2. open is true:
A. opens the fx chain with fx UI shown if fx chain was closed;
B. if fx chain is already open shows the fx UI in the fx chain if it wasn't shown

r.TrackFX_Show(tr, fx_idx, showFlag)

showFlag:
0 - hide chain
1 - show chain with fx UI shown
2 - close fx floating window
3 - open fx in a floating window

]]


function GetMonFXProps() -- get mon fx accounting for floating window, reaper.GetFocusedFX() doesn't detect mon fx in builds prior to 6.20

-- r.TrackFX_GetOpen(master_tr, integer fx)
	local master_tr = r.GetMasterTrack(0)
	local mon_fx_idx = r.TrackFX_GetRecChainVisible(master_tr)
	local is_mon_fx_float = false -- only relevant for pasting stage to reopen the fx in floating window
		if mon_fx_idx < 0 then -- fx chain closed or no focused fx -- if this condition is removed floated fx gets priority
			for i = 0, r.TrackFX_GetRecCount(master_tr) do
				if r.TrackFX_GetFloatingWindow(master_tr, 0x1000000+i) then
				mon_fx_idx = i; is_mon_fx_float = true break end
			end
		end
	return mon_fx_idx, is_mon_fx_float -- expected >= 0, true
end


local retval, track_num, item_num, fx_num = r.GetFocusedFX()
local mon_fx_idx = retval == 1 and track_num == 0 and fx_num >= 16777216
or retval == 0 and GetMonFXProps() >= 0 -- for builds older that 6.20 where GetFocusedFX() doesn't detect Monitor FX
local input_fx = retval == 1 and fx_num >= 16777216	-- since 6.20 covers both input and Mon FX // to differentiate track_num return value must be considered as above


function GetFocusedFX1() -- still must complemented with GetMonFXProps() below to get Mon FX in builds prior to 6.20 // see GetFocusedFX2() below
local retval, src_track_num, src_item_num, src_fx_num = r.GetFocusedFX()
-- Returns 1 if a track FX window has focus or was the last focused and still open, 2 if an item FX window has focus or was the last focused and still open, 0 if no FX window has focus. tracknumber==0 means the master track, 1 means track 1, etc. itemnumber and fxnumber are zero-based. If item FX, fxnumber will have the high word be the take index, the low word the FX index.
-- if take fx, item number is index of the item within the track (not within the project) while track number is the track this item belongs to, if not take fx src_item_num is -1, if retval is 0 the rest return values are 0 as well
-- if src_take_num is 0 then track or no object ??????

local tr = retval > 0 and (r.GetTrack(0,src_track_num-1) or r.GetMasterTrack()) -- will require adjustment if Mon FX should be supported as prior to build 6.20 Master track will have to be gotten even when retval is 0
local item = retval == 2 and r.GetTrackMediaItem(tr, src_item_num)
-- hight word is 16 bits on the left, low word is 16 bits on the right
local take_num, fx_num = src_fx_num>>16, src_fx_num&0xFFFF -- high word is right shifted by 16 bits (out of 32), low word is masked by 0xFFFF = binary 1111111111111111 (16 bit mask)
local take = retval == 2 and r.GetMediaItemTake(item, take_num)
local fx_num = retval == 2 and src_fx_num&0xFFFF or retval == 1 and src_fx_num -- take or track fx index (incl input/mon fx) // unlike in GetLastTouchedFX() input/Mon fx index is returned directly and need not be calculated // will require adjustment if Mon FX should be supported as prior to build 6.20 Mon FX will have to be gotten when retval is 0 as well
--	local mon_fx = retval == 0 and src_mon_fx_idx >= 0
--	local fx_num = mon_fx and src_mon_fx_idx + 0x1000000 or fx_num -- mon fx index

local fx_alias, fx_GUID
	if take then
	fx_GUID = r.TakeFX_GetFXGUID(take, fx_num)
	fx_alias = select(2, r.TakeFX_GetFXName(take, fx_num))
	elseif tr then
	fx_alias = select(2, r.TrackFX_GetFXName(tr, fx_num))
	fx_GUID = r.TrackFX_GetFXGUID(tr, fx_num)
	end

local fx_name, _ = fx_alias
-- if older version fx_name return value will be indentical to fx_alias
	if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.31 then
	local obj = take or tr
	local GetNamedConfigParm = take and r.TakeFX_GetNamedConfigParm or tr and r.TrackFX_GetNamedConfigParm
		if obj then
		_, fx_name = GetNamedConfigParm(obj, fx_num, 'fx_name')
		fx_name = fx_name:match('JS:') and fx_name:match('JS: (.+) %[') -- excluding path
		or fx_name:match('[VSTAUCLPDXi3]+:') and fx_name:match(': (.+)') or fx_name == 'Video processor' and fx_name
		end
	end

return retval, src_track_num-1, tr, src_item_num, item, take_num, take, fx_num, fx_alias, fx_name, fx_GUID -- src_track_num = -1 means Master;

end


function GetFocusedFX2() -- complemented with GetMonFXProps() to get Mon FX in builds prior to 6.20

	if not r.GetTouchedOrFocusedFX then -- older than 7.0

	local retval, tr_num, itm_num, fx_num = r.GetFocusedFX()
	-- Returns 1 if a track FX window has focus or was the last focused and still open, 2 if an item FX window has focus or was the last focused and still open, 0 if no FX window has focus. tracknumber==0 means the master track, 1 means track 1, etc. itemnumber and fxnumber are zero-based. If item FX, fxnumber will have the high word be the take index, the low word the FX index.
	-- if take fx, item number is index of the item within the track (not within the project) while track number is the track this item belongs to, if not take fx itm_num is -1, if retval is 0 the rest return values are 0 as well
	-- if src_take_num is 0 then track or no object ???????

	local mon_fx_num = GetMonFXProps() -- expected >= 0 or > -1

	local tr = retval > 0 and (r.GetTrack(0,tr_num-1) or r.GetMasterTrack()) or retval == 0 and mon_fx_num >= 0 and r.GetMasterTrack() -- prior to build 6.20 Master track has to be gotten even when retval is 0

	local item = retval == 2 and r.GetTrackMediaItem(tr, itm_num)
	-- high word is 16 bits on the left, low word is 16 bits on the right
	local take_num, take_fx_num = fx_num>>16, fx_num&0xFFFF -- high word is right shifted by 16 bits (out of 32), low word is masked by 0xFFFF = binary 1111111111111111 (16 bit mask); in base 10 system take fx numbers starting from take 2 are >= 65536
	local take = retval == 2 and r.GetMediaItemTake(item, take_num)
	local fx_num = retval == 2 and take_fx_num or retval == 1 and fx_num or mon_fx_num >= 0 and 0x1000000+mon_fx_num -- take or track fx index (incl. input/mon fx) // unlike in GetLastTouchedFX() input/Mon fx index is returned directly and need not be calculated // prior to build 6.20 Mon FX have to be gotten when retval is 0 as well // 0x1000000+mon_fx_num is equivalent to 16777216+mon_fx_num
	--	local mon_fx = retval == 0 and mon_fx_num >= 0
	--	local fx_num = mon_fx and mon_fx_num + 0x1000000 or fx_num -- mon fx index

	local obj = take or tr -- take is first to prevent false positive because when take is valid track is valid as well
		
		if obj then
		local GetFXName, GetFXGUID, GetIOSize, GetNamedConfigParm = table.unpack(take and {r.TakeFX_GetFXName, r.TakeFX_GetFXGUID, r.TakeFX_GetIOSize, r.TakeFX_GetNamedConfigParm} or tr and {r.TrackFX_GetFXName, r.TrackFX_GetFXGUID, r.TrackFX_GetIOSize, r.TrackFX_GetNamedConfigParm}) -- take is first to prevent false positive because when take valid track valud as well
		local fx_alias, fx_GUID = select(2, GetFXName(obj, fx_num)), GetFXGUID(obj, fx_num)		
		local fx_name, _ = fx_alias
		-- in builds older than 6.31 fx_name return value will be indentical to fx_alias
			if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.31 then
			local ret
			ret, fx_name = GetNamedConfigParm(obj, fx_num, 'fx_name')
			fx_name = fx_name:match('JS:') and fx_name:match('JS: (.+) %[') -- excluding path
			or fx_name:match('[VSTAUCLPDXi3]+:') and fx_name:match(': (.+)') or fx_name -- if Video processor
			end

		return retval, tr_num-1, tr, itm_num, item, take_num, take, fx_num, mon_fx_num >= 0, fx_alias, fx_name, fx_GUID -- tr_num = -1 means Master;
		end

	else -- supported since v7.0
	
	local retval, tr_num, itm_num, take_num, fx_num, parm_num = reaper.GetTouchedOrFocusedFX(1) -- 1 last touched mode // parm_num only relevant for querying last touched (mode 0) // supports Monitoring FX and FX inside containers, container itself can also be focused
	local tr = tr_num > -1 and r.GetTrack(0, tr_num) or retval and r.GetMasterTrack(0) -- Master track is valid when retval is true, tr_num in this case is -1
	local item = tr and r.GetTrackMediaItem(tr, itm_num)
	local take = item and r.GetTake(item, take_num)
	local obj = take or tr -- take is first to prevent false positive because when take is valid track is valid as well
	
		if obj then
		local GetFXName, GetFXGUID, GetIOSize, GetNamedConfigParm = table.unpack(take and {r.TakeFX_GetFXName, r.TakeFX_GetFXGUID, r.TakeFX_GetIOSize, r.TakeFX_GetNamedConfigParm} or tr and {r.TrackFX_GetFXName, r.TrackFX_GetFXGUID, r.TrackFX_GetIOSize, r.TrackFX_GetNamedConfigParm}) -- take is first to prevent false positive because when take valid track valud as well
		local fx_alias, fx_GUID, is_cont = select(2, GetFXName(obj, fx_num)), GetFXGUID(obj, fx_num), GetIOSize(obj, fx_num) == 8
		local ret, fx_name = GetNamedConfigParm(obj, fx_num, 'fx_name')
		fx_name = fx_name:match('JS:') and fx_name:match('JS: (.+) %[') -- excluding path
		or fx_name:match('[VSTAUCLPDXi3]+:') and fx_name:match(': (.+)') or fx_name -- if Video processor or Container

		local input_fx, cont_fx = tr and r.TrackFX_GetRecChainVisible(tr) ~= -1, fx_num >= 33554432 -- or fx_num >= 0x2000000 // fx_num >= 0x1000000 or fx_num >= 16777216 for input_fx gives false positives if fx is inside a container in main fx chain hence chain visibility evaluatiion
		local mon_fx = retval and tr_num == -1 and input_fx

		return retval, tr_num, tr, itm_num, item, take_num, take, fx_num, mon_fx, fx_alias, fx_name, fx_GUID, input_fx, cont_fx, is_cont -- tr_num = -1 means Master
		end
	end

end
-- USE:
-- local retval, tr_num, tr, itm_num, item, take_num, take, fx_num, mon_fx, fx_alias, fx_name, fx_GUID, is_input_fx, is_cont_fx, is_cont = GetFocusedFX2()
-- if retval == 0 and not mon_fx then return end -- no focused FX -- in versions older than 7.0;
-- not retval or not fx_name means no focused



function GetOrigFXName(obj_chunk, fx_GUID)

-- Get original FX name regardless of a custom plugin name assigned by the user which is returned by r.TrackFX_GetFXName()

-- SINCE 6.37 r.Track/TakeFX_GetNamedConfigParm() can be used, but keep in mind
-- https://forum.cockos.com/showthread.php?t=282139

local fx_GUID = fx_GUID:gsub('[%-]','%%%0') -- escape dashes for capture inside string.match below

		local t = {} -- split chunk into lines and save each to table
			for line in obj_chunk:gmatch('[^\n\r]*') do
			t[#t+1] = line
			end
		local k -- to reset or prevent its spilling over outside of this function
			for i = #t,1,-1 do -- parse from the end since GUID string follows the settings data block
				if t[i]:match(fx_GUID) then k = i end
				if k and k - i > 2 and t[i]:match('<') then fx_name_line = t[i] -- settings data block starts 2 lines above the GUID string, once plugin chunk top line is reached save it
				break end
			end
		local plug_type = fx_name_line:match('<([ACDJLPSTUVX]*)') -- all plugin types bar Video processor
		local fx_name
			if #plug_type > 1 and plug_type ~= 'JS' then fx_name = string.gsub(fx_name_line:match('<'..plug_type..' \"('..plug_type..'%w?: [^\"]*)'),'[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- VST, AU, DX, LV2 or CLAP, escape magic characters likely to appear in plugin names for evaluation against dest object chunks at pasting stage
			elseif #plug_type > 1 then fx_name = string.gsub(fx_name_line:match('<(JS [^\"]*)'),'[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- same, only gets file name, the plugins name must be retrieved either from 'desc:' tag inside the file or from reaper-jsfx.ini searching by the relative path
			end
		return fx_name or obj_chunk:match('Video processor')
end



function Get_Focused_FX_Orig_Name() -- regardless of a user custom name displayed in the FX chain; if non-JSFX plugin name was changed in the FX browser, then it's this name which will be retrieved since this is what's displayed in the chunk
-- relies on GetFocusedFX() and GetObjChunk() functions

-- SINCE 6.37 r.Track/TakeFX_GetNamedConfigParm() can be used, but keep in mind
-- https://forum.cockos.com/showthread.php?t=282139

-- non-JSFX plugin name changes in the FX browser are reflected in reaper-vstplugins(64).ini file
-- JSFX plugin names can't be changed in the FX browser but can in the NAME entries inside reaper-jsfx.ini
-- and then they will be reflected in the FX browser after restatring REAPER or refreshing the FX browser with F5

-- JSFX local to project are only displayed in the FX browser if the project is saved and aren't listed in reaper-jsfx.ini
-- <JS "<Project>/ReaperBlog_Macro Controller test.jsfx" "" // local fx chunk
-- JS: <Project>/ReaperBlog_Macro Controller test.jsfx // local fx fx chain name
-- for the local JSFX to load presets saved with its regular version, the presets file in the /presets folder must be duplicated and named js-_Project__(JSFX file name).ini

	if r.GetToggleCommandStateEx(0,40605) == 1 then return end -- Show action list // ignore FX if Action list window is open

	local function jsfx_exists(path, sep, name, type) -- evaluate if a JSFX exists in case it'd been removed before the FX browser was refreshed with F5 or REAPER restarted
		if type == 'JS' then
		local path = name:match('<Project>') and
		select(2,r.EnumProjects(-1)):match('(.+[\\/])')..'Effects'..sep..name:match('/(.+)')
		or path..sep..'Effects'..sep..(name:match('%[(.+)%]') or name:match('.+')) -- 2nd option if a non-local jsfx appearing in the chain isn't available, in which case only relative path is displayed either in the chain or in the chunk, without the fx name; EnumProjects() returns path even if the project file and possibly folder was deleted while the project is open
		return r.file_exists(path)
		else return true -- all other fx types exist by default
		end
	end


local retval, fx_name, fx_type -- retval just because fx_name must be made local as both are returned together, otherwise retval would end up being global; fx_type to limit Add_Remove_FX_Notes_Tag() to VST and JSFX plugins as cannot test AU/DX/LV2/CLAP (files reaper-auplugins_arm64-bc.ini, reaper-auplugins64-bc.ini, reaper-dxplugins64.ini)

	if r.GetToggleCommandStateEx(0, 40271) == 1 -- View: Show FX browser window // fx browser is open // the action adds last selected fx from the fx browser even when it's closed so must be additionally conditioned
	then -- Insert temporary track to insert FX and get FX props
	r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
	local temp_tr = r.GetTrack(0,r.CountTracks(0)-1)
	r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINMIXER', 0) -- hide in Mixer
	r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINTCP', 0) -- hide in Arrange
	r.TrackFX_AddByName(temp_tr, 'FXADD:1e', false, 0) -- recFX false
	retval, fx_name = r.TrackFX_GetFXName(temp_tr, 0, '')
	fx_type = fx_name:match('^[CPJLVSTAUDX]+') -- see explanation at the variable declaration above
	r.DeleteTrack(temp_tr)
	end

	if not fx_name or #fx_name == 0 then -- FX browser isn't open or open and no FX is selected, look for focused FX in FX chain and get its orig name from chunk because it can be renamed by the user in the fx chain // orig name in the chunk reflects name in reaper-vstplugins64.ini and reaper-jsfx.ini (NAME entry)
	local retval, tr_num, tr, itm_num, item, take_num, take, fx_num, mon_fx = get_focused_fx() -- tr_num = -1 means Master;
		if fx_num then
		local get_fx_GUID, obj = table.unpack((retval == 1 or retval == 0 and mon_fx) and {r.TrackFX_GetFXGUID, tr} or retval == 2 and {r.TakeFX_GetFXGUID, take})
		local fx_GUID = get_fx_GUID(obj, fx_num)
		local prev_fx_GUID = get_fx_GUID(obj, fx_num-1) or ''
		local ret, displayed_fx_name = table.unpack(retval == 2 and {r.TakeFX_GetFXName(obj, fx_num, '')} or (retval == 1 or retval == 0 and mon_fx) and {r.TrackFX_GetFXName(obj, fx_num, '')})
		-- Extract from chunk
		local obj = (retval == 1 or retval == 0 and mon_fx) and obj or r.GetMediaItemTake_Item(obj) -- since the next function needs item, not a take
		local ret, chunk = get_obj_chunk(obj)
			if ret == 'err_mess' then return 'err_mess' end
		local fx_chunk = mon_fx and get_mon_fx_chunk(fx_GUID, prev_fx_GUID) or get_fx_chunk(chunk, fx_GUID, prev_fx_GUID)
		fx_name = fx_chunk:match('BYPASS.-<[CPVSTAUDXL23i:]+ "(.-)" ')
		fx_type = fx_chunk:match('BYPASS.-<([CPJLVSTAUDX2]+)') -- see explanation at the variable declaration above
		local fx_file_name = fx_chunk:match('BYPASS.-<[CPVSTAUDXL23i:]+ ".-" "(.-)" ') or fx_chunk:match('BYPASS.-<[CPVSTAUDXL23i:]+ ".-" (.-) ') -- file name WITH or WITHOUT spaces
		-- in JSFX chunk only file relative path is displayed without the name defined at desc: tag in their code
		fx_name = fx_name
		or fx_chunk:match('BYPASS.-<JS "?(.-)" .-'..esc(displayed_fx_name)) -- displayed name with or without spaces; file path WITH spaces
		or fx_chunk:match('BYPASS.-<JS (.-) .-'..esc(displayed_fx_name)) -- displayed name with or without spaces; file path WITHOUT spaces
		or fx_chunk:match('BYPASS.-<JS "?(.-)"? ""') -- NO displayed name; file path with or without spaces
		or fx_chunk:match('BYPASS.-<VIDEO_EFFECT "(Video processor)"')

		-- Get JSFX which became unavailable during the session (before FX Browser was refreshed) to generate appropriate error message // if these were loaded into the fx chain after becoming unavailable no chunk data is stored for them, hence reliance on the displayed name is required // if they were renamed in the fx chain while being unavailable there's no way to retrieve their original type, name and path
		fx_type = fx_type or displayed_fx_name:match('^[CPJLVSTAUDX]+')
		fx_name = fx_name or displayed_fx_name:match('JS: %[(.+)%]') or displayed_fx_name:match('JS: (.+)') -- either regular or local
		end

	end


fx_name = fx_name and (fx_name:match('.+ %(n%) %[.-%]$') or fx_name:match('(.+) %(n%)')) or fx_name -- if there's notes tag ignore it, from JSFX it'll be removed in Create_Section_Title() function // option 1 is for JSFX since the tag is placed between the name and the path, option 2 is for other FX types

return fx_name and #fx_name > 0 and (fx_type == 'JS' and jsfx_exists(path, sep, fx_name, fx_type) or fx_type ~= 'JS') and fx_name, fx_type -- if JSFX, checking if file exists

end



function Retrieve_Orig_Plugin_Names(chunk) -- relies on GetObjChunk()
-- for non-JSFX plugins get name currently applied in the FX browser
-- which may differ from plugin original name
local t = {}
	for line in chunk:gmatch('[^\n\r]+') do
	local name = line and ( line:match('<.-"([ACDLPSTUVX23i:]+ .-)"') -- AU,CLAP,DX,LV2,VST
	or line:match('<JS "(.-)" ') or line:match('<JS (.-) ') -- spaces or no spaces in the path
	or line:match('<VIDEO_EFFECT "(Video processor)"') )
		if name then
			if line:match('<JS') then -- JSFX bank header will include the name from 'desc:' tag inside of the JSFX file and the file path or only the file path if the name couldn't be retrived
			local path = r.GetResourcePath()
			local sep = path:match('[\\/]') -- or package.config:sub(1,1)
				if name:match('<Project>') then -- JSFX local to the project only if project is saved; for the local JSFX to load presets its file in the /presets folder must be named js-_Project__(JSFX file name).ini
				local retval, proj_path = r.EnumProjects(-1) -- -1 active project; EnumProjects() returns path even if the project file and possibly folder was deleted while the project is open
				local proj_path = proj_path:match('.+[\\/]') -- excluding the file name // OR proj_path:match('.+'..Esc(r.GetProjectName(0, '')))
				local file_name = name:match('<Project>/(.+)')
				local path = proj_path and proj_path..'Effects'..sep..file_name -- proj_path includes the separator
					if path and r.file_exists(path) then
						for line in io.lines(path) do
						local name_local = line:match('^desc:') and line:match('desc:%s*(.+)') -- ignoring commented out 'desc:' tags if any // isolate name in this routine so that in case the actual name isn't found in the JSFX file the file name fetched from the chunk will be used
							if name_local then name = 'JS '..name_local..' ['..path..']' break end
						end
				--	else name = '' -- if wishing to exclude JSFX which has been deleted during the session without updating the FX browser or the FX chain // should be evaluated in Collect_FX_Preset_Names() with string length count
					end
				elseif r.file_exists(path..sep..'Effects'..sep..name) then -- JSFX at the regular location
				-- if JSFX name was changed in the plugin file but REAPER wasn't re-started
				-- or FX browser wasn't refreshed with F5, reaper-jsfx.ini will still contain the old name
					for line in io.lines(path..sep..'reaper-jsfx.ini') do
					local name_local = line and line:match(Esc(name)) and line:match('NAME.+ "(.+)"') -- name_local to prevent clash with name
						if name_local then name = name_local break end
					end
			--	else name = '' -- if wishing to exclude JSFX which has been deleted during the session without updating the FX browser or the FX chain // should be evaluated in Collect_FX_Preset_Names() with string length count
				end
			end
		t[#t+1] = name -- the table indexing must match FX indices in the FX chain so all must be collected with no skips
		end
	end
-- disable duplicate entries, will be evaluated in the preset extraction routine in Check_Selected_FX() and in Collect_FX_Preset_Names()
	for k1, v1 in pairs(t) do
		for k2, v2 in pairs(t) do -- pairs because the table will contain nils
			if v1 == v2 and k1 ~= k2 then
			t[k2] = nil -- keeping indices intact so that correspondence with fx indices in the FX chain is maintained
			end
		end
	end
return t
end



function Get_FX_Chain_Chunk(chunk, path, sep, type, take_GUID) -- isolate object fx chain, for track main fx chain exclude items/input fx, for track input fx exclude items, for items exclude takes other than the active one; type arg is set within the routine: 0 - track main fx, 1 - track input fx or Mon FX for the Master track; if take_GUID arg is valid, then take fx
-- since REAPER 7 'WAK 0 0' may be followed by PARALLEL 1 or PARALLEL 2 if 'Run selected FX in parallel with previous FX' or 'Run selected FX in parallel with previous FX (merge MIDI)' options are enabled respectively
-- due to introduction of FX containers in REAPER 7 'WAK 0 0' and 'PARALLEL X' tokens can be found in FX container chunk and the function may return incomlete chunk not having reached the end of the chain

local take_GUID = Esc(take_GUID)
local fx_chain_chunk

	if chunk and #chunk > 0 then
		if take_GUID then -- take fx chain
		fx_chain_chunk = chunk:match(take_GUID..'.-(<TAKEFX.->)\nTAKE') or chunk:match(take_GUID..'.-(<TAKEFX.->)\n<ITEM') or chunk:match(take_GUID..'.-(<TAKEFX.*>)\n>')
		else
			if type == 0 then -- track main fx chain
			fx_chain_chunk = chunk:match('(<FXCHAIN.*>)\n<FXCHAIN_REC') or chunk:match('(<FXCHAIN.->)\n<ITEM') or chunk:match('(<FXCHAIN.*WAK.*>)\n>')
			elseif type == 1 then -- track input fx chain
				if chunk:match('<FXCHAIN_REC') then -- regular track input fx
				fx_chain_chunk = chunk:match('(<FXCHAIN_REC.->)\n<ITEM') or chunk:match('(<FXCHAIN_REC.*WAK.*>)\n>')
				else -- monitor fx of the master track, extract fx chunk from reaper-hwoutfx.ini
				local f = io.open(path..sep..'reaper-hwoutfx.ini', 'r')
				fx_chain_chunk = f:read('*a')
				f:close()
				end
			end
		end
	end

return fx_chain_chunk

end



function Get_FX_Chunk(obj, obj_chunk, fx_idx, take_idx) 
-- obj is track or item pointer; 
-- if no take_idx arg is supplied, the active take will be used;
-- for track input FX and Mon FX fx_idx argument must look like 
-- fx_idx+0x1000000 or fx_idx+16777216; 
-- relies on Esc() function;
-- since REAPER 7 'WAK 0 0' may be followed by PARALLEL 1 or PARALLEL 2 
-- if 'Run selected FX in parallel with previous FX' 
-- or 'Run selected FX in parallel with previous FX (merge MIDI)' 
-- options are enabled respectively;
-- due to introduction of FX containers in REAPER 7 
-- 'WAK 0 0' and 'PARALLEL X' tokens can be found in FX container chunk 
-- and the function may return incomlete chunk 
-- not having reached the end of the chain

local track = r.ValidatePtr(obj, 'MediaTrack*')
local item = r.ValidatePtr(obj, 'MediaItem*')
local take = item and (take_idx and r.GetTake(obj, take_idx) or r.GetActiveTake(obj))

local GetFXGUID, GetIOSize = table.unpack(take and {r.TakeFX_GetFXGUID, r.TakeFX_GetIOSize} or {r.TrackFX_GetFXGUID, r.TrackFX_GetIOSize})

local obj = track and obj or take

local MON_FX = obj == r.GetMasterTrack(0) and fx_idx >= 16777216 -- OR 0x1000000
--[[ RELATED TO THE INEFFICIENT PART BELOW
local FXCHAINSEC = take and '<TAKEFX'
or fx_idx >= 0x1000000 and fx_idx < 0x2000000 and not MON_FX and '<FXCHAIN_REC' -- 0x2000000+ is the range of fx inside containers, fx inside containers in input fx chain don't start with <FXCHAIN_REC attribute
or ''
--]]

	if MON_FX then
	local path = r.GetResourcePath()
	local sep = r.GetResourcePath():match('[\\/]+') -- or package.config:sub(1,1)
	local f = io.open(path..sep..'reaper-hwoutfx.ini', 'r')
	obj_chunk = f:read('*a') -- not global so isn't accessible outside of the function
	f:close()
	end

local target_fx_GUID = obj and fx_idx and GetFXGUID(obj, fx_idx)

	if not target_fx_GUID then return end

--[[ INEFFICIENT
local prev_fx_GUID = obj and fx_idx and GetFXGUID(obj, fx_idx-1)

return prev_fx_GUID and target_fx_GUID and obj_chunk:match(FXCHAINSEC..'\n.-'..Esc(prev_fx_GUID)..'.-\n(BYPASS %d %d[%s%d]*.-'..Esc(target_fx_GUID)..'.-WAK.-)\n') or target_fx_GUID and obj_chunk:match(FXCHAINSEC..'.-\n(BYPASS %d %d[%s%d]*.-'..Esc(target_fx_GUID)..'.-WAK.-)\n') -- in older REAPER versions BYPASS only has 2 flags; originally the capture was ending with 'WAK %d %d', but was changed to accommodate possible expansion of flags in the future
]]


-- optionally conditioning pattern by fx container type instance 
-- if only the closing part of fx container chunk must be captured
-- i.e. from FLOATPOS onwards,
-- otherwise the captured part will include container portion of the chunk
-- starting from the data of the last fx instance and closing parts
-- if all child containers;
-- the choice depends on the task at hand
local fx_container = GetIOSize(obj, fx_idx) == 8
local patt = fx_container and '.+\n(FLOATPOS.-'..Esc(target_fx_GUID)..'.-WAK.-)\n' 
or '.+\n(BYPASS %d %d[%s%d]*.-'..Esc(target_fx_GUID)..'.-WAK.-)\n' -- in older REAPER versions BYPASS only has 2 flags; originally the capture was ending with 'WAK %d %d', but was changed to accommodate possible expansion of flags in the future

return obj_chunk:match(patt)

end



function Exclude_FX_Containers_From_Chunk(chunk)
-- leaves behind last lines not enclosed within closures
--[[
FLOATPOS 0 0 0 0
FXID {AEA25FBD-59F3-44A2-A727-28381E97FE24}
WAK 0 0
PARALLEL 1
]]

local opening_cnt, found = 0
local chunk_t = {}
	for line in chunk:gmatch('[^\n\r]+') do
		if line:match('^<CONTAINER') then
		found = 1
		opening_cnt = opening_cnt+1
		chunk_t[#chunk_t+1] = '<CONTAINER>' -- this is useful for accurate count of plugin indices via chunk with Collect_VideoProc_Instances() and Collect_VST3_Instances() below
		elseif found then
		opening_cnt = line:match('^<') and opening_cnt+1 or line:match('^>$') and opening_cnt-1 or opening_cnt
			if opening_cnt == 0 then found = nil end
		else
		chunk_t[#chunk_t+1] = line
		end
	end
return table.concat(chunk_t, '\n')
end



function Collect_VideoProc_Instances(fx_chain_chunk) -- fx chain chunk is obtained with Get_FX_Chain_Chunk()
-- to accurately count fx indices in fx chain
-- fx container data must be excluded from the chunk using Exclude_FX_Containers_From_Chunk(), see above

local video_proc_t = {} -- collect indices of video processor instances, because detection by fx name is unreliable as not all its preset names contain 'video processor' phrase due to length
local counter = 0 -- to store indices of video processor instances

	if fx_chunk and #fx_chunk > 0 then
		for line in fx_chunk:gmatch('[^\n\r]*') do -- all fx must be taken into account for video proc indices to be accurate
		local plug = line:match('<VST') or line:match('<AU')
		or line:match('<JS') or line:match('<DX')
		or line:match('<LV2') or line:match('<CLAP')
		or line:match('<VIDEO_EFFECT') or line:match('<CONTAINER')
			if plug then
				if plug == '<VIDEO_EFFECT' then
				video_proc_t[counter] = '' -- dummy value as we only need indices
				end
			counter = counter + 1
			end
		end
	end

return video_proc_t

end



function Collect_VST3_Instances(fx_chain_chunk) -- fx chain chunk is obtained with Get_FX_Chain_Chunk()// replicates Collect_VideoProc_Instances()
-- to accurately count fx indices in fx chain
-- fx container data must be excluded from the chunk using Exclude_FX_Containers_From_Chunk(), see above

-- required to get hold of .vstpreset file names stored in the plugin dedicated folder and list those in the menu

-- probably r.Track/TakeFX_GetNamedConfigParm() can be used instead since 6.37

local vst3_t = {} -- collect indices of vst3 plugins instances, because detection by fx name is unreliable as it can be changed by user in the FX browser
local counter = 0 -- to store indices of vst3 plugin instances

	if fx_chunk and #fx_chunk > 0 then
		for line in fx_chunk:gmatch('[^\n\r]*') do -- all fx must be taken into account for vst3 plugin indices to be accurate
		local plug = line:match('<VST') or line:match('<AU')
		or line:match('<JS') or line:match('<DX')
		or line:match('<LV2') or line:match('<CLAP')
		or line:match('<VIDEO_EFFECT') or line:match('<CONTAINER')
			if plug then
				if line:match('VST3') then
				vst3_t[counter] = '' -- dummy value as we only need indices
				end
			counter = counter + 1
			end
		end
	end

return vst3_t

end



function Collect_FX_Preset_Names(obj, src_fx_cnt, src_fx_idx, pres_cnt)
-- getting all preset names in a roundabout way by travesring them in an instance on a temp track
-- cannot traverse in the source track as if plugin parameters haven't been stored in a preset
-- after traversing they will be lost and will require prior storage and restoration whose accuracy isn't guaranteed

r.PreventUIRefresh(1)
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- insert new track at end of track list and hide it; action 40702 creates undo point
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0) -- hide in Mixer
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0) -- hide in Arrange

	if r.ValidatePtr(obj, 'MediaTrack*') then
	r.TrackFX_CopyToTrack(obj, src_fx_idx, temp_track, 0, false) -- is_move false // when copying FX envelopes don't follow, only when moving
	elseif r.ValidatePtr(obj, 'MediaItem_Take*') then
	r.TakeFX_CopyToTrack(obj, src_fx_idx, temp_track, 0, false) -- is_move false
	end

r.TrackFX_SetPresetByIndex(temp_track, 0, pres_cnt-1) -- start from the last preset in case user has a default preset enabled and advance forward in the loop below
local _, pres_cnt = r.TrackFX_GetPresetIndex(temp_track, 0)

local preset_name_t = {}

	for i = 1, pres_cnt do
	r.TrackFX_NavigatePresets(temp_track, 0, 1) -- forward
	local _, pres_name = r.TrackFX_GetPreset(temp_track, 0, '')
	preset_name_t[i] = pres_name..'|'
	end

r.DeleteTrack(temp_track)

r.PreventUIRefresh(-1)

	if src_fx_cnt > 1 then -- close submenu, otherwise no submenu
	table.insert(preset_name_t, #preset_name_t, '<')
	end

	if #preset_name_t > 0 and
	(#preset_name_t-1 == pres_cnt  -- one extra entry '<' if any
	or #preset_name_t == pres_cnt) -- when there's no submenu closure '<' because there's only one plugin in the chain
	then return preset_name_t end

end



local _, scr_name, scr_sect_ID, cmd_ID, _,_,_ = r.get_action_context()

function Re_Store_Plugin_Settings(obj, fx_idx, t, scr_cmd_ID) -- scr_cmd_ID is obtained with r.get_action_context()
-- if applied to focused fx then fx_idx must be obtained from custom GetFocusedFX2() function
local r = reaper
local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')
local GetNumParams, GetParam, SetParam = table.unpack(tr and {r.TrackFX_GetNumParams, r.TrackFX_GetParam, r.TrackFX_SetParam} or take and {r.TakeFX_GetNumParams, r.TakeFX_GetParam, r.TakeFX_SetParam} or {nil})
local parm_list = r.GetExtState(scr_cmd_ID, 'PARM_LIST')

	if not t and parm_list == '' then -- store
	local t = {}
		for parm_idx = 0, GetNumParams(obj, fx_idx)-1 do
		local retval, minval, maxval = GetParam(obj, fx_idx, parm_idx)
		t[#t+1] = retval
		end
	-- setting ext state allows restoration on the second script run rather than within one run
	r.SetExtState(scr_cmd_ID, 'PARM_LIST', table.concat(t, ';'), false) -- persist false
	return t
	elseif t or parm_list ~= '' then -- restore
	local t = t or (function(parm_list)-- if restoring on second run in which case the t will be nil // function in place
					local t = {}
						for parm_val in parm_list:gmatch('[^;]+') do
						t[#t+1] = parm_val
						end
					return t
					end)(parm_list)

		for parm_idx = 0, GetNumParams(obj, fx_idx)-1 do
		SetParam(obj, fx_idx, parm_idx, t[parm_idx+1])
		end
		if parm_list ~= '' then -- if restored at subsequent script runs
		local resp = r.MB('Keep the stored settings?', 'PROMPT', 4)
		local del = resp == 7 and r.DeleteExtState(scr_cmd_ID, 'PARM_LIST', true) -- persist true
		else -- if restored within the same script run
		r.DeleteExtState(scr_cmd_ID, 'PARM_LIST', true) -- persist true
		end

	end

end



function Select_FX_UI_in_FXChain(object, take_idx, fx_idx, want_input_mon_fx)
-- mainly keeping FX chain closed, but if it's open keeps it open
-- another method of doing that is via chunk, won't work for Monitor FX as from chunk they
-- can only be updated by restarting REAPER

-- r.PreventUIRefresh(1) -- doesn't prevent a short FX chain flick
local master = r.GetMasterTrack(0) == object
local tr = r.ValidatePtr(object, 'MediaTrack*')
local take = r.ValidatePtr(object, ' MediaItem_Take*')
local item = r.ValidatePtr(object, ' MediaItem*')
	if (master or tr) and fx_idx then
	local fx_idx = want_input_mon_fx and 0x1000000+fx_idx or fx_idx
	r.TrackFX_SetOpen(object, fx_idx, true) -- open true; open fx UI and fx chain
--	r.TrackFX_Show(object, fx_idx, 3) -- showFlag 3 show floating window // doesn't make FX UI selected in the chain
	local is_vis = want_input_mon_fx and r.TrackFX_GetRecChainVisible(object) or r.TrackFX_GetChainVisible(object)
	local close = is_vis ~= -1 and r.TrackFX_Show(object, fx_idx, 0) -- showFlag 0 hide chain // if FX chain is open and then gets closed the switch to the desired FX UI doesn't occur; so keep open if the chain is already open
	elseif (item or take) and fx_idx then
	local object = take and object or item and take_idx and r.GetTake(object, take_idx) or item and r.GetActiveTake(object)
	local open = object and r.TakeFX_SetOpen(object, fx_idx, true) -- open true; open fx UI and fx chain
--	r.TakeFX_Show(object, fx_idx, 3) -- showFlag 3 show floating window // doesn't make FX UI selected in the chain
	local is_vis = object and r.TakeFX_GetChainVisible(object)
	local close = is_vis ~= -1 and r.TakeFX_Show(object, fx_idx, 0) -- showFlag 0 hide chain // if FX chain is open and then gets closed the switch to the desired FX UI doesn't occur; so keep open if the chain is already open
	end
-- r.PreventUIRefresh(-1) -- doesn't prevent a short FX chain flick

end



function GetLastTouchedFX1() -- means last even if no longer focused // Mon FX aren't supported by the API function
-- Returns true if the last touched FX parameter is valid, false otherwise.
-- Always returns true as long as FX was touched at least once during a session and that FX is still present, unless the edit cursor is over an item or a TCP
-- To make RS5k last touched its parameter must be changed whereas in plugins with sliders a touch of a slider siffices,
-- could be bacause of a float value change invisible in the UI
--The low word of tracknumber is the 1-based track index -- 0 means the master track, 1 means track 1, etc. If the high word of tracknumber is nonzero, it refers to the 1-based item index (1 is the first item on the track, etc). For track FX, the low 24 bits of fxnumber refer to the FX index in the chain, and if the next 8 bits are 01, then the FX is record FX. For item FX, the low word defines the FX index in the chain, and the high word defines the take number.
-- https://stackoverflow.com/questions/10493411/what-is-bit-masking
-- hight word is 16 bits on the left, low word is 16 bits on the right
local is_last_touched, src_track_num, src_fx_num, src_param_num = r.GetLastTouchedFX() -- doesn't support Mon FX
local track_num = src_track_num&0xFFFF -- low word (16 bits out of 32) masked by 0xFFFF = 1111111111111111 (16 set bits) in binary; 0 master, > 0 regular
local tr = track_num == 0 and r.GetMasterTrack(0) or r.GetTrack(0,track_num-1)
local item_num = src_track_num>>16 -- high word (16 bits out of 32) right shifted; item in track, 1 based
local item = item_num >= 1 and r.GetTrackMediaItem(tr, item_num-1)
local fx_num_tr = src_fx_num&0xFFFFFF -- low 24 bits (out of 32) masked by 0xFFFFFF = 111111111111111111111111 (24 set bits) in binary, fx idx
local is_input_fx = src_fx_num>>24 == 1 -- right shift by 24 bits to only leave 8 high bits intact
local fx_num_take = src_fx_num&0xFFFF -- low word (16 bits out of 32) masked as above // 0 based
local fx_num = item and src_fx_num&0xFFFF or is_input_fx and fx_num_tr+0x1000000 or fx_num_tr -- unlike in GetFocusedFX() input/Mon fx index isn't returned directly and must be calculated
local take_num = item and src_fx_num>>16 -- high word (16 bits out of 32) right shifted as above // 0 based
local take = item and r.GetTake(item, take_num)
return is_last_touched, track_num-1, tr, item_num-1, item, take_num, take, fx_num, src_param_num -- indices are 0 based; track_num = -1 means Master; item_num = -1 or take_num or take = false means not take FX
end
-- EXAMPLE:
-- is_last_touched, track_num, tr, item_num, item, take_num, take, fx_num, parm_num = GetLastTouchedFX()



function GetLastTouchedFX2() -- DOESN'T SUPPORT Monitoring FX since native GetLastTouchedFX() doesn't support them
-- Always returns true as long as FX was touched at least once during a session and that FX is still present, unless the edit cursor is over an item or a TCP
-- To make RS5k last touched its parameter must be changed whereas in plugins with sliders a touch of a slider siffices,
-- could be bacause of a float value change invisible in the UI
-- returns false if the last touched parameter is invalid
-- 131072 = binary 0100000000000000000, hex 20000, 65536*2, 0xFFFF*2
-- 0xFFFF = binary 0001111111111111111, decimal 65536

local is_last_touched, tr_bitfield, fx_bitfield, parm_idx = r.GetLastTouchedFX()

	if is_last_touched then
	local item_idx = tr_bitfield>>16 > 0 and tr_bitfield>>16 -- If the high word of tr_bitfield is nonzero, it refers to the 1-based item index (1 is the first item on the track, etc)
	local tr_idx = tr_bitfield&0xFFFF or -1 -- The low word of tr_bitfield is the 1-based track index -- 0 means the master track, 1 means track 1, etc // 0xFFFF = binary 1111111111111111 (16 bit mask) // 'or -1' to simplify next expression
	local tr = tr_idx == 0 and r.GetMasterTrack(0) or tr_idx > 0 and r.GetTrack(0, tr_idx-1)
	local item = item_idx and r.GetTrackMediaItem(tr, item_idx-1)
	local fx_idx = item and fx_bitfield&0xFFFF or tr and fx_bitfield&0xFFFFFF -- For item FX, the low word of fx_bitfield defines the FX index in the chain; For track FX, the low 24 bits of fx_bitfield refer to the FX index in the chain, and if the next 8 bits are 01, then the FX is record FX; 0xFFFF = binary 1111111111111111 = dec 65535 (16 bit mask), 0xFFFFFF = binary 111111111111111111111111 = dec 16777215 (24 bit mask); each hexadecimal digit stands for four bits
	local fx_idx = tr and fx_bitfield>>24 == 01 and fx_idx+0x1000000 or fx_idx -- For track FX if the next (high) 8 bits are 01, then the FX is record FX // to get high 8 bits of a 32 bit number it must be shifted 24 bits rightwards
	local take_idx = item and fx_bitfield>>16 -- For item FX, the high word defines the take number
	local take = take_idx and r.GetTake(item, take_idx)
	return is_last_touched, tr_idx == -1 and tr_idx or tr_idx-1, tr, item_idx and item_idx-1, item, take_idx, take, fx_idx, parm_idx -- tr_idx -1 is Master track; item_idx is index on a track
	end

end
-- EXAMPLE:
-- is_last_touched, tr_idx, tr, item_idx, item, take_idx, take, fx_idx, parm_idx = GetLastTouchedFX()



function Collect_FX_Output_Data(tr) -- fx index and output channels // blueprint of dealing with output channels
-- since version 7, 128 channels per track are supported, the function only respects 64
-- this function is tailored for RS5k
local t, rs5k_cnt = {}, 0
	for fx_idx = 0, r.TrackFX_GetCount(tr)-1 do
	local RS5k
		for parm_idx = 0, r.TrackFX_GetNumParams(tr, fx_idx)-1 do
		local retval, parm_name = r.TrackFX_GetParamName(tr, fx_idx, parm_idx, '')
			if parm_name == 'Gain for minimum velocity' then RS5k = 1 break end
		end
		if RS5k then -- condition which limits the function to RS5k
		rs5k_cnt = rs5k_cnt+1
		t[fx_idx+1] = {} -- storing 1-based fx index as key
		local tr_ch_cnt = r.GetMediaTrackInfo_Value(tr, 'I_NCHAN')
			for ch_idx = 0, tr_ch_cnt-1 do
			-- thanks to MPL and EUGEN
			-- https://forum.cockos.com/showthread.php?t=233640
			-- https://github.com/EUGEN27771/ReaScripts/blob/master/FX/gen_TrackFX%20Routing%20Matrix.lua
			-- isoutput value must be > 0 throughout, it doesn't represent actual output index, seem to function as a boolean
			-- pin is the horizonal row of checkboxes, 2 for each output, 0-based
			-- high32 bits become grater than 0 starting with channel 33 (1-based), at this stage low32 bits become 0, channel count restarts from 1; so there're 1-32 channels (1-based) for low 23 bits and 1-32 channels for high 32 bits
			local lo32pin1, hi32pin1 = r.TrackFX_GetPinMappings(tr, fx_idx, 1, 0) -- isoutput 1, pin 0
			local lo32pin2, hi32pin2 = r.TrackFX_GetPinMappings(tr, fx_idx, 1, 1) -- isoutput 1, pin 1
				local function select_bitfield(ch_idx, lo32, hi32)
				return ch_idx <= 31 and lo32 or hi32
				end
			local bitmask = ch_idx <= 31 and 2^ch_idx or 2^(ch_idx-32) -- restart channel count for high 32 bits
			local bitfield1, bitfield2 = select_bitfield(ch_idx, lo32pin1, hi32pin1), select_bitfield(ch_idx, lo32pin2, hi32pin2)
			local pin1_ch, pin2_ch = bitfield1&bitmask==bitmask and ch_idx+1, bitfield2&bitmask==bitmask and ch_idx+1 -- using 1-based channel indices
			local ch_t = pin1_ch and pin2_ch and (pin1_ch ~= pin2_ch and {pin1_ch, pin2_ch} or {pin1_ch}) or pin1_ch and {pin1_ch} or pin2_ch and {pin2_ch} -- in theory both pins can point at the same channel hence both are evaluated for each channel
				if ch_t then
				local len = #t[fx_idx+1] -- for legibility and brevity
					for _, ch in ipairs(ch_t) do
					t[fx_idx+1][len+1] = ch
					end
				end
			end
		end
	end
return t, rs5k_cnt
end



function Is_TrackFX_Open(obj, fx_index) -- open in the fx chain and in a floating window
local tr = r.ValidatePtr(obj, 'MediaTrack*')
local take = r.ValidatePtr(obj, 'MediaItem_Take*')
local GetCount, GetOpen, GetFloatingWindow = table.unpack(take and {r.TakeFX_GetCount, r.TakeFX_GetOpen, r.TakeFX_GetFloatingWindow} or tr and {r.TrackFX_GetCount, r.TrackFX_GetOpen, r.TrackFX_GetFloatingWindow})
return GetOpen(obj, fx_index), GetFloatingWindow(obj,fx_index)
--[[-- not clear why i used this // this is useful when searching if there're ANY fx selected in the chain and/or open in floating window
	if tr or take then
		for fx_idx = 0, GetCount(obj)-1 do
			if GetOpen(obj, fx_idx) and fx_idx == fx_index then
			return true, GetFloatingWindow(obj,fx_index)
			end
		end
		if tr then
			for fx_idx = 0, r.TrackFX_GetRecCount(tr)-1 do
				if r.TrackFX_GetOpen(tr, fx_idx+0x1000000) and fx_idx+0x1000000 == fx_index then
				return true, GetFloatingWindow(obj,fx_index)
				end
			end
		end
	end
	]]
end



function Count_FX(sel_trk_cnt, sel_itms_cnt)
-- Count all FX in selected objects to determine if FX were added
-- provided destination objects were initially empty
-- idea borrowed from MPL's 'Open FX browser and close FX browser when FX is inserted.lua'
local fx_cnt = 0
	if sel_trk_cnt > 0 then
		for i = 0, sel_trk_cnt-1 do
		local tr = r.GetSelectedTrack(0,i) or r.GetMasterTrack(0)
		fx_cnt = fx_cnt + r.TrackFX_GetCount(tr) + (TRACK_INPUT_MON_FX and r.TrackFX_GetRecCount(tr))
		end
	end
	if sel_itms_cnt > 0 then
		for i = 0, sel_itms_cnt-1 do
		local take = r.GetActiveTake(r.GetSelectedMediaItem(0,i))
		fx_cnt = fx_cnt + r.TakeFX_GetCount(take)
		end
	end
	return fx_cnt
end



function Get_FX_Env_Src_Parameter(env) -- get fx parameter the envelope belongs to
local tr = r.GetEnvelopeInfo_Value(env, 'P_TRACK') -- if take env is selected returns 0.0, otherwise pointer
local take = r.GetEnvelopeInfo_Value(env, 'P_TAKE') -- if track env is selected returns 0.0, otherwise pointer
local tr, take = tr ~= 0 and tr, take ~= 0 and take -- validate
local retval, env_name = r.GetEnvelopeName(env)
-- capture fx name displayed in the fx chain, fx env name format is 'parm name / fx name'
local fx_name = env_name:match('.+ / (.+)') -- clean name, without the plugin type prefix
local cur_val, minval, maxval, step
local CountFX, GetFXName, GetNumParams, GetFXEnvelope, GetFXParam, GetParamStepSizes = table.unpack(tr and {r.TrackFX_GetCount, r.TrackFX_GetFXName, r.TrackFX_GetNumParams, r.GetFXEnvelope, r.TrackFX_GetParam, r.TrackFX_GetParameterStepSizes} or take and {r.TakeFX_GetCount, r.TakeFX_GetFXName, r.TakeFX_GetNumParams, r.TakeFX_GetEnvelope, r.TakeFX_GetParam, r.TakeFX_GetParameterStepSizes})
local obj = take or tr
	for fx_idx = 0, CountFX(obj)-1 do
	local retval, name = GetFXName(obj, fx_idx)
		if name:match(': (.+) %(') == fx_name or name == fx_name then -- either default or custom plugin name
			for parm_idx = 0, GetNumParams(obj, fx_idx)-1 do
		--	local retval, parm_name = r.TrackFX_GetParamName(tr, fx_idx, parm_idx, '')
			local parm_env = GetFXEnvelope(obj, fx_idx, parm_idx, false) -- create false
				if parm_env == env -- and parm_name == env_name:match('(.+) /')
				then
				local cur_val, minval, maxval = GetFXParam(obj, fx_idx, parm_idx)
				local retval, step, smallstep, largestep, istoggle = GetParamStepSizes(obj, fx_idx, parm_idx) -- if no step retval is false
				return cur_val, minval, maxval, step ~= 0 and step
				end
			end
		end
	end

end



function Get_FX_Type(obj, fx_idx)
-- https://forum.cockos.com/showthread.php?t=277103
local plug_types_t = {[0] = 'DX', [1] = 'LV2', [2] = 'JSFX', [3] = 'VST',
[4] = '', [5] = 'AU', [6] = 'Video processor', [7] = 'CLAP', [8] = 'Container'}
local GetIOSize = obj and (r.ValidatePtr(obj, 'MediaItem_Take*') and r.TakeFX_GetIOSize
or r.ValidatePtr(obj, 'MediaTrack*') and r.TrackFX_GetIOSize)
	if GetIOSize then
	local plug_type, inputPins_cnt, outputPins_cnt = GetIOSize(obj, fx_idx)
	return plug_types_t[plug_type]
	end
end



function Check_FX_In_Focused_FX_Chain(take, track, fx_idx) -- whether any plugin contains presets
-- take is evaluated first because if take is true track is true as well
-- fx_idx is used to condition targeting input/Monitoring fx since their index format is different
local GetCount, GetPresetIndex, GetFXName = table.unpack(take and {r.TakeFX_GetCount, r.TakeFX_GetPresetIndex, r.TakeFX_GetFXName} or track and {fx_idx < 16777216 and r.TrackFX_GetCount or r.TrackFX_GetRecCount, r.TrackFX_GetPresetIndex, r.TrackFX_GetFXName} or {})
local obj = take or track
local fx_cnt = GetCount(obj)
local fx_list, valid_fx_cnt, _129 = '', 0
	if obj then
		for idx = 0, fx_cnt-1 do
		local idx = fx_idx < 16777216 and idx or 16777216+idx -- or 0x1000000+idx, input/monitoring fx
		local retval, pres_cnt = GetPresetIndex(obj, idx)
		_129 = pres_cnt > 128 and 1 or _129 -- verifying if any of the plugins contains more than 128 presets
			if pres_cnt > 0 then -- retval > -1 // only names of pluguns with presets are stored
			valid_fx_cnt = valid_fx_cnt+1
			local ret, name = GetFXName(obj, idx, '')
				if not fx_list:match(Esc(name)) then -- only collect unique names excluding duplicates, i.e. one instance per plugin
				fx_list = fx_list..'\n'..name
				end
			end
		end
	end

	if fx_cnt > 0 and #fx_list == 0 then
	r.MB('No presets in FX of the focused FX chain.', 'ERROR', 0)
	end
return fx_list:sub(2), valid_fx_cnt, _129 -- removing leading line break from fx_list
end



function Check_If_FX_Selected_In_FX_Browser1()

r.PreventUIRefresh(1)
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false // insert new track at end of track list and hide it
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0)
r.TrackFX_AddByName(temp_track, 'FXADD:', false, -1)
local fx_list
	if r.TrackFX_GetCount(temp_track) == 0 then
	r.MB('No FX have been selected in the FX browser.', 'ERROR', 0)
	else
	fx_list = ''
		for i = 0, r.TrackFX_GetCount(temp_track)-1 do
		fx_list = fx_list..'\n'..select(2,r.TrackFX_GetFXName(temp_track, i, ''))
		end
	end
r.DeleteTrack(temp_track)
r.PreventUIRefresh(-1)
return fx_list:sub(3) -- removing leading line break // mainly for display in a prompt

end



function Check_FX_Selected_In_FX_Browser2() -- whether any is selected and whether at least 1 contains presets using temporary track

r.PreventUIRefresh(1)

r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false // insert new track at end of track list and hide it
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0)
r.TrackFX_AddByName(temp_track, 'FXADD:', false, -1)
local fx_cnt = r.TrackFX_GetCount(temp_track)
local fx_list, valid_fx_cnt, _129 = '', 0

	for i = 0, fx_cnt-1 do
	local retval, pres_cnt = r.TrackFX_GetPresetIndex(temp_track, i)
	valid_fx_cnt = pres_cnt > 0 and valid_fx_cnt+1 or valid_fx_cnt
	_129 = pres_cnt > 128 and 1 or _129 -- verifying if any of the plugins contains more than 128 presets
		if r.TrackFX_SetPresetByIndex(temp_track, i, 0) -- preset idx 0 -- returns true on success // check if there're presets // admissible on a temporary track but not in the actual focused FX chain which will mess up preset selection
	--	local retval, pres_cnt = r.TrackFX_GetPresetIndex(temp_track, i) -- preset count could be used as a condition // safe, suitable for all cases
		then
		fx_list = fx_list..'\n'..select(2,r.TrackFX_GetFXName(temp_track, i, ''))
		end
	end

r.DeleteTrack(temp_track)
r.PreventUIRefresh(-1)

local err = fx_cnt == 0 and 'No FX have been selected in the FX browser.' or fx_cnt > 0 and #fx_list == 0 and 'No presets in selected FX'
	if err then
	r.MB(err, 'ERROR', 0)
	end

return fx_list:sub(2), valid_fx_cnt, _129 -- removing leading line break from fx_list

end


-- TWO ABOVE COMBINED
function Check_Selected_FX(take, track, fx_idx) -- presence of arguments makes the function target the focused FX chain, otherwise selected plugins in the open FX browser are targeted, uses temporary track // -- relies on GetObjChunk() and Retrieve_Orig_Plugin_Names() see below

r.PreventUIRefresh(1)
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- insert new track at end of track list and hide it; action 40702 creates undo point
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0) -- hide in Mixer
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0) -- hide in Arrange

-- Copy FX from the source track/take/FX browser to the temporary track

	if fx_idx then -- only copy if arguments are provided, without arguments instantiated from FX browser below
	-- take is evaluated first because if take is true track is true as well
	local GetFXCount, CopyToTrack = table.unpack(take and {r.TakeFX_GetCount, r.TakeFX_CopyToTrack} or track and {fx_idx < 16777216 and r.TrackFX_GetCount or r.TrackFX_GetRecCount, r.TrackFX_CopyToTrack} or {})
	local obj = take or track
		for idx = 0, GetFXCount(obj)-1 do
		local src_idx = fx_idx < 16777216 and idx or 16777216+idx -- or 0x1000000+idx, input/monitoring fx
		CopyToTrack(obj, src_idx, temp_track, idx, false) -- is_move false // when copying FX envelopes don't follow, only when moving
		end
	else
	r.TrackFX_AddByName(temp_track, 'FXADD:', false, -1) -- recFX false, instantiate -1: specify a negative value for instantiate to always create a new effect
	end

local ret, chunk = GetObjChunk(temp_track)
local plugin_name_t = chunk and #chunk > 0 and Retrieve_Orig_Plugin_Names(chunk) -- to pevent error because when ret == 'err_mess' chunk isn't returned by GetObjChunk()
local fx_cnt = r.TrackFX_GetCount(temp_track)
local fx_list, valid_fx_cnt, _129 = '', 0

	-- Collect FX instances names, excluding duplicate plugin instances
	for fx_idx = 0, fx_cnt-1 do
	local retval, pres_cnt = r.TrackFX_GetPresetIndex(temp_track, fx_idx)
		if pres_cnt > 0 then
		local ret, fx_name = r.TrackFX_GetFXName(temp_track, fx_idx, '')
		local fx_name = (not plugin_name_t or plugin_name_t[fx_idx+1]) and '\n'..fx_name or '' -- if original names weren't retrieved from the chunk and so duplicates weren't filtered inside Retrieve_Orig_Plugin_Names() use all displayed names, it were retrieved only use names of unique instances, duplicates will have been set to nil in the plugin_name_t table
		valid_fx_cnt = #fx_name > 0 and valid_fx_cnt+1 or valid_fx_cnt -- counting plugins with presets only honoring unique instances
		_129 = #fx_name > 0 and pres_cnt > 128 and 1 or _129 -- verifying if any of the unique instances contains more than 128 presets
		fx_list = fx_list..fx_name
		end
	end

r.DeleteTrack(temp_track)
r.PreventUIRefresh(-1)

local err = not fx_idx and (fx_cnt == 0 and 'No FX have been selected in the FX browser.' or fx_cnt > 0 and #fx_list == 0 and 'No presets in selected FX.')
local err = not err and fx_idx and fx_cnt > 0 and #fx_list == 0 and 'No presets in FX of the focused FX chain.' or err
	if err then
	r.MB(err, 'ERROR', 0)
	end

return fx_list:sub(2), valid_fx_cnt, _129 -- removing leading line break from fx_list

end


function Re_Store_Float_FX_Wnds(obj, t, idx)
-- idx comes from FX loop and serves as a storage routine condition
local tr = r.ValidatePtr(obj, 'MediaTrack*')
local take = r.ValidatePtr(obj, 'MediaItem_Take*')
	if idx then
	GetFloatingWindow = take and r.TakeFX_GetFloatingWindow or tr and r.TrackFX_GetFloatingWindow
	local t = {}
		if GetFloatingWindow(obj, idx) then
		t[#t+1] = idx
		end
	return t
	elseif t then
		for _, idx in ipairs(t) do
		FX_Show(obj, idx, 3) -- 3 (show floating)
		end
	end
end
-- USAGE:
-- local t = {}
-- for i = 0, fx_cnt-1 do -- store
-- t = Re_Store_Float_FX_Wnds(obj, t, i)
-- end
-- Re_Store_Float_FX_Wnds(obj,t) -- restore



function Re_Store_FX_Windows_Visibility(t)
-- restores positions if screenset wasn't changed
-- doesn't restore focus and z-order
-- take fx windows are linked to track to be able to ignore them when the track is hidden
-- to restore positions and focus use Re_Store_Windows_Props_By_Names()
-- see implementation in Restore FX windows after screenset change.lua
	if not t then
	local t = {}
		for i = -1, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i) or r.GetMasterTrack(0)
		t[tr] = {trackfx = {}, takefx = {}}
			for i = 0, r.TrackFX_GetCount(tr)-1 do
				if r.TrackFX_GetOpen(tr, i) then -- is open in the FX chain window or a floating window
				local len = #t[tr].trackfx+1
				-- storing floating status and fx chain UI visibility status even if the UI is floating
				t[tr].trackfx[len] = {idx=i, float=r.TrackFX_GetFloatingWindow(tr, i), ui=r.TrackFX_GetChainVisible(tr)==i}
				end
			end
			for i = 0, r.TrackFX_GetRecCount(tr)-1 do
			local i = i+0x1000000
			local open_fx_idx = Get_InputMonFX_Chain_Truely_SelectedFX(tr)
				if r.TrackFX_GetOpen(tr, i) then -- is open in the FX chain window or a floating window
				local len = #t[tr].trackfx+1
				t[tr].trackfx[len] = {idx=i, float=r.TrackFX_GetFloatingWindow(tr, i), ui=open_fx_idx==i}
				end
			end
			for i = 0, r.GetTrackNumMediaItems(tr)-1 do
			local itm = r.GetTrackMediaItem(tr,i)
			t[tr].takefx[itm] = {}
				for i = 0, r.CountTakes(itm)-1 do
				local take = r.GetTake(itm, i)
				t[tr].takefx[itm][take] = {}
					for i = 0, r.TakeFX_GetCount(take)-1 do
						if r.TakeFX_GetOpen(take, i) then -- is open in the FX chain window or a floating window
						local len = #t[tr].takefx[itm][take]+1
						t[tr].takefx[itm][take][len] = {idx=i, float=r.TakeFX_GetFloatingWindow(take, i), ui=r.TakeFX_GetChainVisible(take)==i}
						end
					end
				end
			end
		end
	return t
	elseif t then
		for tr in pairs(t) do
	--[[script specific
		local mixer_vis = r.GetToggleCommandStateEx(0, 40078) == 1 -- View: Toggle mixer visible
		local master_vis_flag = r.GetMasterTrackVisibility()
		local master_vis_TCP, master_vis_MCP = master_vis_flag&1 == 1, master_vis_flag&2 == 2 -- in fact contrary to the old versions of the API doc master_vis_flag&2 == 2 is true if Master is hidden in the Mixer, if visible the expression will be false
		local is_master_tr = tr == r.GetMasterTrack(0)
	--]]
			if r.ValidatePtr(tr, 'MediaTrack*')
			--[[ script specific
			and (not mixer_vis and (is_master_tr and master_vis_TCP or r.IsTrackVisible(tr, false)) -- mixer false // visible in the TCP // IsTrackVisible DOESN'T APPLY TO MASTER TRACK, always returns true
			or mixer_vis and (is_master_tr and master_vis_MCP or r.IsTrackVisible(tr, true)) ) -- mixer true // visible in the MCP // IsTrackVisible DOESN'T APPLY TO MASTER TRACK, always returns true
			or IGNORE_VISIBILITY
			--]]
			then
				for _, fx_data in ipairs(t[tr].trackfx) do
					if fx_data.ui then r.TrackFX_Show(tr, fx_data.idx, 1) end -- showFlag 1 (open FX chain with fx ui shown) // OR r.TrackFX_SetOpen(tr, fx_idx, true) -- open true
					if fx_data.float then r.TrackFX_Show(tr, fx_data.idx, 3) end -- showFlag 3 (open in a floating window)
				end
				for itm, takes_t in pairs(t[tr].takefx) do
					for take, fx_t in pairs(takes_t) do
						for _, fx_data in ipairs(fx_t) do
							if fx_data.ui then r.TakeFX_Show(take, fx_data.idx, 1) end -- showFlag 1 (open FX chain with fx ui shown) // OR r.TakeFX_SetOpen(take, fx_data.idx, true) -- open true
							if fx_data.float then r.TakeFX_Show(take, fx_data.idx, 3) end -- showFlag 3 (open in a floating window)
						end
					end
				end
			end
		end
	end

end




function FX_Has_Envelopes(take, tr, fx_idx) -- or (obj, fx_idx) and the uncomment the next lines
--local tr = r.ValidatePtr(env, 'MediaTrack*')
--local take = r.ValidatePtr(env, 'MediaItem_Take*')
local obj = take or tr
local GetNumParams, GetFXEnvelope = table.unpack(take and
{r.TakeFX_GetNumParams,r.TakeFX_GetEnvelope}
or tr and {r.TrackFX_GetNumParams, r.GetFXEnvelope})
	for i = 0, GetNumParams(obj,fx_idx)-1 do
	local env = GetFXEnvelope(obj, fx_idx, i, false) -- create false
		if env and (r.ValidatePtr(env, 'TrackEnvelope*')
		or r.CountEnvelopePoints(env) > 0)
		then return true
		end
	end
end



function TrackFX_GetRecChainVisible1(tr)
-- when fx is both selected in the fx chain and its is UI floating
-- in track main and take fx chains such fx is determined
-- with TrackFX_GetChainVisible() but it doesn't support input and monitoring fx chains
	if not tr or not r.ValidatePtr(tr, 'MediaTrack*') then return end
	if tr then
	local t = {}
	local CountFX = r.TrackFX_GetRecCount
	r.PreventUIRefresh(1)
		for i = 0, CountFX(tr)-1 do -- close and store all floating windows
		local idx = 0x1000000+i
			if r.TrackFX_GetFloatingWindow(tr, idx) then
			r.TrackFX_SetOpen(tr, idx, false) -- open false // close floating window
			-- OR
			-- r.TrackFX_Show(tr, idx, 2) -- showFlag 2 - close floating window
			t[#t+1] = idx
			end
		end
	local open_fx_idx -- get fx whose UI is open in FX chain
		for i = 0, CountFX(tr)-1 do
		local idx = i+0x1000000
			if r.TrackFX_GetOpen(tr, idx) then
			open_fx_idx = idx break end
		end
	-- restore floating windows	// z-order and focused window won't be restored, the foreground will be occupied but the window of the fx selected in the fx chain if its window was floating, otherwise the windows are loaded in the fx order
		for _, fx_idx in ipairs(t) do
		r.TrackFX_Show(tr, fx_idx, 3) -- showFlag 3 - open in a floating window
		end
	r.PreventUIRefresh(-1)
	return open_fx_idx
	end
end



function TrackFX_GetRecChainVisible2(tr) -- only returns fx chain window status
	if not tr or not r.ValidatePtr(tr, 'MediaTrack*') then return end
r.PreventUIRefresh(1)
local chain_open, shown_fx
	for i = 0, r.TrackFX_GetRecCount(tr)-1 do
	local i = i+0x1000000
		if r.TrackFX_GetOpen(tr, i)
		and not r.TrackFX_GetFloatingWindow(tr, i)
		then chain_open = true
		elseif r.TrackFX_GetOpen(tr, i) then
		shown_fx = i
		end
	end
	if not chain_open then -- retry in case the chain is open but empty or the fx open in the chain but also floating which in itself isn't reliable because it returns true even when the chain is closed
	r.TrackFX_AddByName(tr, 'ReaGate', true, -1000) -- recFX true, instantiate -1000 (1st slot) // insert temporary stock fx to evaluate against it, its UI will be automatically shown in the chain
	local idx = 0x1000000 -- 1st slot
	chain_open = r.TrackFX_GetOpen(tr, idx)
	r.TrackFX_Delete(tr, idx)
	local restore = shown_fx and r.TrackFX_SetOpen(tr, shown_fx, true) -- open true // restore // will bring the fx floating window, if any, to the fore
	end
r.PreventUIRefresh(-1)
return chain_open
end



function FX_Exists(obj, fx_name, fx_parm_cnt, parmA_idx, parmA_name, parmB_idx, parmB_name, parmC_idx, parmC_name, fx_idx)
-- fx_name is original fx name, will be used in builds 6.37 onwards
-- fx_idx is optional, if passed the function will evaluate whether the FX with this particular index is the sought one
-- otherwise it searches for ar least one matching FX in the entire FX chain
-- the function currently doesn't support Input/Monitoring FX chains
-- NOT failproof because if at least 1 parameter has an alias, its name won't match
-- the default one if this is what's passed as an argument
-- currently the original parm name can only be verified via chunk
-- feature request for doing this with FX_GetNamedConfigParm():
-- https://forum.cockos.com/showthread.php?t=282037
local tr, take = r.ValidatePtr(obj,'MediaTrack*'), r.ValidatePtr(obj,'MediaItem_Take*')
local obj = tr or take
	if not obj then return 'invalid object' end
local FX_Count, FX_GetNumParams, FX_GetParamName, FX_GetNamedConfigParm = table.unpack(
tr and {r.TrackFX_GetCount, r.TrackFX_GetNumParams, r.TrackFX_GetParamName, r.TrackFX_GetNamedConfigParm}
or take and {r.TakeFX_GetCount, r.TakeFX_GetNumParams, r.TakeFX_GetParamName, r.TakeFX_GetNamedConfigParm}
local parm_t = {[parmA_idx] = parmA_name, [parmB_idx] = parmB_name, [parmC_idx] = parmC_name}
local start, fin = fx_idx or 0, fx_idx or FX_Count(obj)-1
local supported = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.37 -- since this build FX_GetNamedConfigParm() can retrieve the original FX name, which obviates using chunk
	for idx = start, fin do
	local found_cnt = 0
		if supported and #fx_name:gsub(' ','') > 0 then
		local _, org_name = FX_GetNamedConfigParm(obj, idx, 'fx_name') -- parmname could be 'original_name' as well
			if fx_name == org_name then return true end
		else
		local parm_cnt = FX_GetNumParams(obj, idx)
			if parm_cnt == fx_parm_cnt then
				for parm_idx, name in pairs(parm_t) do
				local retval, parm_name = FX_GetParamName(obj, idx, parm_idx, '')
					if parm_name == name then found_cnt = found_cnt+1 end
				end
				if found_cnt == 3 then return true end -- all 3 parameter names match
			end
		end
	end
end



function Enum_RS5k_files(tr, fx_idx)
local i = 0
	repeat
	local retval, name = r.TrackFX_GetNamedConfigParm(tr, fx_idx, "FILE"..i)
	local name = name:match('.+[\\/](.+)')
		if name then ... end -- if retval then .... end // ... means some operation
	i = i + 1
	until not retval or not name or name == ''
end



function Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, pass, want_chain)
-- Due to REAPER bug https://forum.cockos.com/showthread.php?t=281778, which was fixed in build 7.01
-- undo point for all RS5k instances is only created with open FX chain window
-- to create an undo point for a single instance it suffices to open it in a floating window
-- the function must be run in two passes within the Undo blocks
-- 1st pass before the action for which undo point needs to be created, 2nd pass after it
-- if flag -1 doesn't work in Undo block flag 2 must be used
-- ARGS:
-- targ_fx_idx is the single target fx to be affected by the script and to be opened in the floating window, must only be valid if want_chain is false, to be used in both function passes;
-- targ_fx_floats isn't needed in the 1st pass, only needed in the second if want_chain is false;
-- last_sel_idx and last_sel_fx_floats in the 1st pass aren't needed, only needed in the 2nd pass if want_chain is true;
-- pass is integer, 1 or 2;
-- want_chain is boolean if the entire chain has to be opened because multiple RS5k instances are affected, in this case relies on GetObjChunk() function
-- to evaluate build: tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.01

	if pass == 1 then
	local chain_vis = r.TrackFX_GetChainVisible(tr) ~= -1
	local targ_fx_floats = r.TrackFX_GetFloatingWindow(tr, targ_fx_idx)
		if (want_chain and not chain_vis or not want_chain and not chain_vis and targ_fx_idx and not targ_fx_floats)
		then -- open
		local last_sel_idx = 0
			if want_chain then
			local ret, chunk = GetObjChunk(tr)
				if ret then -- if chunk was successfully retrieved
					for line in tr_chunk:gmatch('[^\n\r]+') do
						if line:match('LASTSEL') then last_sel_idx = line:match('%d+') break end -- extract the index of fx selected in fx chain so that if the chain is closed it could be opened with this fx visible to make REAPER register change in the undo history
					end
				end
			end
		local last_sel_fx_floats = want_chain and r.TrackFX_GetFloatingWindow(tr, last_sel_idx) -- if last selected fx window floats while the fx chain is closed, after toggling open-close the fx chain below the floating window will be closed because the function will use its index to keep it selected in the chain, so find if it floats to re-float it after toggling the fx chain open-close
		local open = want_chain and r.TrackFX_SetOpen(tr, last_sel_idx, true) -- open arg true - open fx chain with last selected fx shown
		or fx_idx and not targ_fx_floats and r.TrackFX_Show(tr, fx_idx, 3) -- or open target fx in a floating window, flag 3
		return last_sel_idx, last_sel_fx_floats, r.TrackFX_GetFloatingWindow(tr, fx_idx)
		end
	elseif pass == 2 then -- close
	local clse = last_sel_idx and r.TrackFX_SetOpen(tr, last_sel_idx, false) -- close fx chain if was closed originally, open arg is false
	or fx_idx and targ_fx_floats and r.TrackFX_Show(tr, fx_idx, 2) -- or close the target fx floating window if was closed originally, flag 2 close floating window
	local re_float = last_sel_fx_floats and r.TrackFX_Show(tr, last_sel_idx, 3) -- show in a floating window, flag 3, re-float fx last selected in the fx chain if it was floating prior to toggling the fx chain open-close, because it will end up being closed as a result
	end

end
-- USE (WORKING WITH A SINGLE RS5k INSTANCE):
-- Undo_BeginBlock()
-- local last_sel_idx, last_sel_fx_floats, targ_fx_floats = Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 1, false) -- targ_fx_floats, last_sel_idx, last_sel_fx_floats are nil, pass is 1, want_chain false
-- DO STUFF
-- Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 2, false) -- last_sel_idx, last_sel_fx_floats are nil, pass is 2, want_chain false
-- Undo_EndBlock('',2) -- the flag MUST be 2 (UNDO_STATE_FX), NOT -1 which works only once if the plugin UI is originally open

-- (WORKING WITH MULTIPLE RS5k INSTANCES):
-- Undo_BeginBlock()
-- local last_sel_idx, last_sel_fx_floats, targ_fx_floats = Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 1, true) -- targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats are nil, pass is 1, want_chain true
-- DO STUFF
-- Force_RS5k_Undo_With_Closed_Chain(tr, targ_fx_idx, targ_fx_floats, last_sel_idx, last_sel_fx_floats, 2, false) -- targ_fx_idx, targ_fx_floats and nil, last_sel_idx is integer, last_sel_fx_floats is boolean, pass is 2, want_chain true
-- Undo_EndBlock('',2) -- the flag MUST be 2 (UNDO_STATE_FX), NOT -1 which works only once if the plugin UI is originally open



function Get_FX_Selected_In_FX_Chain(obj, input_fx, chunk) -- see GetSet_FX_Selected_In_FX_Chain() below for a comprehensive version
-- input_fx is boolean for use in builds 7.06+ to target input/Monitoring FX chain
-- doesn't support containers

local take, tr = r.ValidatePtr(obj, 'MediaItem_Take*'), r.ValidatePtr(obj, 'MediaItem_Track*')
FX_GetNamedConfigParm = tr and r.TrackFX_GetNamedConfigParm or take and r.TakeFX_GetNamedConfigParm
local input_fx = tr and input_fx -- validate so it's only valid if object is track

	if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 7.06 then
	local ret, sel_idx = FX_GetNamedConfigParm(obj, input_fx and 0x1000000 or 0, 'chain_sel')
	return sel_idx
	else
	-- as an alternative to chunk, selected fx can be determined by opening FX chain with actions
	-- with storage of selected objects and making the target object exclusively selected/last touched
	-- then using FX_GetOpen and closing FX chain if it was initially closed which is evaluated with FX_GetChainVisible
	-- but you're running the risk of removing the focus from any currently focused windows which is a bad practice
	local found
		for line in chunk:gmatch('[^\n\r]+') do
			if (not input_fx or found) and line:match('LASTSEL') then
			return line:match('%d+')
			elseif input_fx and line:match('<FXCHAIN_REC') then found = 1
			end
		end
	end

end



function Set_FX_Selected_In_FX_Chain(obj, input_fx, fx_idx, chunk) -- see GetSet_FX_Selected_In_FX_Chain() below for a comprehensive vesrion
-- before build 7.06 relies on SetObjChunk() and on Esc() for dealing with takes
-- functions FX_Copy_To_Take(), FX_Copy_To_Track() in particular change fx selection in the source chain, making selected the last addressed fx
-- so the original selection requires restoration
-- doesn't support containers
-- since 7.06 can be done with FX_SetNamedConfigParm()
-- input_fx is boolean for use in builds 7.06+ to target input/Monitoring FX chain

local take, tr = r.ValidatePtr(obj, 'MediaItem_Take*'), r.ValidatePtr(obj, 'MediaItem_Track*')
local FX_Chain_Vis, FX_Open, FX_SetNamedConfigParm = table.unpack(take and {r.TakeFX_GetChainVisible, r.TakeFX_SetOpen, r.TakeFX_SetNamedConfigParm} or tr and {r.TrackFX_GetChainVisible, r.TrackFX_SetOpen, r.TrackFX_SetNamedConfigParm} or {})
local input_fx = tr and input_fx -- validate so it's only valid if object is track

	if take or tr then
		if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 7.06 then
		FX_SetNamedConfigParm(obj, input_fx and 0x1000000 or 0, 'chain_sel', math.floor(fx_idx)..'') -- converting to string without trailing decimal 0
		elseif FX_Chain_Vis(obj) ~= -1 -- -1 chain hidden, -2 chain visible but no effect selected
		then -- FX chain open
		FX_Open(obj, fx_idx, true) -- open true
		else -- to select FX in a closed FX chain technically it can be done with FX_SetOpen after opening the chain and then closing it, but you're running the risk of removing the focus from any currently focused windows which is a bad practice
		local cur_sel_idx, found
			if tr and tr ~= r.GetMasterTrack(0) then -- ?????? TO TEST Monitoring FX selection cannot be set via chunk because their chunk is stored in reaper-hwoutfx.ini file rather than in the master track chunk and the file cannot be updated as long as REAPER runs
				for line in chunk:gmatch('[^\n\r]+') do
					if (not input_fx or found) and line:match('LASTSEL') then
					cur_sel_idx = line:match('%d+')
					break
					elseif line:match('<FXCHAIN_REC') then found = 1
					end
				end
				if cur_sel_idx then
				local input_fx_prefix = input_fx and '<FXCHAIN_REC.-' or ''
				local chunk = chunk:gsub(input_fx_prefix..'LASTSEL '..cur_sel_idx, input_fx_prefix..'LASTSEL '..fx_idx, 1)
				SetObjChunk(obj, chunk)
				end
			elseif take then
			local retval, GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
			local take_chunk = chunk:match(Esc(GUID)..'<.-TAKEFX.-LASTSEL %d+') -- isolate take data by its GUID
			local take_chunk_upd = take_chunk:gsub('LASTSEL %d+', 'LASTSEL '..math.floor(fx_idx)..'') -- converting to string without trailing decimal 0
			take_chunk = Esc(take_chunk)
			chunk = chunk:gsub(take_chunk, take_chunk_upd)
			SetObjChunk(obj, chunk)
			end
		end
	end

end



function GetSet_FX_Selected_In_FX_Chain(obj, sel_idx, chunk, input_fx)
-- before build 7.06 relies on SetObjChunk() and on Esc() for dealing with takes
-- functions FX_Copy_To_Take(), FX_Copy_To_Track() in particular change fx selection in the source chain if the source and destination FX indices are identical https://forum.cockos.com/showthread.php?t=285177#18
-- (their non-identity can be used as a conditon to avoid setting selection)
-- so the original selection requires restoration
-- sel_idx is string, input_fx is boolean to address input fx chain
-- chunk comes from GetObjChunk(), relevant at both stages
-- used in builds older than 7.06, as well as SetObjChunk()
-- Since 7.06 FX_GetNamedConfigParm() 'chain_sel' can be used, e.g.
-- FX_GetNamedConfigParm(obj, 0, 'chain_sel') -- 0x1000000 for input fx instead of 0
-- FX_SetNamedConfigParm(obj, 0, 'chain_sel', fx_idx) -- fx_idx is a string
-- https://forum.cockos.com/showthread.php?t=285177#19
-- doesn't support containers

local old = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 7.06
local take, tr = r.ValidatePtr(obj, 'MediaItem_Take*'), r.ValidatePtr(obj, 'MediaItem_Track*')
local FX_Chain_Vis, FX_Open, Get_Conf_Parm, Set_Conf_Parm = table.unpack(take and {r.TakeFX_GetChainVisible, r.TakeFX_SetOpen, r.TakeFX_GetNamedConfigParm,r.TakeFX_SetNamedConfigParm} or tr and {r.TrackFX_GetChainVisible, r.TrackFX_SetOpen, r.TrackFX_GetNamedConfigParm, r.TrackFX_SetNamedConfigParm} or {})
local input_fx = tr and input_fx -- validate so it's only valid if object is track

	if not sel_idx then -- GET
		if not old then
		return select(2, Get_Conf_Parm(obj, input_fx and 0x1000000 or 0, 'chain_sel')) -- returns value even if none is visually selected as long as there're fx in the chain
		else -- use chunk, chunk holds the selected index even if none is visually selected
		-- as an alternative to chunk, selected fx can be determined by opening FX chain with actions
		-- with storage of selected objects and making the target object exclusively selected/last touched
		-- then using FX_GetOpen and closing FX chain if it was initially closed which is evaluated with FX_GetChainVisible
		-- but you're running the risk of removing the focus from any currently focused windows which is a bad practice
		local found
			for line in chunk:gmatch('[^\n\r]+') do
				if (not input_fx or found) and line:match('LASTSEL') then
				return line:match('%d+')
				elseif line:match('<FXCHAIN_REC') then found = 1
				end
			end
		end
	else -- SET
		if not old and #sel_idx > 0 then -- only when certain fx was selected, would be empty string if no fx in the chain
		Set_Conf_Parm(obj, input_fx and 0x1000000 or 0, 'chain_sel', math.floor(fx_idx)..'') -- converting to string without trailing decimal 0
		else -- use chunk
		-- if object data changed in between the function executions
		-- the chunk must be re-get for the restoration stage
		-- to select FX in a closed FX chain technically it can be done with FX_SetOpen after opening the chain and then closing it, but you're running the risk of removing the focus from any currently focused windows which is a bad practice
		local fx_chain = ''
			if tr then
				for line in chunk:gmatch('[^\n\r]+') do
				-- collect chunk up to LASTSEL token
					if not input_fx then
					fx_chain = fx_chain..'\n'..line
						if line:match('LASTSEL') then break end
					elseif input_fx and obj ~= r.GetMasterTrack(0) then -- ?????? TO TEST Monitoring FX selection cannot be set via chunk because their chunk is stored in reaper-hwoutfx.ini file rather than in the master track chunk and the file cannot be updated as long as REAPER runs
						if line:match('<FXCHAIN_REC') or #fx_chain > 0 then
						fx_chain = fx_chain..'\n'..line
							if line:match('LASTSEL') then break end
						end
					end
				end
			elseif take then
			local retval, GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
			fx_chain = chunk:match(Esc(GUID)..'<.-TAKEFX.-LASTSEL %d+') -- isolate take data by its GUID
			end
			-- weirdly enough after using FX_Copy_To_Take(), FX_Copy_To_Track()
			-- selection changes visually without LASTSEL update in the chunk
			-- thefore comparison with the original value doesn't make sense
			-- the chunk must be updated regardless, only then the selection gets restored
			if #fx_chain > 0 --and line:match('LASTSEL (%d+)') ~= sel_idx <-- pointless due to above
			then
			local fx_chain_upd = fx_chain:gsub('LASTSEL %d+', 'LASTSEL '..math.floor(fx_idx)..'') -- converting to string without trailing decimal 0
			fx_chain = Esc(fx_chain)
			local chunk = chunk:gsub(fx_chain, fx_chain_upd)
			SetObjChunk(obj, chunk)
			end
		end
	end

end
--[[USE:
local sel_idx = GetSet_FX_Selected_In_FX_Chain(obj, nil, nil, chunk) -- sel_idx, input_fx are nil // GET/STORE

	if sel_idx then -- SET/RESTORE
	GetSet_FX_Selected_In_FX_Chain(obj, sel_idx, input_fx, chunk) -- input_fx depends on the target fx chain
	end
]]




function Apply_FX_Chain(obj, fx_chain, recFX)
-- obj is track or item, fx_chain is path to fx chain file,
-- recFX is boolean to apply fx chain to track input/Monitor fx chain
-- for take fx only single-take items are supported,
-- in multi-take items the chain is applied to the last take
-- if target chain already contains fx they're replaced,
-- REAPER seems to respect the chain chunk which appears later in the track chunk
-- so existence of several chain chunks of the same type doesn't break it,
-- for tracks, existing track items aren't a problem
-- !!!! CAN BE DONE WITH reaper.TrackFX_AddByName() WITH FX CHAIN FILE NAME+EXTENSION
-- AS fxname ARGUMENT, the minimal build isn't known

local tr, item = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem*')

	if tr or item then

	-- OR USE custom Get/SetObjChunk()
	local GetChunk, SetChunk = table.unpack(tr and {r.GetTrackStateChunk, r.SetTrackStateChunk}
	or item and {r.GetItemStateChunk, r.SetItemStateChunk})

	local retval, chunk = GetChunk(obj , '', false) -- isundo false

	local f = io.open(fx_chain,'r')
	local fx_chain = f:read('*a')
	f:close()

	local ch_cnt = chain_chunk:match('REQUIRED_CHANNELS (%d+)') -- will be absent if the chain only uses 2 channels
		if ch_cnt then
		chunk = chunk:gsub('NCHAN %d+', 'NCHAN '..ch_cnt)
		chain_chunk = chain_chunk:match('REQUIRED_CHANNELS %d+(\n.+)') -- exclude channel data because it's not part of the chunk
		else
		chain_chunk = '\n'..chain_chunk -- add new line char to match structure of chain with channel data for appending to the track chunk
		end

	local chunk1, chunk2 = chunk:match('(.+)(>)') -- split the chunk
	-- adding fx chain to track after items code isn't a problem,
	-- REAPER then places them in correct order
	local merged = chunk1..(item and '<TAKEFX'
	or ('<FXCHAIN'..(recFX and '_REC' or '')))..'\n'
	..fx_chain..'>\n'..chunk2 -- concatenate a new one // works without '>\n' as well

	SetChunk(obj, merged, false) -- isundo false

	end

end



function Process_FX_Incl_In_All_Containers(obj, recFX, parent_cntnr_idx, parents_fx_cnt)
-- https://forum.cockos.com/showthread.php?t=282861
-- https://forum.cockos.com/showthread.php?t=282861#18
-- https://forum.cockos.com/showthread.php?t=284400

-- obj is track or take, recFX is boolean to target input/Monitoring FX
-- parent_cntnr_idx, parents_fx_cnt must be nil

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')
-- OR
-- local tr, take = r.ValidatePtr(obj, 'MediaTrack*') and obj, r.ValidatePtr(obj, 'MediaItem_Take*') and obj // may be required to pass into the sub-function which does the processing

local FXCount, GetIOSize, GetConfig, SetConfig, GetFXName =
table.unpack(tr and {r.TrackFX_GetCount, r.TrackFX_GetIOSize, r.TrackFX_GetNamedConfigParm,
r.TrackFX_SetNamedConfigParm, r.TrackFX_GetFXName}
or take and {r.TakeFX_GetCount, r.TakeFX_GetIOSize, r.TakeFX_GetNamedConfigParm,
r.TakeFX_SetNamedConfigParm, r.TakeFX_GetFXName} or {})

local fx_cnt = not parent_cntnr_idx and (recFX and r.TrackFX_GetRecCount(obj) or FXCount(obj))
fx_cnt = fx_cnt or ({GetConfig(obj, parent_cntnr_idx, 'container_count')})[2]

	if tr or take then
		for i = 0, fx_cnt-1 do
		-- only add 0x1000000 to fx index to target input/Monitoring fx inside the outermost fx chain
		-- (at this stage parent_cntnr_idx is nil)
		local i = not parent_cntnr_idx and recFX and i+0x1000000 or i
		-- only use formula to calculate indices of fx in containers once parent_cntnr_idx var is valid
		-- to keep the indices of fx in the root (outermost) fx chain intact
		i = parent_cntnr_idx and (i+1)*parents_fx_cnt+parent_cntnr_idx or i
		local container = GetIOSize(obj, i) == 8
			if container then
			-- DO STUFF TO CONTAINER (if needed) and proceed to its FX;
			-- the following vars must be local to not interfere with the current loop and break i expression above
			-- only add 0x2000000+1 to the very 1st (belonging to the outermost FX chain) container index
			-- (at this stage parent_cntnr_idx is nil)
			-- and then keep container index obtained via the formula above throughout the recursive loop
			local parent_cntnr_idx = parent_cntnr_idx and i or 0x2000000+i+1
			-- multiply fx counts of all (grand)parent containers by the fx count
			-- of the current one + 1 as per the formula;
			-- accounting for the outermost fx chain where parents_fx_cnt is nil
			local parents_fx_cnt = (parents_fx_cnt or 1) * (fx_cnt+1)
			Process_FX_Incl_In_All_Containers(obj, recFX, parent_cntnr_idx, parents_fx_cnt) -- recFX can be nil/false // go recursive

			--[[ THIS EXPRESSION IS TO BE USED IF THE NEXT BLOCK 'DO STUFF TO FX' RETURNS SOMETHING
			local retval_1, retval_2 = Process_FX_Incl_In_All_Containers(obj, recFX, parent_cntnr_idx, parents_fx_cnt)
				if retval_1 then return retval_1, retval_2 end -- this will exit the main function
			]]

			else
			-- DO STUFF TO FX
			-- SetConfig(obj, i, 'renamed_name', 'TEST') -- e.g. rename all fx to 'TEST'

			--[[ THIS BLOCK RETURNS VALUES, SEE PARALLEL EXPRESSION IN THE BLOCK ABOVE
			local ret, fx_name = GetFXName(obj, i, '')
				if fx_name == 'ReaComp' then return fx_name end -- if in this block fx in a containter are processed this will only exit recursive function in the block above but not the main function
			]]
			--[[ Alternatively to exit the main function from here
				the values must not be returned inside the loop but assigned
				and the loop be exited with 'break' in order to return them
				at the very end of the main Process_FX_Incl_In_All_Containers() function
				so that the main function is exited after loop break, e.g.
				local ret, fx_name = GetFXName(obj, i, '')
					if fx_name == 'ReaComp' then name = fx_name break end -- then return 'name' var at the very end of the main function
			]]
			end
		end
	end

end



function Loop_Over_FX_Container_Table(obj, t)
-- obj is track or take, t is the table returned by Collect_All_Container_FX_Indices() above

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')

-- add functions as necessary depending on the type of fx processing needed
local FXCount, GetIOSize, GetConfig, SetConfig, GetFXName =
table.unpack(tr and {r.TrackFX_GetCount, r.TrackFX_GetIOSize, r.TrackFX_GetNamedConfigParm,
r.TrackFX_SetNamedConfigParm, r.TrackFX_GetFXName}
or take and {r.TakeFX_GetCount, r.TakeFX_GetIOSize, r.TakeFX_GetNamedConfigParm,
r.TakeFX_SetNamedConfigParm, r.TakeFX_GetFXName} or {})

	-- target fx instances in a chain ignoring containers
	for k, fx_idx in ipairs(t) do
		if tonumber(fx_idx) then -- fx instance // if container evaluation will be false since the value is table
	--  DO STUFF TO FX INSTANCES
	--	local ret, name = GetFXName(obj, fx_idx, '')
	--	Msg(name, fx_idx)
		end
	end
	-- target containers, ignoring fx instances
	for k, cont in ipairs(t) do
		if not tonumber(cont) then -- table storing container index and its fx list
	-- 	DO STUFF TO CONTAINER IF NEEDED USING ITS INDEX AT cont[1]
		Loop_Over_FX_Container_Table(obj, cont[2]) -- go recursive to loop over container fx, cont[2] is the address of the nested table with container fx indices list, at cont[1] container own index is stored
		end
	end

end




function Collect_All_Container_FX_Indices(t, obj, recFX, parent_cntnr_idx, parents_fx_cnt)
-- t must be nil, obj is track or take, recFX is boolean to target input/Monitoring FX
-- parent_cntnr_idx, parents_fx_cnt must be nil
-- fx indices from the outermost fx chain (the object main fx chain) are of course stored as well
-- see Loop_Over_FX_Container_Table() next

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')

local FXCount, GetIOSize, GetConfig = table.unpack(tr and {r.TrackFX_GetCount, r.TrackFX_GetIOSize,
r.TrackFX_GetNamedConfigParm} or take and {r.TakeFX_GetCount, r.TrackFX_GetIOSize,
r.TakeFX_GetNamedConfigParm} or {})

local fx_cnt = not parent_cntnr_idx and (recFX and r.TrackFX_GetRecCount(obj) or FXCount(obj))
fx_cnt = fx_cnt or ({GetConfig(obj, parent_cntnr_idx, 'container_count')})[2]

local t = t or {} -- add table for the outermost FX chain on the very first run

	-- collect all fx instances in a chain, including containers
	for i = 0, fx_cnt-1 do
	local i = not parent_cntnr_idx and recFX and i+0x1000000 or i
	i = parent_cntnr_idx and (i+1)*parents_fx_cnt+parent_cntnr_idx or i
	t[#t+1] = i
	end

	-- search for containers in the fx chain data stored above
	-- and if found go recursive to collect fx instances inside them
	for i, fx_idx in ipairs(t) do
	local container = GetIOSize(obj, fx_idx) == 8
	local retval, cont_fx_cnt = r.TrackFX_GetNamedConfigParm(obj, fx_idx, 'container_count') -- retval true even if container is empty
		if container and cont_fx_cnt+0 > 0 then
		t[i] = {fx_idx, {}} -- replace container index with a nested table containing its index and another nested table to collect indices of fx inside it
		local parent_cntnr_idx = parent_cntnr_idx and fx_idx or 0x2000000+fx_idx+1
		local parents_fx_cnt = (parents_fx_cnt or 1) * (#t+1) -- #t is equal to fx count in the parent container
		-- the function must not return table, otherwise its structure will be reversed
		-- starting from the innermost fx chain with no way to get higher
		-- the table is the same througouht the entire recursive loop anyway
		Collect_All_Container_FX_Indices(t[i][2], obj, recFX, parent_cntnr_idx, parents_fx_cnt) -- go recursive // t[i][2] is the address of the nested table for collecting container fx indices
		end
	end

return t

end



function Get_FX_All_Parent_Containers(obj, fx_idx)
-- supported since build 7.06

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')

	if fx_idx > 0x2000000 and (tr or take) then -- range fx inside containers, or > 33554432
	local GetConfigParm = tr and r.TrackFX_GetNamedConfigParm or take and r.TakeFX_GetNamedConfigParm
	local t, retval = {}	
		repeat
		retval, fx_idx = GetConfigParm(obj, fx_idx, 'parent_container')
			if retval then
			table.insert(t, 1, fx_idx+0)
			end
		until not retval -- or #fx_idx == 0
	return t
	end

end



function GetSetClear_FX_Parm_Mapping_Across_Containers(obj, fx_idx, parm_idx, parent_cont_t, set)
-- up to the outermost;
-- only works for container fx;
-- fx_idx is index of target container fx;
-- parm_idx is index of the target container fx parameter;
-- parent_cont_t is optional, a table of all parent containers 
-- stored from the outermost to the innermost, comes from Get_FX_All_Parent_Containers()
-- if empty or invalid it will be created inside this function;
-- set arg: 1 or any valid value apart from 2 - map parameter across all containers (set), 
-- 2 - unmap parameter across all containers (clear),
-- integers 1, 2 were opted for because relying on booleans true/false 
-- gets tricky in ternary expression
-- where false is diffucult to assign reliably due to its being weak value
-- i.e. expression local mode = a and not b and true or not a and b and false or nil
-- instead of false will always fall back on nil,
-- otherwise (nil) run in get mode,
-- i.e. evaluate whether parm_idx is mapped across all containers;
-- function is supported since build 7.06

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')

	if fx_idx > 0x2000000 and (tr or take) then -- range fx inside containers, or > 33554432
	local GetConfigParm = tr and r.TrackFX_GetNamedConfigParm or take and r.TakeFX_GetNamedConfigParm
	local parent_cont_t = parent_cont_t and #parent_cont_t > 0 and parent_cont_t or {}
		if #parent_cont_t == 0 then -- collect parent container indices
		local fx_idx, retval = fx_idx
			repeat
			retval, fx_idx = GetConfigParm(obj, fx_idx, 'parent_container')
				if retval then
				table.insert(parent_cont_t, 1, fx_idx+0) -- store in descending order, from the outermost to the innermost container
				end
			until not retval -- or #fx_idx == 0
		end
		if #parent_cont_t > 0 then -- map across containers or collect data for unmapping and unmap or find it mapped across containers
		local child_cont_idx, mapped_parm_idx = fx_idx, parm_idx -- assign current fx parameters to variables which will be updated during the loop // parm_idx is 0-based
		local map_t = set ~= 1 and {} -- initialize to collect indices associated with parameter across all containers // use separate table because if a table passed as parent_cont_t arg has this exact name, it will be modified and likely unusable for further operations outside the function
		-- first current fx parameter is mapped to its parent container parameter list
		-- and then this parameter is mapped across containers using its index in the child container parameter list
			for i = #parent_cont_t,1,-1 do -- loop in reverse because container indices are stored from the outermost to the innermost and it's the innermost container which parameter of an fx inside a container must be mapped to first so that there's something to map to further up the chain
			local cont_idx = parent_cont_t[i]
			local parmname = 'container_map.'..(set and 'add.' or 'get.')..child_cont_idx..'.'..mapped_parm_idx -- this parameter must be applied to container therefore the 2nd argument in GetConfigParm is always container index // in the very first cycle child_cont_idx is parent container of the fx whose index is passed as fx_idx, in subsequent cycles it's always a child container of container at cont_idx
			retval, mapped_parm_idx = GetConfigParm(obj, cont_idx, parmname) -- return mapped parameter index associated with it in the parent container parameter list, for the next cycle to map it to next parent container
				if not set and not retval then return -- if set is nil, i.e. get mode, retval being false means that parameter mapping hasn't reached the current (cont_idx) container, i.e. it's not mapped across all containers, therefore abort as there's no point to continue
				elseif set ~= 1 then -- collect parameter indices associated with parameter list of each container for unmapping or returning to the main routine
				map_t[i] = {cont_idx=cont_idx, parm_idx=mapped_parm_idx}
				end
			child_cont_idx = cont_idx -- update for the next cycle, for the next container (one level above current) current one becomes child
			end
			if not set then return true, map_t -- if set is nil, i.e. get mode, return true if the loop above wasn't aborted preemptively, which means that the parameter is mapped across ALL parent containers, plus return table with the parameter data
			elseif set == 2 then -- unmap parameter across all parent containers
				for k, data in ipairs(map_t) do -- here loop directly because unmapping must be performed in the order opposite to mapping, i.e. from the outermost container down to the innermost
				GetConfigParm(obj, data.cont_idx, 'param.'..data.parm_idx..'.container_map.delete')
				end
			end
		end
	end

end



function Get_Container_Parm_Source_Props(obj, cont_idx, parm_idx)
-- function is supported since build 7.06

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')
local GetIOSize, GetNamedConfigParm, GetNumParams, GetFXName, GetParamName = 
table.unpack(take and {r.TakeFX_GetIOSize, r.TakeFX_GetNamedConfigParm, 
r.TakeFX_GetNumParams, r.TakeFX_GetFXName, r.TakeFX_GetParamName}
or tr and {r.TrackFX_GetIOSize, r.TrackFX_GetNamedConfigParm, r.TrackFX_GetNumParams, 
r.TrackFX_GetFXName, r.TrackFX_GetParamName}) -- take is first to prevent false positive because when take valid track valud as well
	if GetIOSize and GetIOSize(obj, cont_idx) ~= 8 then return end -- not container

-- container built-in parameters (Bypass, Wet, Delta) follow all mapped parameters, i.e. 3 very last
local ret, src_fx_idx = GetNamedConfigParm(obj, cont_idx, 'param.'..parm_idx..'.container_map.fx_index') -- 0-based index // src_fx_idx is string // returns false and empty string if parm_idx refers to container built-in parameter or is out of range
local parm_cnt = GetNumParams(obj, cont_idx)-1 -- -1 to conform to 0-based parameter indexation

	if not ret and parm_idx > parm_cnt then return -- parm_idx is out of range
	elseif parm_idx > parm_cnt-3 then -- container built-in parameter (Bypass, Wet, Delta)
	local parm_idx = parm_idx - (parm_cnt-3)
	local t = {[1]='Bypass', [2]='Wet', [3]='Delta'}
	return t[parm_idx] -- return original name of a built-in parameter
	else
	local ret, src_fx_idx = GetNamedConfigParm(obj, cont_idx, 'container_item.'..src_fx_idx) -- 0x2000000 based index to be passed to all regular FX functions // src_fx_idx is string
	src_fx_idx = src_fx_idx+0 -- converting index from string into integer
	local ret, src_parm_idx = GetNamedConfigParm(obj, cont_idx, 'param.'..parm_idx..'.container_map.fx_parm') --  src_parm_idx is string
	src_parm_idx = src_parm_idx+0 -- converting index from string into integer
	local ret, src_fx_name = GetFXName(obj, src_fx_idx) -- returns aliased instance name if changed by the user; if parameter is mapped from a child container parameter list, returns name of the child container
	local ret, src_parm_name = GetParamName(obj, src_fx_idx, src_parm_idx) -- if aliased by user returns aliased name; if parameter is mapped from a grandchild container parameter list, returns full path to the parameter starting from grandchild container name, i.e. if source fx resides inside a grandchild container named 'cont123' the returned path will look like 'cont123: src FX name: src parm name'; the aliased path which is returned may be aliased at any level of container hierarchy
	-- concatenate mapped parameter name as it's supposed to appear in container parameter list in default format which is:
	-- [container1 name]: [container2 name] ...: [FX instance name]: [param name]
	-- when fx is deep within container hierarchy, for each container the parameter name is added container name;
	-- when src_fx_name is not a container name, non-aliased FX instance name is stripped off the plugin type prefix and vendor name
	local cont_parm_format = (src_fx_name:match('^[ADCJLPSTXVi]+:') and (src_fx_name:match('.-: (.-)%s%(') 
	or src_fx_name:match('.-: (.+)')) or src_fx_name)..': '..src_parm_name
	return cont_parm_format, src_fx_idx, src_parm_idx, src_fx_name, src_parm_name
	end

end



function Get_FX_Parm_Orig_Name_s(obj, fx_idx, parm_idx)
-- in case it's been aliased by the user
-- obj is track or take;
-- if parm_idx is valid, returns name of parameter 
-- at parm_idx, otherwise collects
-- all parameter names;
-- works with builds 6.37+ since which original non-aliased
-- fx name can be retrieved for use in TrackFX_AddByName(),
-- for older builds use Validate_FX_Identity()

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')
local GetConfig = tr and r.TrackFX_GetNamedConfigParm or take and r.TakeFX_GetNamedConfigParm
-- get fx name displayed in fx browser
local retval, fx_name = GetConfig(obj, fx_idx, 'original_name') -- or 'fx_name'
-- insert temp track
r.PreventUIRefresh(1)
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0) -- hide in Mixer
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0) -- hide in Arrange
-- insert FX instance on the temp track
-- the fx names retrieved with GetNamedConfigParm() always contains fx type prefix,
-- the function FX_AddByName() supports fx type prefixing but in the retrieved fx name
-- the fx type prefix is followed by space which wasn't allowed in FX_AddByName()
-- before build 7.06 so it must be removed, otherwise the function will fail
-- https://forum.cockos.com/showthread.php?t=285430
fx_name = fx_name:gsub(' ','',1) -- 1 is index of the 1st space in the string
r.TrackFX_AddByName(temp_track, fx_name, 0, -1) -- insert // recFX 0 = false, instantiate is -1
-- search for the name of parameter at the same index as the one being evaluated
local t, retval, parm_name = {}
	for i = 0, r.TrackFX_GetNumParams(temp_track, 0)-1 do -- fx_idx 0
	retval, parm_name = r.TrackFX_GetParamName(temp_track, 0, i, '') -- fx_idx 0
		if parm_idx and parm_idx > -1 and i == parm_idx then break -- must break rather than return to allow deletion of the temp track before returning the value
		else
		t[#t+1] = parm_name -- 1-based indexing
		end
	end
r.DeleteTrack(temp_track)
r.PreventUIRefresh(-1)

return parm_idx and parm_idx > -1 and parm_name, #t > 0 and t

end



function Get_FX_Parm_By_Name_Or_Ident(obj, fx_idx, parm_name, parm_ident, want_input_fx)
-- search by name/identifier in case index changes
-- yet a situation when index remains the same while name/identifier change
-- is just as likely;
-- param name can be aliased by user while identifier can't and so more reliable;
-- obj is track or take
-- want_input_fx is boolean to target input fx chain / Mointoring FX chain of the Master track
-- only valid if obj arg is track
local take, tr = r.ValidatePtr(obj,'MediaItem_Take*'), r.ValidatePtr(obj,'MediaTrack*')
local FX_CountParm, FX_GetParamName, FX_GetParamIdent = table.unpack(take and {r.TakeFX_GetNumParams, r.TakeFX_GetParamName, r.TakeFX_GetParamIdent} or tr and {want_input_fx and r.TrackFX_GetRecCount or r.TrackFX_GetNumParams, r.TrackFX_GetParamName, r.TrackFX_GetParamIdent})
	if take or tr then
	local _6_37 = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.37 -- support FX_GetParamIdent function
	local fx_idx = tr and want_input_fx and fx_idx < 0x100000 and fx_idx+0x1000000 or fx_idx
		for i=0, FX_CountParm(obj, fx_idx) do
		local retval, name = FX_GetParamName(obj, fx_idx, i)
		local retval, ident = table.unpack(_6_37 and {FX_GetParamIdent(obj, fx_idx, i)} or {})
			if parm_name and name == parm_name 
			or parm_ident and ident:match(parm_ident) -- without escaping because they're unlikely to include special characters, but worth being watchful
			then return i end
		end
	end
end




function Is_Same_Plugin(src_obj, src_fx_idx, dest_obj, dest_fx_idx)
-- since v7 EnumInstalledFX() can be used to retrieve the name listed in the FX browser and a unique identifier independent of the name in case changed but the identifier must of course be known in advance

-- src_obj and dest_obj are either track or take
-- input/Monitoring FX index must be fed in the API format, i.e. 0x1000000+idx or 16777216+idx
-- may not be good for JSFX plugins, because they may have too few params to reliably compare
-- while having common wet, bypass, delta params

	local function get_fx_parms(obj, fx_idx)
	local take = r.ValidatePtr(obj, 'MediaItem_Take*')
	local tr = r.ValidatePtr(obj, 'MediaTrack*')
	local GetNumParams, GetParamName = table.unpack(take and {r.TakeFX_GetNumParams, r.TakeFX_GetParamName}
	or tr and {r.TrackFX_GetNumParams, r.TrackFX_GetParamName} or {})
		if obj then
		local t = {}
			for idx = 0, GetNumParams(obj, fx_idx)-1 do
			local ret, parm_name = GetParamName(obj, fx_idx, idx, '')
			t[#t+1] = parm_name
			end
		return t
		end
	end

local src_parm_t = get_fx_parms(src_obj, src_fx_idx)
local dest_parm_t = get_fx_parms(dest_obj, dest_fx_idx)

	if src_parm_t and dest_parm_t and #src_parm_t == #dest_parm_t then
		for i = 1, #src_parm_t do -- compare the entire parm list
		local src, dest = src_parm_t[i], dest_parm_t[i]
			if src ~= 'Wet' and src ~= 'Bypass' and src ~= 'Delta' then -- not stock parameters
				if src ~= dest then return false
			end
		end
	--[[ OR
	math.randomseed(math.floor(r.time_precise())*1000) -- math.floor() because the seeding number must be integer
	local r, r_init
		for i = 1, 3 do -- 3 random comparisons
			if #src_parm_t > 4 then -- if 4 or less the loop might get stuck when none of the 'until' conditions is met, so math.random must be allowed to alternate between at least two values other than the 3 stock params
				repeat
				r = math.random(1,#src_parm_t)
				local parm = src_parm_t[r]
				until r ~= r_init and parm ~= 'Wet' and parm ~= 'Bypass' and parm ~= 'Delta'
			r_init = r
			else
			r = math.random(1,#src_parm_t)
			end
		local src, dest = src_parm_t[r], dest_parm_t[r]
			if src ~= 'Wet' and src ~= 'Bypass' and src ~= 'Delta' then -- not stock parameters
				if src ~= dest then return false
			end
		end
	--]]
	return true
	end

end



function Validate_FX_Identity(obj, fx_idx, fx_name, parm_t, parm_ident_t, TAG)
-- since v7 EnumInstalledFX() can be used to retrieve the name 
-- listed in the FX browser and a unique identifier independent 
-- of the name in case changed but the identifier must of course be known in advance

-- the function is based on Get_FX_Parm_Orig_Name_s() above
-- in case it's been aliased by the user;
-- obj is track or take;
-- fx_name is the original name of the plugin being validated
-- parm_t is a table indexed by param indices whose fields hold corresponding original param names
-- e.g. {[4] = 'parm name 4', [12] = 'parm name 12', [23] = 'parm name 23'}
-- parm_ident_t is a table indexed by param indices whose fields hold 
-- corresponding param string identifiers, supported since build 6.37+
-- parm_t and parm_ident_t must be of the same length and have the same order of parameters
-- TAG is a user TAG added to FX name in the FX chain
-- to mark it as a target for script, optional
-- works with builds 6.37+
-- relies on Esc() function

local tr, take = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem_Take*')
local GetFXName, GetConfig, CopyFX, GetParmCount, GetParamName =
table.unpack(tr and {r.TrackFX_GetFXName, r.TrackFX_GetNamedConfigParm,
r.TrackFX_CopyToTrack, r.TrackFX_GetNumParams, r.TrackFX_GetParamName}
or take and {r.TakeFX_GetFXName, r.TakeFX_GetNamedConfigParm,
r.TakeFX_CopyToTrack, r.TakeFX_GetNumParams, r.TakeFX_GetParamName} or {})
-- get name displayed in fx chain
local retval, fx_chain_name = GetFXName(obj, fx_idx, '')
fx_chain_name = TAG and fx_chain_name:gsub(TAG,'') or fx_chain_name -- if TAG is supplied removing to be able to evaluate clean name
	if fx_chain_name:match(Esc(fx_name)) then return true end -- ignoring fx type prefix

-- if fx chain displayed name doesn't match the user supplied name, meaning was renamed
-- get fx browser displayed name in builds which support this option

local build_6_37 = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.37

local retval, orig_fx_name

	if build_6_37 then
	retval, orig_fx_name = GetConfig(obj, fx_idx, 'original_name') -- or 'fx_name' // returned with fx type prefix
	-- In theory two different plugins can have identical names set by the user in the FX browser
	-- but in practice the odds are low
		if orig_fx_name:match(Esc(fx_name)) then return true end -- ignoring fx type prefix
	end

-- if validation by the original name failed or wasn't supported
-- validate using parameter names

-- add temp track and copy the fx instance to it
r.PreventUIRefresh(1)
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
local temp_track = r.GetTrack(0,r.CountTracks(0)-1)
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINMIXER', 0) -- hide in Mixer
r.SetMediaTrackInfo_Value(temp_track, 'B_SHOWINTCP', 0) -- hide in Arrange
-- search for the name of fx parameter at the same index as the one being evaluated 
-- in a fresh instance of the fx on the temp track or its copy if fresh instance could not
-- be added due to name change by the user in the FX browser,
-- in builds older than 6.37 the evaluation isn't reliable 
-- by 100% because some parameter names in the source fx may be aliased
-- and won't match the expected names
-- parameter identifiers supported since build 6.37 however are likely to be immutable
r.TrackFX_AddByName(temp_track, fx_name, false, 1) -- recFX false, instantiate 1 (or -1000) to insert
	if r.TrackFX_GetCount(temp_track) == 0 then -- copy source fx if insertion of a fresh one failed
	CopyFX(obj, fx_idx, temp_track, 0, false) -- is_move false
	end
local parm_t = parm_t and type(parm_t) == 'table' and #parm_t > 0 and parm_t
local parm_ident_t = parm_ident_t and type(parm_ident_t) == 'table' and #parm_ident_t > 0 and parm_ident_t
local name_match = true

	if parm_t or parm_ident_t then	
		for idx, name in pairs(parm_t) do
		local ident
		local retval, parm_name = r.TrackFX_GetParamName(temp_track, 0, idx, '') -- fx_idx 0
			if build_6_37 then
			retval, ident = r.TrackFX_GetParamIdent(temp_track, 0, idx)
			end
			if partm_t and name ~= parm_name
			or parm_ident_t and not ident:match(Esc(parm_ident_t[idx])) -- using string.match because returned identifiers incluse param index, i.e. 1:_identifier, while the table fed as argument doesn't
			then
			-- break rather than return to allow deletion of the temp track
			-- before returning the value
			name_match = false break
			end
		end
	else -- compare names and identifiers of up to 6 random parameters
	local src_parm_cnt = GetParmCount(obj, fx_idx)
	local tmp_parm_cnt = r.TrackFX_GetNumParams(temp_track, 0) -- 0 temp fx index
		if src_parm_cnt == tmp_parm_cnt then
		parm_t, parm_ident_t = {}, {}
		math.randomseed(math.floor(r.time_precise()*1000))
		local count = src_parm_cnt > 5 and 6 or src_parm_cnt -- look for 6 param names as long as the param count allows that, 6 is more reliable than 3 or 4 because random number may repeat which will reduce the number of options
			for i=1, count do
			-- collect parameter data from the source fx
			local ident
			local rnd = math.random(1, src_parm_cnt)-1 -- math.random range must start from 1
			local ret, parm_name = GetParamName(obj, fx_idx, rnd, '')
				if build_6_37 then
				ret, ident = r.TrackFX_GetParamIdent(obj, fx_idx, rnd)
				end
			local stock = parm_name == 'Bypass' or parm_name == 'Wet' or build_6_37 and parm_name == 'Delta' -- excluding 3 stock parameters because they're not unique to a plugin
				if parm_t[rnd] or parm_ident_t[rnd] or stock then -- prevent storing the same param several times if math.random generates the same number, and storing stock params
					repeat
					rnd = math.random(1, src_parm_cnt)-1
					ret, parm_name = GetParamName(obj, fx_idx, rnd, '')
					until not parm_t[rnd] and not parm_ident_t[rnd] 
					and parm_name ~= 'Bypass' and parm_name ~= 'Wet'
					and (not build_6_37 or parm_name ~= 'Delta')
				end
			parm_t[rnd], parm_ident_t[rnd] = parm_name, ident -- store
			end
			-- compare collected parameter data with temp fx parameters
			for parm_idx, name in pairs(parm_t) do
			local ident
			local retval, parm_name = r.TrackFX_GetParamName(temp_track, 0, parm_idx, '') -- fx_idx 0
				if build_6_37 then
				retval, ident = r.TrackFX_GetParamIdent(temp_track, 0, parm_idx)
				end
				if name ~= parm_name or parm_ident_t[parm_idx] and parm_ident_t[parm_idx] ~= ident then
				-- break rather than return to allow deletion of the temp track
				-- before returning the value
				name_match = false break
				end
			end
		end
	end


--[[ -- THIS IS REDUNDANT SINCE IN BUILDS 6.37+ VALIDATION WILL SUCCEED THROUGH FX_GetNamedConfigParm()
	  -- WHILE IN OLDER BUILDS FX CANNOT BE RELIABLY LOADED FROM BROWSER WITH FX_AddByName() 
	  -- TO CONTINUE COMPARING THEIR PARAMETERS
-- if name_match ends up being false there's possibility that the parameters have been aliased
-- in which case collate parm names in the clean instance of the fx loaded from the fx browser in builds 6.37+
	if parm_t and not name_match and build_6_37 then
	-- delete fx instance copied in the previous routine to the temp track
	r.TrackFX_Delete(temp_track, 0)
	-- use fx name displayed in fx browser
	-- to insert FX instance on the temp track
	-- the fx names retrieved with GetNamedConfigParm() always contain fx type prefix,
	-- the function FX_AddByName() supports fx type prefixing but in the retrieved fx name
	-- the fx type prefix is followed by space which wasn't allowed in FX_AddByName()
	-- before build 7.06 so it must be removed, otherwise the function will fail
	-- https://forum.cockos.com/showthread.php?t=285430
	orig_fx_name = orig_fx_name:gsub(' ','',1) -- 1 is index of the 1st space in the string
	r.TrackFX_AddByName(temp_track, orig_fx_name, 0, -1000) -- insert // recFX 0 = false, instantiate at index 0
	name_match = true
		for i = 0, r.TrackFX_GetNumParams(temp_track, 0)-1 do -- fx_idx 0
		local retval, parm_name = r.TrackFX_GetParamName(temp_track, 0, i, '') -- fx_idx 0
			if parm_t[i] and parm_t[i] ~= parm_name then
			-- break rather than return to allow deletion of the temp track
			-- before returning the value
			name_match = false break
			end
		end
	end
]]

r.DeleteTrack(temp_track)
r.PreventUIRefresh(-1)

return name_match

end



function Get_Open(obj, fx_idx)
-- evaluate whether the fx is open within fx chain or as a floating window
-- whether fx is open in a floating window can only be reliably determined
-- when it's not open within the fx chain or the fx chain is closed
-- because GetOpen function doesn't differentiate between open states
local tr, take = r.ValidatePtr(obj,'MediaTrack*'), r.ValidatePtr(obj,'MediaItem_Take*')
local GetChainVisible, GetOpen = table.unpack(tr and {r.TrackFX_GetChainVisible, r.TrackFX_GetOpen}
or take and {r.TakeFX_GetChainVisible, r.TakeFX_GetOpen})
local open_in_chain_idx = GetChainVisible(obj)
local open = GetOpen(obj, fx_idx)
return open_in_chain_idx == fx_idx, open_in_chain_idx ~= fx_idx and open -- 1st return value is true when fx is opened in the open fx chain, whether it's also open in a floating window is impossible to determine, 2nd return value is true when the fx isn't open in the fx chain or the fx chain is closed but it's open in a floating window

end



function Apply_Video_Proc_Preset(obj, fx_idx, preset, preset_idx) -- used inside Split_Active_Take_Name()
-- obj is track or take pointer
-- preset is preset name, preset_idx is its index, optional, 
-- either one or the other,
-- if applying by targetting index SetPresetByIndex 
-- will have to be used (see below)
-- but in builds older than 7.46 it's unreliable 
-- due to bug https://forum.cockos.com/showthread.php?t=302678

-- in builds older than 7.20 presets don't work if applied via the API
-- without opening the Video processor beforehand
-- because the parameter values shift downwards between parameters
-- while 'text height' param ends up at 0 so the text becomes invisible
-- bug report https://forum.cockos.com/showthread.php?t=293212
local old_build = tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.20
local tr, take = r.ValidatePtr(obj,'MediaTrack*'), r.ValidatePtr(obj,'MediaItem_Take*')
local SetPresetByName, SetPresetByIndex, GetOpen, GetChainVisible, FX_Show = 
table.unpack(tr and {r.TrackFX_SetPreset, r.TrackFX_SetPresetByIndex, r.TrackFX_GetOpen, 
r.TrackFX_GetChainVisible, r.TrackFX_Show} 
or take and {r.TakeFX_SetPreset, r.TakeFX_SetPresetByIndex, r.TakeFX_GetOpen, 
r.TakeFX_GetChainVisible, r.TakeFX_Show} or {})
local Set_Preset = preset and SetPresetByName or preset_idx and SetPresetByIndex
	if Set_Preset then
	local preset = preset or preset_idx
	local was_opened
	-- only open if not already opened in the fx chain or a floating window 
		if old_build and not r.GetOpen(obj, fx_idx) then
		FX_Show(obj, fx_idx, 3) -- showFlag 3 show floating window
		was_opened = 1
		end
	Set_Preset(obj, fx_idx, preset)
		if was_opened then FX_Show(obj, fx_idx, 2) end -- showFlag 2 hide floating window
	end
end



function Insert_Video_Proc_With_Preset(obj, preset)
-- obj is track or take pointer,
-- if there're video processor instances insert after the last found, 
-- otherwise insert at the top of the chain

local tr, take = r.ValidatePtr(obj,'MediaTrack*'), r.ValidatePtr(obj,'MediaItem_Take*')
local GetCount, GetIOSize, GetPreset, GetFXName, SetFXName, AddByName, SetPresetByName, 
SetPresetByIndex, FX_Show, SetNamedConfigParm = 
table.unpack(tr and {r.TrackFX_GetCount, r.TrackFX_GetIOSize, r.TrackFX_GetPreset, 
r.TrackFX_GetFXName, r.TrackFX_SetFXName, r.TrackFX_AddByName, r.TrackFX_SetPreset, 
r.TrackFX_SetPresetByIndex, r.TrackFX_Show, r.TrackFX_SetNamedConfigParm}
or take and {r.TakeFX_GetCount, r.TakeFX_GetIOSize,r.TakeFX_GetPreset, r.TakeFX_GetFXName, 
r.TakeFX_SetFXName, r.TakeFX_AddByName, r.TakeFX_SetPreset, r.TakeFX_SetPresetByIndex, 
r.TakeFX_Show, r.TakeFX_SetNamedConfigParm} or {})

local video_proc_idx
	for i=0, GetCount(obj)-1 do
	local plug_type = GetIOSize(obj, i)
		if plug_type == 6 then -- video proc
		local ret, presetname = GetPreset(obj, i, '')
			if presetname == preset then
			local ret, name = GetFXName(obj, i)
			--[[ script specific
				if name ~= 'Caption' then
				SetFXName(obj, i)
				end
			--]]
			return -- if preset is already activated in any of the video proc instances, abort operation
			else
			video_proc_idx = i -- keep collecting video processors indices, if any
			end
		end
	end

local fx_idx = video_proc_idx and video_proc_idx+1 or -1000 -- if there're video processor instances insert after the last, otherwise insert at the top of the chain

AddByName(obj, 'Video processor', fx_idx)
fx_idx = fx_idx < 0 and 0 or fx_idx -- change to target for processing
-- in builds older than 7.20 'Overlay: Text/Timecode' preset doesn't work if applied via the API
-- without opening the Video processor beforehand
-- because the parameter values shift downwards between parameters
-- while 'text height' param ends up at 0 so the text becomes invisible
-- bug report https://forum.cockos.com/showthread.php?t=293212
local old_build = tonumber(r.GetAppVersion():match('[%d%.]+')) < 7.20
	if old_build then FX_Show(obj, fx_idx, 3) end -- showFlag 3 show floating window
SetPresetByName(obj, fx_idx, preset)
	if old_build then FX_Show(obj, fx_idx, 2) end -- showFlag 2 hide floating window
--SetNamedConfigParm(obj, fx_idx, 'renamed_name', 'Caption') -- script specific

return true

end




function Get_Vid_Proc_Instance_Default_Name(obj, fx_GUID, chunk)
-- the line from the code which is added as video proc instance name in the FX chain
-- by deafault
-- if the code isn't preceded with comments or comment line are empty
-- the instance name is Video processor'
-- space between comment operator // and the text is ignored
-- entire 1st comment is used;
-- relies on Esc() function
local chunk, ret = chunk
	if not chunk then
	local tr, take = r.ValidatePtr(obj,'MediaTrack*'), r.ValidatePtr(obj,'MediaItem_Take*')
	local obj = take and r.GetMediaItemTake_Item(take) or tr
	local GetChunk = tr and r.GetTrackStateChunk or take and r.GetItemStateChunk
	ret, chunk = GetChunk(obj, '', false) -- isundo false
	end
local fx_GUID = Esc(fx_GUID)
local vid_proc, code = {}
	for line in chunk:gmatch('[^\n\r]+') do
		if not vid_proc and line and line:match('^<VIDEO_EFFECT') or vid_proc then
		vid_proc = 1
		code[#code+1] = line
		elseif vid_proc and line:match('FXID') then
			if not line:match(Esc(fx_GUID)) then 
			-- reset, wrong take or wrong video proc instance
			code = {}
			vid_proc = nil
			else break
			end 
		end
	end

return #code > 0 and code[3]:match('//.-(%S.+%S)') or 'Video processor'-- code starts on line 3 of collected part of chunk

end



function Find_Video_Proc_Instance(take, preset, want_disabled)
-- finds first instance which matches the conditions
-- want_disabled is boolean to detect disabled (bypassed or offline)

	for i=0, r.TakeFX_GetCount(take)-1 do
	local plug_type = r.TakeFX_GetIOSize(take, i)
	local vid_proc = plug_type == 6
	local ret, name = r.TakeFX_GetFXName(take, i)
	local ret, presetname = r.TakeFX_GetPreset(take, i, '')		
		if vid_proc and presetname == '' then -- will be true after bringing a video proc instance online in builds older than 7.46, in the preset list its name will be replaced with (Customized preset) https://forum.cockos.com/showthread.php?t=303014, so identify the preset by its parameter names and order
		local parm_names = {'text height', 'y position', 'x position', 'bg pad'} -- THESE WILL BE DIFFERENT FOR A DIFFERENT PRESET
			for ii=0, r.TakeFX_GetNumParams(take, i)-1 do
			local retval, parm_name = r.TakeFX_GetParamName(take, i, ii, '')
				if parm_name == parm_names[ii+1] -- +1 to match 0-based inetator count with 1-based table indexation
				or parm_name == 'text size' and ii == 0 then -- making allowance for variable name of the first parameter 
				presetname = preset
				break
				end
			end
		end
	local off = r.TakeFX_GetOffline(take, i)
	local unbypassed = r.TakeFX_GetEnabled(take, i)
		if vid_proc
		and presetname == preset 
		-- and name == 'Caption' -- script specific
		and (not want_disabled and not off and unbypassed or (off or not unbypassed) and want_disabled)
		then
			if want_disabled then -- reenable
			r.TakeFX_SetEnabled(take, i, true) -- enabled true
			r.TakeFX_SetOffline(take, i, false) -- offline false
			end
		return i
		end
	end
end


function Collect_FX_Parm_Aliases(fx_chunk)
-- fx_chunk arg stems from Get_FX_Chunk()
local t = {}
	for line in fx_chunk:gmatch('[^\n\r]+') do
		if line:match('PARMALIAS') then
		local parm_idx, alias = line:match('PARMALIAS (%d+).- "?(.+)') -- '.-' becase since presumably build 6.48 between index and the alias, parameter identifier (returned by r.Track/TakeFX_GetParamIdent) or VST3/CLAP internal param index can be tucked in separated by a colon
		t[parm_idx+0] = alias:match('[%s#]+') and alias:sub(1,-2) or alias -- converting index into a number and truncating trailing quotation mark if alias contains spaces or hash (#) because it's captured along with it
		end
	end
return t
end



--================================================  F X  E N D  ==============================================


--================================ I T E M S ==================================

-- Minimum take height is 12 px across all themes
-- r.GetMediaItemInfo_Value(item, 'I_LASTH') / number of takes
-- once this number is reduced by TCP shrinking
-- multi-take item collapses to display a single take at a time


local Get_Item_By_Take_GUID(take_GUID)
return r.GetMediaItemTake_Item(r.GetMediaItemTakeByGUID(0, take_GUID))
end


-- temporary disable options when manipulating items in the background, edit curs pos in these cases may need storage and restoration as well if Preferences -> Editing Behavor -> Move edit cursor when pasting/insering media is enabled
function Re_Store_Options_Togg_States(state1, state2) -- to disable and store run without the args to be on the safe side
	if not state1 and not state2 then
	local state1 = r.GetToggleCommandStateEx(0,40070) == 1 -- Options: Move envelope points with media items
		if state1 then r.Main_OnCommand(40070,0) end -- disable
	local state2 = r.GetToggleCommandStateEx(0,41117) == 1 -- Options: Trim content behind media items when editing
		if state2 then r.Main_OnCommand(41117,0) end -- disable
	return state1, state2
	else
	local re_enable = state1 and r.Main_OnCommand(40070,0)
	local re_enable = state2 and r.Main_OnCommand(41117,0)
	end
end
-- USE:
-- state1, state2 = Re_Store_Options_Togg_States()
-- DO STUFF
-- Re_Store_Options_Togg_States(state1, state2)



local x, y = r.GetMousePosition()
local item = r.GetItemFromPoint(x, y, true) -- allow_locked is true

function Toggle_Item_Selection(item) -- under mouse
--local item = r.GetMediaItem(0,0)
r.SetMediaItemSelected(item, not r.IsMediaItemSelected(item)) -- select if not selected and vice versa; doesn't affect the rest
end


function Display_Item_Name(item) -- for monitoring
r.ShowConsoleMsg('NAME = '..({r.GetSetMediaItemTakeInfo_String(r.GetActiveTake(itm), 'P_NAME', '', false)})[2])
end


function Rename_Item_Take_Src_File1(item, ACT) -- see a more reliable version 2 below

local take = r.GetActiveTake(item)
local old_fn = r.GetMediaSourceFileName(r.GetMediaItemTake_Source(take), '') -- extract file path and name

local f_path, f_name = old_fn:match('^(.+[\\/])([^\\/]+)$') -- isolate file path and name

local f_name_new = '...' -- SOME STRING OR MODIFIED f_name
local new_fn = f_path..f_name_new

ACT(40289) -- Item: Unselect all items
r.SetMediaItemSelected(item, true)
ACT(40440) -- Item: Set selected media temporarily offline
os.rename(old_fn, new_fn) -- apply a new name
local new_src = r.PCM_Source_CreateFromFile(new_fn)
r.SetMediaItemTake_Source(take, new_src) -- assign the renamed file as a source
ACT(40439) -- Item: Set selected media online
local ok, message = #r.GetPeakFileName(f_path..f_name, '') > 0 and os.remove(f_path..f_name..'.reapeaks') -- remove old file name peak file

end


function Rename_Item_Take_Src_File2(take)
-- Thanks to cfillion and MPL
-- https://forum.cockos.com/showthread.php?t=211250 file rename
-- https://forum.cockos.com/showthread.php?p=1889202 file rename

local old_src = r.GetMediaItemTake_Source(take)
local old_src = r.GetMediaSourceParent(src) or old_src -- in case the item is a section or a reversed source

local old_fn = r.GetMediaSourceFileName(old_src, "") -- extract rendered file path and name
--local rend_file_ext = old_fn:match("%.%w+") -- extract rendered file extension
--local rend_file_path = old_fn:match("^(.+[\\/])") -- extract rendered file path
local rend_file_path, rend_file_ext = old_fn:match("^(.+[\\/]).+(%.%w)$") -- extract rendered file index and extension

-- Concatenate a new file name and rename the rendered fil
local f_name_new = '...' -- CONCATENATE NAME
local new_fn = f_path..f_name_new

-- Rename source file and reapply

r.Main_OnCommand(40440,0) -- Item: Set selected media temporarily offline
os.rename(old_fn, new_fn) -- apply a new name
local new_src = r.PCM_Source_CreateFromFile(new_fn)
r.SetMediaItemTake_Source(take, new_src) -- assign the renamed file as a source
r.Main_OnCommand(40439,0) -- Item: Set selected media online
os.remove(old_fn..'.reapeaks') -- remove old file name peak file

end



function Re_Store_Active_Take_At_Index(item, act_take)
-- act_take is either a pointer or an index, only relevant at restoration stage
-- restoration by index or by pointer produces the same result,
-- i.e. the take at the same position remains active
-- even if it's a different take
-- obviously only makes sense for multi-take items
	if not act_take then -- storage stage
	local act_take_idx = r.GetMediaItemInfo_Value(item, 'I_CURTAKE')
	local act_take = r.GetActiveTake(item)
	return act_take_idx, act_take -- returns both index and pointer, so any can be used at the restoration stage
	else -- restoration stage
		if tonumber(act_take) then -- index
		r.SetMediaItemInfo_Value(item, 'I_CURTAKE', act_take)
	-- OR
	-- r.SetActiveTake(r.GetTake(item, act_take)
		elseif r.ValidatePtr(act_take, 'MediaItem_Take*') then -- pointer
		r.SetActiveTake(act_take)
		end
	end
end



function Re_Store_Active_Take_By_GUID(item, GUID)
-- ensuring that the same take remains active no matter the position
-- GUID arg is only relevant at restoration stage
	if not GUID then -- storage stage
	local act_take = r.GetActiveTake(item)
	local ret, act_GUID = r.GetSetMediaItemTakeInfo_String(act_take, 'GUID', '', false)
	return act_GUID
	else -- restoration stage
	local act_take = r.GetMediaItemTakeByGUID(0, act_GUID) -- this ensures that the same take remains active no matter the position
	r.SetActiveTake(act_take)
	end
end



function Delete_Track_Items(tr)
	for i = r.CountTrackMediaItems(tr),0,-1 do
	local item = r.GetTrackMediaItem(tr,i)
	local del = item and r.DeleteTrackMediaItem(tr, item)
	end
end


function Count_Track_Sel_Items1(tr)

local itm_cnt = r.CountTrackMediaItems(tr)
	if itm_cnt > 0 then
	local t = {}
		for i = 0, itm_cnt-1 do
		local item = r.GetTrackMediaItem(tr,i)
			if r.IsMediaItemSelected(item) then t[#t+1] = item end
		end
	end

return itm_cnt > 0, #t

end


local function Count_Track_Sel_Items2(tr, tr_itm_cnt)
local counter = 0
	for i = 0, tr_itm_cnt-1 do
	local item = r.GetTrackMediaItem(tr, i)
		if r.IsMediaItemSelected(item) then counter = counter+1 end
	end
return counter
end


function Get_Folder_Rightmost_Item_RightEdge(tr)

local is_folder = ({r.GetTrackState(tr)})[2]&1 == 1
local par_tr_depth = r.GetTrackDepth(tr)
local idx = r.CSurf_TrackToID(tr, false)
local rightmost_itm_r_edge = 0
	if is_folder then
		for i = idx, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i) -- next track after folder parent/1st child track
		local tr_depth = r.GetTrackDepth(tr)
			if tr_depth <= par_tr_depth or tr_depth == 0 then break end -- either the same or higher nested level within higher level folder or a regular track (outside of the folder)
		local tr_item_cnt = r.CountTrackMediaItems(tr)
			if tr_item_cnt > 0 then
			local tr_last_itm = r.GetTrackMediaItem(tr, r.CountTrackMediaItems(tr)-1)
			local tr_last_itm_r_edge = r.GetMediaItemInfo_Value(tr_last_itm, 'D_POSITION') + r.GetMediaItemInfo_Value(tr_last_itm, 'D_LENGTH')
			rightmost_itm_r_edge = tr_last_itm_r_edge > rightmost_itm_r_edge and tr_last_itm_r_edge or rightmost_itm_r_edge
			end
		end
	end

return rightmost_itm_r_edge

end



function Generate_Consistent_IID_Sequence(itm) -- for items overlapping the one passed in the arg, included // uses chunk functions
-- same as using native actions:
--ACT(40068) -- Item lanes: Move item up one lane (when showing overlapping items in lanes)
--ACT(40107) -- Item lanes: Move item down one lane (when showing overlapping items in lanes)
-- only works in builds up until 6.53, since then the behavior drastically changed
-- https://forum.cockos.com/showthread.php?t=267390

	if not itm then return end

local tr = r.GetMediaItemTrack(itm)
local is_tr_sel = r.IsTrackSelected(tr)

	if not is_tr_sel then r.SetTrackSelected(tr, true) end -- selected true

	for i = 1, 50 do -- expand track height so overlapping item heights differ, i.e. none is collapsed
	-- may affect other selected tracks, but all are restored later
	r.Main_OnCommand(41325, 0) -- View: Increase selected track heights
	end

local get_item_props = r.GetMediaItemInfo_Value
local start = get_item_props(itm, 'D_POSITION')
local length = get_item_props(itm, 'D_LENGTH')
local t = {}
	for i = 0, r.GetTrackNumMediaItems(tr)-1 do
	local itm = r.GetTrackMediaItem(tr, i)
	local st = get_item_props(itm, 'D_POSITION')
	local len = get_item_props(itm, 'D_LENGTH')
	local I_LASTY = get_item_props(itm, 'I_LASTY')
	local overlap = st < start+length and st+len > start
		if overlap then -- overlaps item passed in the argument
		t[#t+1] = {itm = itm, I_LASTY = I_LASTY}
		elseif not overlap and #t > 0 then break -- past overlapping items cluster
		end
	end

	table.sort(t, function(a, b) return a.I_LASTY < b.I_LASTY end) -- sort by height

	for k, v in ipairs(t) do -- assign IIDs according to the height
	local itm = v.itm
	local ret, chunk = GetObjChunk2(itm)
	local chunk = not chunk:match('\nIID %d+') and chunk:gsub('IGUID .-\n', '%0IID '..(k-1)..'\n') or chunk:gsub('\nIID %d+', '\nIID '..k-1) -- -1 because IID sequence is 0 based white table index is 1 based
	SetObjChunk2(itm, chunk)
	end

	for i = 1, 50 do -- restore original track height
	r.Main_OnCommand(41326, 0) -- View: Decrease selected track heights
	end

	if not is_tr_sel then r.SetTrackSelected(tr, false) end -- selected true // deselect item track if it wasn't selected originally

end


function Are_There_Overlapping_Itms(sel_itm) -- find if there're items overlapping the selected one // returns boolean and a table
local get_item_props = r.GetMediaItemInfo_Value
local t = {}
local start = get_item_props(sel_itm, 'D_POSITION')
local length = get_item_props(sel_itm, 'D_LENGTH')
local tr = r.GetMediaItemTrack(sel_itm)
	for i = 0, r.GetTrackNumMediaItems(tr)-1 do
	local itm = r.GetTrackMediaItem(tr, i)
	local st = get_item_props(itm, 'D_POSITION')
	local len = get_item_props(itm, 'D_LENGTH')
		if st < start+length and st+len > start then -- covers both full and partial overlap
	--	return true -- or any other valid data type: 1, '', {} -- if table isn't needed
		local ret, chunk = GetObjChunk2(itm)
			if ret == 'err_mess' then Err_mess('data in one of the items') return r.defer(function() do return end end)
			else
			local chunk = not chunk:match('IID %d+') and chunk:gsub('IGUID .-\n', '%0IID 0\n') or chunk -- replace nil IID with 0 so the sequence can be used for table sorting
			t[#t+1] = chunk -- // or t[#t+1] = itm -- depending on the design
			end
		end
	end

return #t > 0, t

end


function Are_Itms_Overlapping(itm, want_count) -- find if there're items overlapping one passed as the argument
-- if want_count arg is true returns count of overlapping items less the one passed as itm arg or returns false
-- otherwise returns true if there're at least 1 overlapping item
local get_item_props = r.GetMediaItemInfo_Value
local tr = r.GetMediaItemTrack(itm)
local start = get_item_props(itm, 'D_POSITION')
local length = get_item_props(itm, 'D_LENGTH')
local cnt = 0
	for i = 0, r.GetTrackNumMediaItems(tr)-1 do
	local tr_itm = r.GetTrackMediaItem(tr, i)
	local st = get_item_props(tr_itm, 'D_POSITION')
	local len = get_item_props(tr_itm, 'D_LENGTH')
		if tr_itm ~= itm and st < start+length and st+len > start then
		cnt = cnt + 1
			if not want_count then return true end -- if at least one overlapping
		end
	end
return cnt > 0 and cnt
end


function Are_Two_Items_Overlapping(itm1, itm2)
	if not itm1 or not itm2 then return end -- false
local get_item_props = r.GetMediaItemInfo_Value
local get_track = r.GetMediaItemTrack
local st1 = get_item_props(itm1, 'D_POSITION')
local len1 = get_item_props(itm1, 'D_LENGTH')
local st2 = get_item_props(itm2, 'D_POSITION')
local len2 = get_item_props(itm2, 'D_LENGTH')
	return st2 < st1+len1 and st2+len2 > st1 and get_track(itm1) == get_track(itm2) -- true
end


function Count_Selected_Overlapping_Itms(itm) -- for 'explode' routine
-- including the item in the argument
local get_item_props = r.GetMediaItemInfo_Value
local start = get_item_props(itm, 'D_POSITION')
local length = get_item_props(itm, 'D_LENGTH')
local tr = r.GetMediaItemTrack(itm)
local selected_cntr = 0
	for i = 0, r.GetTrackNumMediaItems(tr)-1 do
	local tr_itm = r.GetTrackMediaItem(tr, i)
	local st = get_item_props(tr_itm, 'D_POSITION')
	local len = get_item_props(tr_itm, 'D_LENGTH')
	local itms_overlapping = st < start+length and st+len > start
		if itms_overlapping and r.IsMediaItemSelected(tr_itm) then
		selected_cntr = selected_cntr + 1
		end
	end
return selected_cntr
end



function Get_Outermost_Overlapping_Item(are_lanes_collapsed, tr, start, length) -- for 'explode' and 'crop' when item lanes are collapsed
local overlap_itm_cnt, outermost_itm = 0
	if are_lanes_collapsed then	-- get the outermost item to be able to crop everything to it if it happens to be selected
		for i = 0, r.GetTrackNumMediaItems(tr)-1 do -- tr is sel_itm track
		local tr_itm = r.GetTrackMediaItem(tr, i)
		local st = get_item_props(tr_itm, 'D_POSITION')
		local len = get_item_props(tr_itm, 'D_LENGTH')
		local overlap = st < start+length and st+len > start -- start & length are sel_itm properties
			if overlap then
			outermost_itm = tr_itm
			overlap_itm_cnt = overlap_itm_cnt+1
			end
		end
	end
return outermost_itm, outermost_itm and r.IsMediaItemSelected(outermost_itm), overlap_itm_cnt > 1 and overlap_itm_cnt-1 or 0 -- accounting for the item against which evaluation is being done to exclude it
end



function Overlapping_Itms_Props(itm, count_overlap, count_sel)
-- combines Are_Itms_Overlapping() and Count_Selected_Overlapping_Itms()
-- count_overlap and count_sel are booleans, return vals are integers
-- if both count_overlap and count_sel are true return val is boolean
-- indicating whether all overlapping items are selected
	if not count_overlap and not count_sel then return end
--local count_overlap = not count_sel
--local count_sel = not count_overlap
local get_item_props = r.GetMediaItemInfo_Value
local start = get_item_props(itm, 'D_POSITION')
local length = get_item_props(itm, 'D_LENGTH')
local tr = r.GetMediaItemTrack(itm)
local cntr = 0 -- excluding the item in the argument
local selected_cntr = 0 -- including the item in the argument
	for i = 0, r.GetTrackNumMediaItems(tr)-1 do
	local tr_itm = r.GetTrackMediaItem(tr, i)
	local st = get_item_props(tr_itm, 'D_POSITION')
	local len = get_item_props(tr_itm, 'D_LENGTH')
	local itms_overlapping = st < start+length and st+len > start
		if count_overlap and itms_overlapping and tr_itm ~= itm then
		cntr = cntr+1
		end
		if count_sel and itms_overlapping and r.IsMediaItemSelected(tr_itm) then
		selected_cntr = selected_cntr+1
		end
	end
return count_overlap and count_sel and cntr > 0 and cntr+1 == selected_cntr
or count_overlap and not count_sel and cntr
or count_sel and not count_overlap and selected_cntr
end



function Are_Itms_Overlapping_Selected_Collapsed(t) -- t is an array storing selected items, optional
-- returns 5 boolean values:
-- true if there's at least one item overlapping each of those stored in the table or currently selected
-- true if there're no non-selected items among items overlapping each of those stored in the table or currently selected
-- first 2 return values must both be true to conclude that in all targeted clusters of overlapping items all items are selected
-- true if there're no items overlapping any of those stored in the table or currently selected
-- true if overlapping and non-overlapping items are all selected
-- true if selected item lanes are collapsed excluding non-overlapping items

local is_build_6_54_onward = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.54 -- or '[%d%.]+'
local lanes_collapsed_cnt = 0

local get_item_props = r.GetMediaItemInfo_Value
local overlap_cnt, non_selected = 0, 0
local cnt = t and #t or r.CountSelectedMediaItems(0)
	for i = 1, cnt do
	local sel_itm = t and t[i] or r.GetSelectedMediaItem(0, i-1)
	local start = get_item_props(sel_itm, 'D_POSITION')
	local length = get_item_props(sel_itm, 'D_LENGTH')
	local tr = r.GetMediaItemTrack(sel_itm)
	local prev_itm = r.GetSelectedMediaItem(0, i-2)
	local prev_itm_tr = t and t[i-1] and r.GetMediaItemTrack(t[i-1]) or prev_itm and r.GetMediaItemTrack(prev_itm)
	local overlap = true -- condition count of overlapping items below
	local I_LASTY_init = 0
		for i = 0, r.GetTrackNumMediaItems(tr)-1 do
		local tr_itm = r.GetTrackMediaItem(tr, i)
		local st = get_item_props(tr_itm, 'D_POSITION')
		local len = get_item_props(tr_itm, 'D_LENGTH')
		local I_LASTY = get_item_props(tr_itm, 'I_LASTY')
		local itms_overlapping = st < start+length and st+len > start
			if overlap and tr_itm ~= sel_itm and itms_overlapping then -- covers both full and partial overlap, excluding the actual item being evaluated
			overlap_cnt = overlap_cnt + 1 -- for each selected only 1 will be counted
			overlap = false -- one is enough; all next cycles will be ignored
			end
			if itms_overlapping then
			non_selected = not r.IsMediaItemSelected(tr_itm) and non_selected + 1 or non_selected -- accurate counting of selected items is problematic so it's easier to count non-selected
			I_LASTY_init = tr_itm ~= sel_itm and (not is_build_6_54_onward and (I_LASTY > 15 and I_LASTY or I_LASTY_init)) or I_LASTY_init -- seek the greatest, excluding non-overlapping items with tr_itm ~= sel_itm because otherwise they too satisfy itms_overlapping boolean
			end
		end
	lanes_collapsed_cnt = I_LASTY_init and I_LASTY_init <= 15 and lanes_collapsed_cnt+1 or lanes_collapsed_cnt -- if no greater than 15 is found then register
	end


local all_overlap, all_sel, all_non_overlap, mixed = overlap_cnt == cnt, non_selected == 0, overlap_cnt == 0, overlap_cnt ~= 0 and overlap_cnt < cnt and non_selected == 0 -- all_non_overlap return value is required because overlap_cnt == cnt being false doesn't necessarily mean that there're no items overlapping the selected, the selection could be mixed, likewise overlap_cnt > 0 for the same reason doesn't always mean that all items are being overlapped

local lanes_collapsed = not is_build_6_54_onward and lanes_collapsed_cnt > 0  -- relevant when overlapping item lanes are collapsed at certain TCP height or only 1 lane is set in Preferences -> Appearance in builds prior to 6.54
--or is_build_6_54_onward and Check_reaper_ini('itemoverlap_offspct', '0') -- or 'Offset by' is 0 at Preferences -> Appearance -> Media Item Positioning in builds 6.54 onward // doesn't make sense as overlapping items feature doesn't work since 6.54

return all_overlap, all_sel, all_non_overlap, mixed, lanes_collapsed -- the last value will be used to offset all_sel because in collapsed lanes selection of all is allowed by design

end


function Are_Overlapping_Itm_Lanes_Collapsed(...)
-- arguments must be either tr, itm OR tr, itm_start, itm_length
-- start, length args are selected item props // returns true when in builds prior to 6.54 I_LASTY val of every overlapping item <= 15 when TCP is at certain height, when Preferences -> Appearance -> Maximum number of lanes when showing overlapping items in lanes option is set to 1, and when in builds 6.54 onward Preferences -> Appearance -> Media Item Positioning -> Offset by is set to 0 // for items in FIPM only works if TCP is fully collapsed for REAPER builds prior to 6.54 or when the track height is less than the value at Preferences -> Appearance -> Media Item Positioning -> Collapse free item positioning when track height is less than since build 6.54

local tr, itm, start, length
local get_item_props = r.GetMediaItemInfo_Value

	if #(...) == 2 then
	tr, itm = table.unpack(...)
	start = get_item_props(itm, 'D_POSITION')
	length = get_item_props(itm, 'D_LENGTH')
	elseif #(...) == 3 then
	tr, start, length = table.unpack(...)
	else break
	end

local build = tonumber(r.GetAppVersion():match('[%d%.]+'))

local function Get_reaper_ini(key)
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
	return cont:match(key..'=(%d+)')
end

	if build < 6.54 then
	local f = io.open(r.get_ini_file(),'r')
	local cont = f:read('*a')
	f:close()
		if Get_reaper_ini('maxitemlanes') == '1' then return true -- Preferences -> Appearance -> Maximum number of lanes is 1
		else
		local overlap_cnt = 0
		local I_LASTY_cnt = 0
			for i = 0, r.GetTrackNumMediaItems(tr)-1 do
			local itm = r.GetTrackMediaItem(tr, i)
			local st = get_item_props(itm, 'D_POSITION')
			local len = get_item_props(itm, 'D_LENGTH')
				if st < start+length and st+len > start then -- covers both full and partial overlap
				overlap_cnt = overlap_cnt+1
					if get_item_props(itm, 'I_LASTY') <= 15 then
				-- 	if get_item_props(itm, 'I_LASTH') <= 15 then -- I_LASTY and I_LASTH values always seem identical
					I_LASTY_cnt = I_LASTY_cnt+1
					end
				end
			end
			if overlap_cnt == I_LASTY_cnt then return true end -- collapsed when I_LASTY val of every overlapping item <= 15 // 15 seems to be valid across different themes // the condition is also true when only 1 lane is set at Preferences -> Appearance -> Maximum number of lanes when showing overlapping items in lanes, 'maxitemlanes' value in reaper.ini
	--[[
	elseif -- 6.54 onward // doesn't make sense as overlapping items feature doesn't work since 6.54
	local f = io.open(r.get_ini_file(),'r')
	local cont = f:read('*a')
	f:close()
		if Get_reaper_ini('itemoverlap_offspct') == '0' then return true -- Preferences -> Appearance -> Media Item Positioning -> Offset by is 0
	]]
	end

--[[ UNNECESSARY
-- If the above expression is false, check if total number of overlapping items is less than the number of lanes set at Preferences -> Appearance -> Maximum number of lanes when showing overlapping items in lanes
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local maxitemlanes = cont:match('maxitemlanes=(%d+)')
-- https://forums.cockos.com/showpost.php?p=2422782&postcount=20
	if tonumber(maxitemlanes) < overlap_cnt then return true end
]]

end



function Shift_Overlapping_Items_Together(sel_itm, val) -- overlapping the selected one, shift by val
local start = r.GetMediaItemInfo_Value(sel_itm, 'D_POSITION')
local length = r.GetMediaItemInfo_Value(sel_itm, 'D_LENGTH')
local tr = r.GetMediaItemTrack(sel_itm)
local t = {} -- table to avoid chaos in items order when they start being moved, otherwise moving rightwards the loop must be reversed and moving leftwards - direct
	for i = 0, r.GetTrackNumMediaItems(tr)-1 do
	local itm = r.GetTrackMediaItem(tr, i)
	local st = r.GetMediaItemInfo_Value(itm, 'D_POSITION')
	local len = r.GetMediaItemInfo_Value(itm, 'D_LENGTH')
		if st < start+length and st+len > start then
		t[#t+1] = itm
		end
	end
	for _, itm in ipairs(t) do
	local st = r.GetMediaItemInfo_Value(itm, 'D_POSITION')
	r.SetMediaItemInfo_Value(itm, 'D_POSITION', st+val)
	end
end



function Is_Overlapping_In_Lanes(item, want_count)
-- want_count is boolean to return the actual count of items 
-- overlapping the source one and including it;
-- prior to build 6.54 overlapping items lanes could collapse of the track height wasn't sufficient
-- to accommodate them, since that build items are always displayed in lanes as long as the setting
-- at Preferences -> Appearance -> Zoom/Scroll/Offset -> Offset by ... of item height is not 0
-- the Preference path is as of build 7.22, in earlier builds it was different
	if r.GetToggleCommandStateEx(0, 40507) == 1 then -- Options: Offset overlapping media items vertically AKA Show overlapping media items in lanes (when room)
	local GetItem, GetTrack = r.GetMediaItemInfo_Value, r.GetMediaTrackInfo_Value
	local tr = r.GetMediaItemTrack(item)
	-- check if there're items overlapping the current one by comparing item and track height
	-- the difference between item_h and tr_h is greater than the offset measured with item_y
	-- even without the icon bar there's still difference, across all tested themes it's 4 px
		and GetTrack(tr, 'I_TCPH')-GetItem(item, 'I_LASTH')-GetItem(item, 'I_LASTY') > 4 -- I_LASTH doesn't include icon top bar if any, so if the difference is greater than 4 px the TCP size is greater than needed to accommodate 1 item which means there's at least 1 overlapping item
		then
			if not want_count then return true end
		local start = GetItem(item, 'D_POSITION')
		local length = GetItem(item, 'D_POSITION')
		local count = 1 -- accounting for the source item
		local item_idx
			for i = 0, r.GetTrackNumMediaItems(tr)-1 do
			local tr_itm = r.GetTrackMediaItem(tr, i)
			local st = GetItem(tr_itm, 'D_POSITION')
			local len = GetItem(tr_itm, 'D_LENGTH')
				if tr_itm ~= item and st < start+length and st+len > start then
				count = count+1
				elseif tr_itm == item then
				item_idx = i
				end
			end
		return count, item_idx -- item index doesn't necessarily indicate the index of its lane if the option 'Arrange in order they were created' isn't enabled at Preferences -> Appearance -> Zoom/Scroll/Offset
	end
end



function Count_Sel_Itms_Unique_Tracks(t)
local cnt = 0
local tr_init
-- REAPER devs don't recommend using CountSelectedMediaItems()
-- and GetSelectedMediaItem in favor of CountMediaItems()
-- and IsMediaItemSelected() instead
-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
local fin = t and #t or r.CountSelectedMediaItems(0)
	for i = 1, fin do
	local itm = t and t[i] or r.GetSelectedMediaItem(0,i-1)
	local tr = r.GetMediaItemTrack(itm)
	cnt = tr ~= tr_init and cnt + 1 or cnt
	tr_init = tr
	end
return cnt
end


function Get_Item_Greatest_And_1st_Availab_Group_IDs1()
local t = {}
	for i = 0, r.CountMediaItems(0)-1 do
	local group_id = r.GetMediaItemInfo_Value(r.GetMediaItem(0,i), 'I_GROUPID')
		if group_id > 0 then t[#t+1] = group_id end
	end
table.sort(t)
return t[#t], t[#t]+1
end


function Get_Item_Greatest_And_1st_Availab_Group_IDs2()
local group_id_store = 0
	for i = 0, r.CountMediaItems(0)-1 do
	local group_id = r.GetMediaItemInfo_Value(r.GetMediaItem(0,i), 'I_GROUPID')
		if group_id > group_id_store then group_id_store = group_id end
	end
return group_id_store, group_id_store+1
end



function get_same_group_items(item, sel_itms_t)
	local function get_group(item)
	return r.GetMediaItemInfo_Value(item, 'I_GROUPID')
	end
local group = get_group(item)
sel_itms_t[item] = {}
local t = sel_itms_t[item]
	if group > 0 then -- 0 no group	
		for i=0, r.CountMediaItems(0)-1 do
		local item = r.GetMediaItem(0,i)
			if get_group(item) == group and not sel_itms_t[item] then -- store if not already stored as selected
				if r.IsMediaItemSelected(item) then -- if selected, store as selected in the main table
				sel_itms_t[#sel_itms_t+1] = item
				sel_itms_t[item] = ''
				else -- store as grouped
				table.insert(t, item)
				end
			end
		end
	end
return sel_itms_t
end




function Insert_Empty_Item_To_Display_Text1(output) -- relies on Re_Store_Selected_Objects(); for the item notes to recognize line breaks in the output they must be replaced with '\r\n' if the string wasn't previously formatted in the notes field https://forum.cockos.com/showthread.php?t=214861#2
local sel_itms_t, sel_trk_t = Re_Store_Selected_Objects() -- store
local cur_pos = r.GetCursorPosition() -- store
r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false
r.SetOnlyTrackSelected(r.GetTrack(0,r.GetNumTracks()-1)) -- select the newly inserted track
r.SetEditCurPos(-3600, true, false) -- moveview true, seekplay false // move to -3600 or -1 hour mark in case project time start is negative, will surely move cursor to the very project start to reveal the notes item
r.SelectAllMediaItems(0, false) -- selected false // deselect all
r.Main_OnCommand(40142,0) -- Insert empty item
local item = r.GetSelectedMediaItem(0,0)
	--[[
	local path = r.GetResourcePath()
	local temp_file = path..path:match('[\\//]')..'preset_list_temp'
	local f = io.open(temp_file, 'w')
	f:write(output); f:close()
	local f = io.open(temp_file, 'r')
	local output = f:read('*a')
	f:close(); os.remove(temp_file)
	]]
r.GetSetMediaItemInfo_String(item, 'P_NOTES', output, true) -- setNewValue true
-- Open the empty item notes
r.SetMediaItemSelected(r.GetSelectedMediaItem(0,0),true) -- selected true
r.Main_OnCommand(40850,0) -- Item: Show notes for items...
Re_Store_Selected_Objects(sel_itms_t, sel_trk_t) -- restore originally selected objects
r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false; restore position
end


function Insert_Empty_Item_To_Display_Text2(tr) -- tr is the target track
-- USED IN 'Track embedded notes displayed as a tooltip'
-- relies on Re_Store_Selected_Objects(); for the item notes to recognize line breaks in the output they must be replaced with '\r\n' if the string wasn't previously formatted in the notes field https://forum.cockos.com/showthread.php?t=214861#2

local tr_GUID = r.GetTrackGUID(tr)

local retval, tr_name = r.GetTrackName(tr)
local ret, notes = r.GetSetMediaTrackInfo_String(tr, 'P_EXT:NOTES', '', false)
local notes = not ret and ACCESS_SWS_TRACK_NOTES and Load_SWS_Track_Notes(tr):gsub('\n\n','\r\n\r\n') or notes -- load SWS track notes if no notes and the setting is enabled, adding carriage return char to the notes edition warning divider, if any, for correct display in the item notes window
local notes = notes:match('([\0-\255]+)\n \n%d+') or notes -- exclude date if there're stored notes

local sel_itms_t, sel_trk_t = Re_Store_Selected_Objects() -- store
local cur_pos = r.GetCursorPosition() -- store

-- Insert notes track and configure
local tr_idx = r.CSurf_TrackToID(tr, false) -- mcpView false
local tr_idx = tr_idx == 0 and 0 or tr_idx -- CSurf_TrackToID returns idx 0 for the master track and 1-based idx for the rest
r.InsertTrackAtIndex(tr_idx, false) -- wantDefaults false
local notes_tr = r.CSurf_TrackFromID(tr_idx+1, false) -- mcpView false
r.GetSetMediaTrackInfo_String(notes_tr, 'P_NAME', 'Track '..tr_idx..' notes', true) -- setNewValue true
r.GetSetMediaTrackInfo_String(notes_tr, 'P_EXT:NOTES_TRACK', '+', true) -- setNewValue true // add extended data to be able to find the track later if left undeleted

-- Insert notes item and configure
r.SetEditCurPos(-3600, false, false) -- moveview, seekplay false // move to -3600 or -1 hour mark in case project time start is negative, will surely move cursor to the very project start to reveal the notes item // thanks to moveview false the notes item will be accessible from anywehere in the project since its length will be set to full project length below

local notes_item = r.AddMediaItemToTrack(notes_tr)
r.SetMediaItemSelected(notes_item, true) -- selected true // to be able to open notes with action
local proj_len = r.GetProjectLength(0)

r.SetMediaItemInfo_Value(notes_item, 'D_LENGTH', proj_len == 0 and 5 or proj_len) -- set notes item length to full project length if there're time line objects, if there's none and so proj length is 0 then set to 5 sec
r.AddTakeToMediaItem(notes_item) -- creates a quasi-MIDI item so label can be added to it since label (P_NAME) is a take property // the item is affected by actions 'SWS/BR: Add envelope points...', 'SWS/BR: Insert 2 envelope points...' and 'SWS/BR: Insert envelope points on grid...' when applied to the Tempo envelope which cause creation of stretch markers in the item
r.GetSetMediaItemTakeInfo_String(r.GetActiveTake(notes_item), 'P_NAME', 'track "'..tr_name..'"', true) -- setNewValue true // add label to the notes item
r.GetSetMediaItemInfo_String(notes_item, 'P_NOTES', notes, true) -- setNewValue true // load notes
r.GetSetMediaItemInfo_String(notes_item, 'P_EXT:NOTES_ITEM', tr_GUID, true) -- setNewValue true // add extended data to be able to find the item later if left undeleted and to find the target track to store the notes to
-- Open the empty item notes
r.Main_OnCommand(40850,0) -- Item: Show notes for items... -- CAUSES CRASH IF THE ITEM IS CLICKED RAPIDLY

Re_Store_Selected_Objects(sel_itms_t, sel_trk_t) -- restore originally selected objects
r.SetEditCurPos(-3600, true, false) -- moveview true, seekplay false // move to -3600 or -1 hour mark in case project time because the Arrange view may move when the item is inserted in case Preferences -> Editing behavior -> Move edit cursor when pasing/insering media is enabled
r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false; restore position

end



function Insert_Image()
-- change path, image file name and undo point title in the code

local chunk = [[
<ITEM
POSITION 0
SNAPOFFS 0
LENGTH 8
LOOP 1
ALLTAKES 0
FADEIN 1 0 0 1 0 0 0
FADEOUT 1 0 0 1 0 0 0
MUTE 0 0
SEL 1
IGUID {3E42B32C-B52E-4644-A494-DFDBCFB163B9}
IID 1
RESOURCEFN "F:\Program Files\REAPER (x64)\Scripts\MY\my_Transcribing\Transcribing toolbar layout.png"
IMGRESOURCEFLAGS 5
NOTESWND 197 95 1198 659
>
]]

r.Undo_BeginBlock()
-- the function will faulter here if it's already used outside of the function
-- in which case scr_name will have to be passed as an argument
local is_new_value, scr_name, sect_ID, cmd_ID, mode, resol, val, contextstr = r.get_action_context()
local img_name = 'Transcribing 2 toolbar layout.png'
local path = scr_name:match('.+[\\/]')..img_name
	if r.file_exists(path) then
	local GetSet = r.GetSetMediaTrackInfo_String
	local img_tr
	-- search for an empty file with the image inserted earler to prevent duplication on successive script runs
	-- when the toolbar file gets overwritten this function doesn't run
		for i=r.GetNumTracks()-1, 0, -1 do
		local tr = r.GetTrack(0,i)
		local ret, ext = GetSet(tr, 'P_EXT:'..img_name, '', false) -- setNewValue false
			if ret then
				for i=0,r.CountTrackMediaItems(tr)-1 do
				local item = r.GetTrackMediaItem(tr,i)
					if r.CountTakes(item) == 0 then -- OR not r.GetActiveTake(item) // empty items don't have takes
					local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo false
						if chunk:match('RESOURCEFN "'..Esc(path)..'"') then return end -- already exists
					end
				end
			img_tr = tr
			break end
		end
	--Msg(path)
		if not img_tr then
		r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefault false
		img_tr = r.GetTrack(0,r.GetNumTracks()-1)
		end
	local item = r.AddMediaItemToTrack(img_tr)
	GetSet(img_tr, 'P_NAME', 'Transcribing 2 toolbar layout', true) -- setNewValue true
	GetSet(img_tr, 'P_EXT:'..img_name, '1', true) -- setNewValue true
	chunk = chunk:gsub('RESOURCEFN.-\n', 'RESOURCEFN "'..path..'"\n')
	--Msg(chunk)
	r.SetItemStateChunk(item, chunk, false) -- isundo false
	local st_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0) -- isSet false
	r.SetMediaItemInfo_Value(item, 'D_LENGTH', end_time)
--	r.UpdateArrange()
		if r.GetCursorPosition() < end_time then -- prevent edit cursor crossing the image
		r.SetEditCurPos(0,true,false) -- moveview true, seekplay false
		end
	-- The image may end up being a bit cut off on the left if zoom level is not high enough
	-- but couldn't figure out a way to ensure the sweet spot of the zoom level, Set_Horiz_Zoom_Level() didn't help
	r.CSurf_OnScroll(-400,0) -- scroll horizontally left, 1 scroll unit is 16 px so scroll 6400 px which should be enough to reach the project start
--	Set_Horiz_Zoom_Level(10)
--	r.CSurf_OnScroll(2,0)
	GetSet_Track_Zoom_100_Perc(img_tr)
--	r.UpdateArrange()
	end
r.Undo_EndBlock('Insert Transcribing toolbar layout image', -1)

end



function Insert_Temp_Item(temp_tr, file_path, item_props_t, take_props_t)
-- for adding temp_tr see Insert_Temp_Track()
-- item_props_t, take_props_t are associative arrays of item and take attribute names and value to be set

-- THE RESULTING ITEM WHILE BEHAVING LIKE AN EMPTY ITEM WHEN CLICKED,
-- HAS FX CHAIN AND TAKE NAME FIELD, ITEM BUTTONS ARE NOT DISPLAYED
-- SO LOOKS TIDER AND FX CHAIN CAN ONLY BE ACCESSED VIA ITEM PROPERTIES DIALOGUE
local temp_itm = r.AddMediaItemToTrack(temp_tr)
local take = r.AddTakeToMediaItem(temp_itm)
local pcm_src = r.PCM_Source_CreateFromFile(file_path)
r.SetMediaItemTake_Source(take, pcm_src)
r.GetSetMediaItemTakeInfo_String(take, 'P_NAME', file_path:match('[^\\/]+$'), true) -- setNewValue true, name after source file
local Set_Item, Set_Take = r.SetMediaItemInfo_Value, r.SetMediaItemTakeInfo_Value
	
	for attr, val in pairs(item_props_t) do
	Set_Item(temp_itm, attr, val)
	end
	
	for attr, val in pairs(take_props_t) do
	Set_Take(take, attr, val)
	end
	
-- DO STUFF AND STORE VALUES

r.DeleteTrackMediaItem(temp_tr, temp_itm) -- or the entire track can be deleted if not needed any longer
-- r.DeleteTrack((temp_tr)
r.PCM_Source_Destroy(pcm_src)

-- RETURN STUFF

end



function Insert_Item_On_Temp_Track(tr_name)

r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefaults false; insert new track at end of track list and hide it; action 40702 'Track: Insert new track at end of track list' creates undo point hence unsuitable
local temp_tr = r.GetTrack(0,r.CountTracks(0)-1)
local name = tr_name and r.GetSetMediaTrackInfo_String(temp_tr, 'P_NAME', tr_name, true) -- setNewValue true
r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINMIXER', 0) -- hide in Mixer
r.SetMediaTrackInfo_Value(temp_tr, 'B_SHOWINTCP', 0) -- hide in Arrange // hiding in Arrange will prevent Gluing track item, the Glue action won't work
local temp_itm = r.AddMediaItemToTrack(temp_tr)
local take = r.AddTakeToMediaItem(temp_itm)

return temp_tr, temp_itm, take

end


function Get_Item_Edge_At_Mouse() -- Combined with Get_Item_Track_Segment_At_Mouse() can be used to get 4 item corners at the mouse cursor
local cur_pos = r.GetCursorPosition()
local x, y = r.GetMousePosition()
local item, take = r.GetItemFromPoint(x,y, false) -- allow_locked false
local left_edge, right_edge
	if item then
	r.PreventUIRefresh(1)
	local px_per_sec = r.GetHZoomLevel() -- 100 px per 1 sec = 1 px per 0.01 sec or 10 ms
	local left = r.GetMediaItemInfo_Value(item, 'D_POSITION')
	local right = left + r.GetMediaItemInfo_Value(item, 'D_LENGTH')
	r.Main_OnCommand(40514, 0) -- View: Move edit cursor to mouse cursor (no snapping)
	local new_cur_pos = r.GetCursorPosition()
		if math.abs(left - new_cur_pos) <= 0.01*(1000/px_per_sec) -- condition the minimal distance by the zoom resolution, the greater the zoom-in the smaller is the required distance, the base value of 10 ms or 1 px which is valid for zoom at 100 px per 1 sec seems optimal, 1000/px_per_sec is ms per pixel; OR 0.01/(px_per_sec/1000) px_per_sec/1000 is pixels per ms // only cursor position inside item is respected
		then
		left_edge = true
		elseif math.abs(right - new_cur_pos) <= 0.01*(1000/px_per_sec) then
		right_edge = true
		end
	r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false // restore orig edit cursor pos
	r.PreventUIRefresh(-1)
	end
return left_edge, right_edge
end



function Get_Sel_Items_St_And_End()
local first_start = math.huge -- when note or repeats value is negative (leftward duplication) we search for the earliest pos value
local last_end = math.huge*-1 -- when duplicating rightwards we search for the latest end value
	for i = 0, r.CountSelectedMediaItems(0)-1 do
	-- REAPER devs don't recommend using CountSelectedMediaItems()
	-- and GetSelectedMediaItem in favor of CountMediaItems()
	-- and IsMediaItemSelected() instead
	-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
	local item = r.GetSelectedMediaItem(0,i)
	local item_pos = r.GetMediaItemInfo_Value(item, 'D_POSITION')
	first_start = item_pos < first_start and item_pos or first_start -- get the earliest pos value amongst selected items because when copying/pasting multiple items which maintain their relative positions that's the defining value
	local fin = item_pos + r.GetMediaItemInfo_Value(item, 'D_LENGTH')
	last_end = fin > last_end and fin or last_end -- get the latest end value amongst selected items to place cursor at to emulate duplicate action
	end
return first_start, last_end
end


function Is_Same_Items_Track() -- whether all selected items belong to the same track
-- REAPER devs don't recommend using CountSelectedMediaItems()
-- and GetSelectedMediaItem in favor of CountMediaItems()
-- and IsMediaItemSelected() instead
-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
local sel_itm_cnt = r.CountSelectedMediaItems(0)
	if sel_itm_cnt > 0 then
	local ref_tr = r.GetMediaItemTrack(r.GetSelectedMediaItem(0,0))
		for i = 0, sel_itm_cnt-1 do
			if r.GetMediaItemTrack(r.GetSelectedMediaItem(0,i)) ~= ref_tr then return false end
		end
	end
return true
end


function REVERSE_TAKES_VIA_CHUNK(item)
local ret, chunk = GetItemChunk(item) -- FUNCTION
	if ret == 'error' then Err_mess() return end -- FUNCTION
local take_cnt = r.CountTakes(item)
	if take_cnt > 1 then
	local chunk_t = {chunk:match('(.+)(NAME[%W].-)'..string.rep('(TAKE[%W].-)', take_cnt-2)..'(TAKE[%W].+)>')} -- GET TAKE CHUNKS; repeat as many times as take count -2 since first and last take chunks are different; [%W] makes sure that only 'TAKE' tag is captured disregarding words which contain it of which there're a few, that is must be followed by anything but alphanumeric characters
	local part_one = chunk_t[1] -- store first part before takes
	table.remove(chunk_t,1) -- remove it
	local take_chunk_t = reverse_indexed_table(chunk_t) -- reverse, FUNCTION
	table.insert(take_chunk_t, #take_chunk_t, 'TAKE\n') -- add to the formerly 1st take now being the last as 1st take doesn't have 'TAKE' tag
	local take_chunk = table.concat(take_chunk_t):match('TAKE.-\n(.+)') -- concatenate, removing TAKE tag from the formerly last take now being the 1st, as 1st take shouldn't have 'TAKE' tag
	r.SetItemStateChunk(item, part_one..take_chunk..'>', false) -- isundo is false // adding chunk closure since it wasn't stored in the table
	r.UpdateItemInProject(item)
	end
end


------------------------ GET ITEM SEGMENTS AT MOUSE -------------------

-- Combined with Get_Item_Edge_At_Mouse() can be used to get 4 item corners at the mouse cursor

function Get_Arrange_and_Header_Heights1()
-- fetches data from a temporary project tab, WORKS, but isn't ideal because of being way too intrusive, project loading process is usually visible
-- if no SWS estension only works if the program window is fully open
-- only runs when there's track or item under mouse cursor

-- !!!!!!!!!!! since build 6.76 there's a new preference for maximum vertical zoom (reaper.ini key maxvzoom=0.50000000) which will break the function if not 100% as if affects the action 'View: Toggle track zoom to maximum height' used here to get Arrange height; it will still be possible to calculate it using the action, e.g. (track_height/max_height)*100 to find 100% value
-- a very convoluted alternative way is using actions 'Ruler: Set to default/max/min height', then checking toppane value in reaper.ini, checking where transport is located and toggling it temporarily off if on top, checking in reaper.ini for any toolbars/windows docked at the top, temporarily toggling it off, then adding about 90 px to toppane value and subtracting this from the screen or program window height depending on whether SWS extension is installed

local lt_scr, top_scr, rt_scr, bot_scr = r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true) -- true - work area, false - the entire screen // https://forum.cockos.com/showthread.php?t=195629#4
local sws = r.APIExists('BR_Win32_GetWindowRect')
local retval, rt, top, lt, bot = table.unpack(sws and {r.BR_Win32_GetWindowRect(r.GetMainHwnd())} or {nil})
--[[
local dimens_t = sws and {r.BR_Win32_GetWindowRect(r.GetMainHwnd())}
or {r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true)} -- true - work area, false - the entire screen // https://forum.cockos.com/showthread.php?t=195629#4
	if #dimens_t == 5 then table.remove(dimens_t, 1) end -- remove retval value if BR's function
local rt, top, lt, bot = table.unpack(dimens_t)
]]
local wnd_h = sws and bot-top or bot_scr
local retval, proj_state = r.GetProjExtState(0,'WINDOW DIMS','window_dims')
local state = retval == 0 and r.GetExtState('WINDOW DIMS','window_dims') or proj_state
local window_h, arrange_h = state:match('(.+);(.+)')
local wnd_h_offset = sws and top or 0 -- to add when calculating absolute track top edge coordinate inside Get_Item_Track_Segment_At_Mouse1() function when the sws extension is installed to be able to get segments in the shrunk program window, in this case 'top' value represents difference between program window top and full screen top coordinates which is needed to match mouse cursor Y coordinate which is absolute i.e. is relative to the full screen size // !!!! MIGHT NOT WORK ON MAC since there Y axis starts at the bottom

	if sws and window_h ~= wnd_h..'' or not window_h then -- either only update if sws extension is installed and program window height has changed or initially store

	-- get 'Maximum vertical zoom' set at Preferences -> Editing behavior, which affects max track height set with 'View: Toggle track zoom to maximum height', introduced in build 6.76
	local cont
		if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.76 then
		local f = io.open(r.get_ini_file(),'r')
		cont = f:read('*a')
		f:close()
		end
	local max_zoom = cont and cont:match('maxvzoom=([%.%d]+)\n') -- min value is 0.125 (13%), max is 8 (800%)
	local max_zoom = not max_zoom and 100 or max_zoom*100 -- ignore in builds prior to 6.76 by assigning 100 so that when track height is divided by 100 and multiplied by 100% nothing changes, otherwise convert to conventional percentage value; if 100 can be divided by the percentage (max_zoom) value without remainder (such as 50, 25, 20) the resulting value is accurate, otherwise there's ±1 px diviation, because the actual track height in pixels isn't fractional like the one obtained through calculation therefore some part is lost

	-- Get Arrange and window header height
	-- When track zoom actions are applied the UI jolts, but PreventUIRefresh() is not suitable 
	-- because it blocks the function GetMediaTrackInfo_Value() from getting the return value;
	-- toggle to minimum and to maximum height are mutually exclusive // selection isn't needed, all are toggled;
	-- in v7 action 'View: Toggle track zoom to maximum height (limit to 100% of arrange view)' was introduced
	-- which works like 40113 worked before the change and its use would obviate all the calculations above and below 
	-- but it obviously doesn't cover the interim builds, so leaving the current code;
	-- since build 7.48 the following toggle zoom actions affect pinned tracks as well,
	-- introduced in build 7.46, but since their height is being taken into account
	-- the calculation must still be accurate
	local cur_proj, projfn = r.EnumProjects(-1) -- store cur project pointer
	-- r.PreventUIRefresh(1) -- PREVENTS GetMediaTrackInfo_Value RETURN VALUE PROBABLY BECAUSE THE HIGHT ISN'T UPDATED AFTER ACTION
	r.Main_OnCommand(41929, 0) -- New project tab (ignore default template) // open new proj tab
	local dock_open = r.GetToggleCommandStateEx(0,40279) -- View: Show docker // the result of the action 'View: Toggle track zoom to maximum height' depends on the visibility of the bottom docker so if open it needs to be temporarily closed, the action 40279 applies to all dockers
		if dock_open then r.Main_OnCommand(40279,0) end -- View: Show docker // close docks
	r.InsertTrackAtIndex(0, false) -- wantDefaults false
	local ref_tr = r.GetTrack(0,0)
--	r.SetTrackSelected(ref_tr, true) -- selected true // not needed, the next actions are global
		if r.GetToggleCommandStateEx(0,40113) == 0 then
		r.Main_OnCommand(40113, 0) -- View: Toggle track zoom to maximum height (i.e. height of the Arrange) [in later builds comment '(limit to 100% of arrange view) has been added' and another action introduced to zoom to maxvzoom value] // selection isn't needed, all are toggled
		end
	local tr_height = r.GetMediaTrackInfo_Value(ref_tr, 'I_TCPH')/max_zoom*100 -- not including envelopes, action 40113 doesn't take envs into account; calculating track height as if it were zoomed out to the entire Arrange height by taking into account 'Maximum vertical zoom' setting at Preferences -> Editing behavior
	
	-- if there're visible pinned tracks at the top (introduced in build 7.46), calculate their height because
	-- their presence affects max track height obtained above
	local pin_tracks_h = 0
		if r.GetToggleCommandState(43573) == 0 then -- Track: Override/unpin all pinned tracks in TCP 
			for i=0, r.GetNumTracks()-1 do
			local tr = r.GetTrack(0,i)
				if r.IsTrackVisible(tr, false) -- mixer false
				and GetTrackVal(tr, 'B_TCPPIN') == 1 				
				then
				pin_tracks_h = pin_tracks_h + GetTrackVal(tr, 'I_WNDH') -- incl. envelopes
				end
			end
		end

	pin_tracks_h = pin_tracks_h > 0 and pin_tracks_h+10 or pin_tracks_h -- 10 px is pinned track area separator width	
	local tr_height = math.floor(tr_height + pin_tracks_h + 0.5) -- round; if 100 can be divided by the percentage (max_zoom) value without remainder (such as 50, 25, 20) the resulting value is integer, otherwise the calculated Arrange height is fractional because the actual track height in pixels is integer which is not what it looks like after calculation based on percentage (max_zoom) value, which means the value is rounded in REAPER internally because pixels cannot be fractional and the result is ±1 px diviation compared to the Arrange height calculated at percentages by which 100 can be divided without remainder
	r.SetExtState('WINDOW DIMS','window_dims', wnd_h..';'..tr_height, false) -- persist false
	r.SetProjExtState(cur_proj, 'WINDOW DIMS', 'window_dims', wnd_h..';'..tr_height)
	-- Close temp project tab without save prompt; when a freshly opened project closes there's no prompt
	-- the problem may emerge if the script is bound to a shortcut where Ctrl & Shift are used because this modifier combination is used to generate a prompt to load project with fx offlined, so the script shortcut must not include this combination; in reaper-kb.ini KEY codes Ctrl+Shift code (the first number) seems to be consistently 13, Ctrl+Alt+Shift is 29
	-- using dummy project doesn't help to overcome Ctrl+Shift issue
		if r.file_exists(projfn) then -- EnumProjects() returns empty string if project doesn't have a file and returns path even if the project file and possibly folder was deleted while the project is open
		r.Main_openProject('noprompt:'..projfn)
		r.Main_OnCommand(40860, 0) -- Close current project tab
		r.SelectProjectInstance(cur_proj) -- re-open orig proj tab
		end
		if dock_open then r.Main_OnCommand(40279,0) end -- View: Show docker // re-open docks
	-- r.PreventUIRefresh(-1)
	local header_height = bot - tr_height - 23 -- size between program window top edge and Arrange // 18 is horiz scrollbar height (regardless of the theme) and 'bot / window_h' value is greater by 4 px than the actual program window height hence 18+4 = 22 has to be subtracted + 1 more pixel for greater precision in targeting item top/bottom edges
	return tr_height, header_height, wnd_h_offset-- tr_height represents Arrange height // return updated data

	else return tonumber(arrange_h), window_h - arrange_h - 23, wnd_h_offset -- return previously stored data // calculation explication see above

	end

end



function Get_Arrange_and_Header_Heights2()
-- if no SWS extension only works if the program window is fully open
-- only runs when there's track or item under mouse cursor

-- !!! in newer builds, at least since 6.79 but likely since 6.76 when zoom height preference was added (from the changelog: Vertical zoom: overhaul, allow more fractional zoom state), actions 'View: Increase/Decrease selected track heights' don't work sharply any more in a loop so the change in track height when heights are restored is visible and ugly, especially when there're many tracks, so because of that Get_Arrange_and_Header_Heights1() version might be prefereable

-- !!!!!!!!!!! since build 6.76 there's a new preference for maximum vertical zoom (reaper.ini key maxvzoom=0.50000000) which will break the function if not 100% as if affects the action 'View: Toggle track zoom to maximum height' used here to get Arrange height; it will still be possible to calculate it using the action, e.g. (track_height/max_height)*100 to find 100% value
-- a very convoluted alternative way is using actions 'Ruler: Set to default/max/min height', then checking toppane value in reaper.ini, checking where transport is located and toggling it temporarily off if on top, checking in reaper.ini for any toolbars/windows docked at the top, temporarily toggling it off, then adding about 90 px to toppane value and subtracting this from the screen or propgarm window height depending on whether SWS extension is installed

local lt_scr, top_scr, rt_scr, bot_scr = r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true) -- true - work area, false - the entire screen // https://forum.cockos.com/showthread.php?t=195629#4
local sws = r.APIExists('BR_Win32_GetWindowRect')
local retval, rt, top, lt, bot = table.unpack(sws and {r.BR_Win32_GetWindowRect(r.GetMainHwnd())} or {nil})

--[[
local dimens_t = sws and {r.BR_Win32_GetWindowRect(r.GetMainHwnd())}
or {r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true)} -- true - work area, false - the entire screen // https://forum.cockos.com/showthread.php?t=195629#4
	if #dimens_t == 5 then table.remove(dimens_t, 1) end -- remove retval value if BR's function
local rt, top, lt, bot = table.unpack(dimens_t)
]]
local wnd_h = sws and bot-top or bot_scr
local retval, proj_state = r.GetProjExtState(0,'WINDOW DIMS','window_dims')
local state = retval == 0 and r.GetExtState('WINDOW DIMS','window_dims') or proj_state
local window_h, arrange_h = state:match('(.+);(.+)')
local wnd_h_offset = sws and top or 0 -- to add when calculating absolute track top edge coordinate inside Get_Item_Track_Segment_At_Mouse1() function when the sws extension is installed to be able to get segments in the shrunk program window, in this case 'top' value represents difference between program window top and full screen top coordinates which is needed to match mouse cursor Y coordinate which is absolute i.e. is relative to the full screen size // !!!! MIGHT NOT WORK ON MAC since there Y axis starts at the bottom

-- Item condition isn't necessary, works perfectly without it // on the other hand it makes sure that there's at least one track so that ref_tr var below is valid
local x, y = r.GetMousePosition() -- the coordinates are absolute, relative to the full screen size
local item, take = r.GetItemFromPoint(x, y, false) -- allow_locked false // item is needed to have some anchor to restore scroll state after track heights restoration, item under cursor is 100% within view so is a good reference
local track, info = r.GetTrackFromPoint(x, y)

	if (item or track) and (sws and window_h ~= wnd_h..'' or not window_h) then -- either only update if sws extension is installed and program window height has changed or initially store

	-- get 'Maximum vertical zoom' set at Preferences -> Editing behavior, which affects max track height set with 'View: Toggle track zoom to maximum height', introduced in build 6.76
--[[ INEFFICIENT
	local cont
		if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.76 then
		local f = io.open(r.get_ini_file(),'r')
		cont = f:read('*a')
		f:close()
		end
	local max_zoom = cont and cont:match('maxvzoom=([%.%d]+)\n') -- min value is 0.125 (13%), max is 8 (800%)
	local max_zoom = not max_zoom and 100 or max_zoom*100
	--]]
	local retval, max_zoom = r.get_config_var_string('maxvzoom') -- min value is 0.125 (13%), max is 8 (800%)
	local max_zoom = #max_zoom == 0 and 100 or max_zoom*100 -- ignore in builds prior to 6.76 by assigning 100 so that when track height is divided by 100 and multiplied by 100% nothing changes, otherwise convert to conventional percentage value; if 100 can be divided by the percentage (max_zoom) value without remainder (such as 50, 25, 20) the resulting value is accurate, otherwise there's ±1 px diviation, because the actual track height in pixels isn't fractional like the one obtained through calculation therefore some part is lost

	-- Store track heights
	local dock_open = r.GetToggleCommandStateEx(0,40279) == 1 -- View: Show docker // the result of the action 'View: Toggle track zoom to maximum height' depends on the visibility of the bottom docker so if open it needs to be temporarily closed, the action 40279 applies to all dockers
		if dock_open then r.Main_OnCommand(40279,0) end -- View: Show docker // close docks // placed before getting track heights to get the actual data unaffected by the docker visibility because it might be
	local t = {}
		for i=0, r.CountTracks(0)-1 do
		local tr = r.GetTrack(0,i)
		t[#t+1] = {height=r.GetMediaTrackInfo_Value(tr, 'I_TCPH'), sel=r.IsTrackSelected(tr)}
		end
	local ref_tr = r.GetTrack(0,0) -- reference track (any) to scroll back to in order to restore scroll state after track heights restoration
	local ref_tr_y = r.GetMediaTrackInfo_Value(ref_tr, 'I_TCPY')

	-- Get the data
	-- When the actions are applied the UI jolts, but PreventUIRefresh() is not suitable 
	-- because it blocks the function GetMediaTrackInfo_Value() from getting the return value;
	-- toggle to minimum and to maximum height are mutually exclusive // selection isn't needed, all are toggled;
	-- in v7 action 'View: Toggle track zoom to maximum height (limit to 100% of arrange view)' was introduced
	-- which works like 40113 worked before the change and its use would obviate all the calculations above and below 
	-- but it obviously doesn't cover the interim builds, so leaving the current code;
	-- since build 7.48 the following toggle zoom actions affect pinned tracks as well,
	-- introduced in build 7.46, but since their height is being taken into account
	-- the calculation must still be accurate
	r.Main_OnCommand(40110, 0) -- View: Toggle track zoom to minimum height
	r.Main_OnCommand(40113, 0) -- View: Toggle track zoom to maximum height [in later builds comment '(limit to 100% of arrange view) has been added' and another action introduced to zoom to maxvzoom value]
	local tr_height = r.GetMediaTrackInfo_Value(ref_tr, 'I_TCPH')/max_zoom*100 -- not including envelopes, action 40113 doesn't take envs into account; calculating track height as if it were zoomed out to the entire Arrange height by taking into account 'Maximum vertical zoom' setting at Preferences -> Editing behavior
	
	-- if there're visible pinned tracks at the top (introduced in build 7.46), calculate their height because
	-- their presence affects max track height obtained above
	local pin_tracks_h = 0
		if r.GetToggleCommandState(43573) == 0 then -- Track: Override/unpin all pinned tracks in TCP 
			for i=0, r.GetNumTracks()-1 do
			local tr = r.GetTrack(0,i)
				if r.IsTrackVisible(tr, false) -- mixer false
				and r.GetMediaTrackInfo_Value(tr, 'B_TCPPIN') == 1 				
				then
				pin_tracks_h = pin_tracks_h + r.GetMediaTrackInfo_Value(tr, 'I_WNDH') -- incl. envelopes
				end
			end
		end
	
	pin_tracks_h = pin_tracks_h > 0 and pin_tracks_h+10 or pin_tracks_h -- 10 px is pinned track area separator width
	local tr_height = math.floor(tr_height + pin_tracks_h + 0.5) -- round; if 100 can be divided by the percentage (max_zoom) value without remainder (such as 50, 25, 20) the resulting value is integer, otherwise the calculated Arrange height is fractional because the actual track height in pixels is integer which is not what it looks like after calculation based on percentage (max_zoom) value, which means the value is rounded in REAPER internally because pixels cannot be fractional and the result is ±1 px diviation compared to the Arrange height calculated at percentages by which 100 can be divided without remainder
	r.Main_OnCommand(40110, 0) -- View: Toggle track zoom to minimum height
	r.SetExtState('WINDOW DIMS','window_dims', wnd_h..';'..tr_height, false) -- persist false
	r.SetProjExtState(0, 'WINDOW DIMS', 'window_dims', wnd_h..';'..tr_height)

	-- Restore
		for k, data in ipairs(t) do -- restore track heights
		local height = data.height
		local tr = r.GetTrack(0,k-1)
		local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
			if tr_h ~= height then
			local bigger, smaller = tr_h > height, tr_h < height
			local action = bigger and 41326 -- View: Decrease selected track heights
			or smaller and 41325 -- View: Increase selected track heights
			--[[ WORKED perfectly in 6.56 and earlier, but since vertical zoom overhaul in 6.76 TCP height change is visible during the loop https://forum.cockos.com/showthread.php?t=278646
			r.SetOnlyTrackSelected(tr)
				repeat
				r.Main_OnCommand(action, 0)
				local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
				until bigger and tr_h <= height or smaller and tr_h >= height
			]]
			-- Very slight improvement, only change in height isn't invisible, but change in selection still is despite SetOnlyTrackSelected() being enclosed between PreventUIRefresh()
			local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH')
			r.PreventUIRefresh(1)
			r.SetOnlyTrackSelected(tr)
				repeat
				r.Main_OnCommand(action, 0)
				tr_h = bigger and tr_h-8 or tr_h+8 -- 8 px is the amount TCP height is changed by with actions 41325/41326
				until bigger and tr_h <= height or smaller and tr_h >= height
				end
			r.PreventUIRefresh(-1)
		end
		for k, data in ipairs(t) do
		local tr = r.GetTrack(0,k-1)
		r.SetTrackSelected(tr, data.sel)
		end
	r.PreventUIRefresh(1)
		repeat -- restore track scroll position
		r.CSurf_OnScroll(0, -1) -- negatve to scroll up because after track heights restoration the tracklist ends up being scrolled all the way down // 1 vert scroll unit is 8 px
		until r.GetMediaTrackInfo_Value(ref_tr, 'I_TCPY') >= ref_tr_y
	r.PreventUIRefresh(-1)

		if dock_open then r.Main_OnCommand(40279,0) end -- View: Show docker // re-open docks if were open initially

	local header_height = bot - tr_height - 23 -- size between program window top edge and Arrange // 18 is horiz scrollbar height (regardless of the theme) and 'bot / window_h' value is greater by 4 px than the actual program window height hence 18+4 = 22 has to be subtracted + 1 more pixel for greater precision in targeting item top/bottom edges
	return tr_height, header_height, wnd_h_offset -- tr_height represents Arrange height // return updated data

	elseif window_h then -- Return the data already stored and not needing update
	return tonumber(arrange_h), window_h - arrange_h - 23, wnd_h_offset -- return previously stored data // calculation explication see above

	end

end


local arrange_h, header_h, wnd_h_offset = Get_Arrange_and_Header_Heights2() -- ONLY RELEVANT FOR Get_Item_Track_Segment_At_Mouse1() and depends on extensions

function Get_Item_Track_Segment_At_Mouse1(header_h, wnd_h_offset, want_item, want_takes) -- SEE UPDATED VERSION BELOW horizontal segments, targets item or track under mouse cursor, supports overlapping items displayed in lanes // want_item is boolean in which case item under mouse is considered otherwise segments will be valid along the entire time line for the track under mouse; want_takes is boolean and only relevant if want_item is true, if true and the item arg is true and the item is multi-take, each take will be divided into 2 segments

local x, y = r.GetMousePosition()
local item, take = table.unpack(item and {r.GetItemFromPoint(x, y, false)} or {nil}) -- allow_locked false
local tr, info = table.unpack(not item and {r.GetTrackFromPoint(x, y)} or {nil})

	if item then -- without item the segments will be relevant for the track along the entire timeline which is also useful, in which case item parameters aren't needed; if limited to TCP with Get_TCP_MCP_Under_Mouse() can be used to divide TCP to segments
	local tr = r.GetMediaItemTrack(item)
	local tr_y = r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
	local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH') -- no envelopes
	local itm_y = r.GetMediaItemInfo_Value(item, 'I_LASTY') -- within track
	local itm_h = r.GetMediaItemInfo_Value(item, 'I_LASTH')
	local take_cnt = r.CountTakes(item)
	--[[ These are only working for non-overlapping items or overlapping which aren't displayed in lanes
	local tr_h_glob = tr_y + tr_h + header_h -- distance between the program window top and the track bottom edge
	local itm_h_glob = tr_h_glob - 4 -- same for the item // -4 because item height is always smaller that its track height by 4 px regadless of icons and text on item's top, track I_TCPH = item I_LASTY + item I_LASTH + 4 is a universal formula
	]]
	local tr_y_glob = tr_y + header_h + wnd_h_offset -- distance between the screen top and the track top edge accounting for shrunk program window if sws extension is installed
	local itm_y_glob = tr_y_glob + itm_y -- distance between the screen top and the item top edge
	local itm_h_glob = itm_y_glob + itm_h -- distance between the screen top and the item bottom edge // only needed if table isn't used below

		if take_cnt == 1 then
		local itm_segm_h = itm_h/3 -- item segment height // can be divided by more than 3 in which case the following vars and return values must be adjusted accordingly
		--[-[ if the table isn't used
		local segm_bot = y <= itm_h_glob and y >= itm_h_glob - itm_segm_h
		local segm_mid = y <= itm_h_glob - itm_segm_h and y >= itm_h_glob - itm_segm_h*2
		local segm_top = y <= itm_h_glob - itm_segm_h*2 and y >= itm_h_glob - itm_h
		return segm_top, segm_mid, segm_bot
		--]]
		--[[ OR same as for takes below
		-- The tables collect truths/falses
		local t = {}
			for i = 1, 3 do
			t[i] = y >= itm_y_glob+itm_segm_h*(i-1) and y <= itm_y_glob+itm_segm_h*i
			end
		return t
		--]]

		elseif take_cnt > 1 and want_takes then
		local itm_segm_h = item_h/take_cnt/2 -- two segments per take, can be more
		local segm_cnt = 2*take_cnt -- multiply by segments per take
		local t = {}
			for i = 1, segm_cnt do
			t[i] = y >= itm_y_glob+itm_segm_h*(i-1) and y <= itm_y_glob+itm_segm_h*i
			end
		return t
		end

	elseif tr then -- if limited to TCP with Get_TCP_MCP_Under_Mouse() can be used to divide TCP to segments
	local tr_y = r.GetMediaTrackInfo_Value(tr, 'I_TCPY')
	local tr_h = r.GetMediaTrackInfo_Value(tr, 'I_TCPH') -- no envelopes
	local tr_y_glob = tr_y + header_h + wnd_h_offset -- distance between the screen top top and the track top edge accounting for shrunk program window if sws extension is installed
	local tr_segm_h = tr_h/3 -- 3 segments
	local t = {}
		for i = 1, 3 do
		t[i] = y >= tr_y_glob+tr_segm_h*(i-1) and y <= tr_y_glob+tr_segm_h*i
		end
	return t
	end

end


function Get_Item_Track_Segment_At_Mouse2(want_item, want_takes) -- horizontal segments, targets item or track under mouse cursor, supports overlapping items displayed in lanes // want_item is boolean in which case item under mouse is considered otherwise segments will be valid along the entire time line for the track under mouse; want_takes is boolean and only relevant if want_item is true, if true and the item arg is true and the item is multi-take, each take will be divided into 2 segments
-- based on AZpercussion_GetItemTopBottomHalf() below
-- track segment detection can be empeded by open track FX window if it overlaps the track
-- or is located not far below it

	local function is_fx(info, tr1, tr2)
	-- Error_Tooltip is recognized in the local function is_fx() as well
	-- but variables local to Get_Item_Track_Segment_At_Mouse() function are not, hence the need for arguments
		if info == 2 then -- track FX
		local mess = tr2 and tr1 and tr1 == tr2 and '      proper segment detection \n\n is impeded by the open fx window '
 		or '\tthe cursor is over \n\n\t track fx window. \n\n proper segment detection \n\n\t   is impossible.'
		Error_Tooltip('\n\n '..mess..'\n\n ', 1, 1, 20) -- caps and spaced are true, x is 0 to NOT shift the tooltip away from the mouse cursor because over the TCP otherwise if the script is re-run while the tooltip is ON, the error will be displayed again because the tooltip blocks the GetItem/TrackFromPoint() function
		return true
		end
	end

local x, y = r.GetMousePosition()
-- itm_slots_t length evaluation conditions below allow targeting track segments within Arrange over the item if no item slot is enabled, i.e. don't contain action ID or 0, while track slots are
local item, take = table.unpack(want_item and #itm_slots_t > 0 and {r.GetItemFromPoint(x, y, false)} or {nil}) -- allow_locked false
local tr, info = table.unpack((not item or #itm_slots_t == 0) and {r.GetTrackFromPoint(x, y)} or {nil})
local env = info == 1
local GetObj = item and r.GetItemFromPoint or r.GetTrackFromPoint
local GetVal = item and r.GetMediaItemInfo_Value or r.GetMediaTrackInfo_Value

	if item then -- without item the segments would be relevant for the track along the entire timeline which is also useful, in which case item parameters aren't needed; if limited to TCP with Get_TCP_MCP_Under_Mouse() can be used to divide TCP to segments;
	local tr = r.GetMediaItemTrack(item)
	local itm_y = GetVal(item, 'I_LASTY') -- within track
	local itm_h = GetVal(item, 'I_LASTH')
	local take_cnt = r.CountTakes(item)
	local t = {}
		if take_cnt == 1 or take_cnt > 1 and not want_takes then
		local itm_segm_h = itm_h/ITEM_SEGMENTS -- item segment height // can be divided by more or less than 3 in which case the following vars and return values must be adjusted accordingly
			for i = 1, ITEM_SEGMENTS do
			local add = math.floor(y+itm_segm_h*(ITEM_SEGMENTS-i)+0.5) -- to add following segments
			local subtr = math.floor(y-itm_segm_h*(i-1)+0.5) -- to subtract preceding segments
			t[i] = GetObj(x, add, false) and GetObj(x, subtr, false) and true or false -- avoiding nil storage because then the table cannot be iterated sequentially
			end
		elseif take_cnt > 1 and want_takes then -- UNUSED IN THIS SCRIPT
		local itm_segm_h = itm_h/take_cnt/2 -- two segments per take, can be more
		local segm_cnt = 2*take_cnt -- multiply by segments per take
		local t = {}
			for i = 1, segm_cnt do -- store truth and falsehood
			local add = math.floor(y+itm_segm_h*(segm_cnt-i)+0.5) -- to add following segments
			local subtr = math.floor(y-itm_segm_h*(i-1)+0.5) -- to subtract preceding segments
			t[i] = GetObj(x, add, false) and GetObj(x, subtr, false) and true or false -- avoiding nil storage because then the table cannot be iterated sequentially
			end
		end
	return t
--	elseif not want_item and tr then -- do not target track when want_item is true // AN OPTION
	elseif tr then -- if limited to TCP with Get_TCP_MCP_Under_Mouse() can be used to divide TCP to segments
	local tr_y = GetVal(tr, 'I_TCPY')
	local tr_h = GetVal(tr, 'I_TCPH') -- no envelopes
	local t = {}
		if env then t[1] = true -- y >= tr_y_glob+tr_h and y <= tr_y_glob+tr_h_env -- using table for the sake of unifomity
		else
		-- display error when track FX windows is hit instead of the track lane or TCP
			if is_fx(info) then return end

			if info == 2 then -- track FX
			Error_Tooltip('\n\n\tthe cursor is over \n\n\t track fx window. \n\n proper segment detection \n\n\t   is impossible. \n\n ', 1, 1, 20) -- caps and spaced are true, x is 20 see explanation abov
			end
		local tr_segm_h = tr_h/TRACK_SEGMENTS -- 3 segments, or more or less
			for i = 1, TRACK_SEGMENTS do -- store truth and falsehood
			local add = math.floor(y+tr_segm_h*(TRACK_SEGMENTS-i)+0.5) -- to add following segments
			local hit, info = GetObj(x, add) -- when track envelope lanes are open if add value exceeds tr_h value hit will still be successful because the coordinate will land on the ECP, therefore it needs to be validated with info value which for a successful hit must not return envelope indicated with integer 1

			-- when track FX windows overlap its TCP or lane or are located below them at a distance of tr_segm_h*(segm_cnt-i),
			-- proper detection of segments will be impeded because the window will extend the hight within which track will be valid
			-- exceeding the actual tr_h value
				if hit == tr and is_fx(info, tr, hit) then return end -- hit == tr to exclude FX windows of other tracks, if hit, detection of segments in the original track won't be affected

			local subtr = math.floor(y-tr_segm_h*(i-1)+0.5) -- to subtract preceding segments
			t[i] = hit == tr and info < 1 and GetObj(x, subtr) and true or false -- avoiding nil storage because then the table cannot be iterated sequentially // hit == tr to ignore next track which would produce false positive, info < 1 to exclude track envelope lanes, track fx windows are excluded with is_fx() function above
			end
		end
	return t
	end

Error_Tooltip('\n\n no valid object under \n\n     the mouse cursor \n\n ', 1, 1, 20) -- caps and spaced are true, x is 20	to shift the tooltip away from the mouse cursor otherwise if the script is re-run while the tooltip is ON, the error will be displayed again because the tooltip blocks the GetItem/TrackFromPoint() function

end



-- Process the segment table // can be integrated into the loops inside Get_Item_Segment_At_Mouse() function // see example in my_Indicate cursor position within item with a tooltip.lua
	for k, truth in ipairs(t) do
		if truth then
			if #t == 3 then -- 1 take, 3 segments
				if k == 1 then -- DO STUFF
				break -- break because only 1 segment can be targeted at a time so no point to continue
				elseif k == 2 then -- DO STUFF
				break
				elseif k == 3 then -- DO STUFF
				break
				end
			elseif #t > 3 then -- multi-take, 2 segments per take
				if k%2 ~= 0 then -- odd number, upper segment of a take
				-- DO STUFF
				break
				else -- even number, lower segment of a take
				-- DO STUFF
				break
				end
			end
		end
	end



function AZpercussion_GetItemTopBottomHalf()
-- https://github.com/ReaTeam/ReaScripts/pull/1406/files

local itempart

local x, y = reaper.GetMousePosition()

local item_under_mouse = reaper.GetItemFromPoint(x, y, true)

	if item_under_mouse then

	local item_h = reaper.GetMediaItemInfo_Value(item_under_mouse, "I_LASTH")

	local OScoeff = 1

		if not reaper.GetOS():match("^Win") then
		OScoeff = -1
		end

	local test_point = math.floor(y + (item_h-1) * OScoeff)
	local test_item, take = reaper.GetItemFromPoint(x, test_point, true)

		if item_under_mouse == test_item then
		itempart = "header"
		else
		local test_point = math.floor(y + item_h/2 * OScoeff)
		local test_item, take = reaper.GetItemFromPoint(x, test_point, true)

			if item_under_mouse ~= test_item then
			itempart = "bottom"
			else
			itempart = "top"
			end

		end

	return item_under_mouse, itempart

	end

end


------------------------ GET ITEM SEGMENTS AT MOUSE END ---------------------

--[[

Calculate take actual length for take marker operations using edit cursor

* convert timeline pos to pos within take

local cur_pos = r.GetCursorPosition()

local item_pos = r.GetMediaItemInfo_Value(item, 'D_POSITION')
OR
local item_pos = r.GetMediaItemInfo_Value(r.GetMediaItemTake_Item(take), 'D_POSITION')

local offset = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
local playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE') -- affects take start offset and take marker pos
local mark_pos = (cur_pos - item_pos + offset)*playrate

* convert pos within take to timeline pos

local ret_pos, name, color = r.GetTakeMarker(take, idx) -- ret_pos = -1 or position in item source
local mark_pos = item_pos + (ret_pos - offset)/playrate

ALSO RELEVANT FOR TAKE ENVELOPE POINTS, STRETCH MARKERS AND TRANSIENT GUIDES BAR offset value
which for stretch markers only relevant if its position in source is used, its position in item
is already relative to the item start

]]


function Proj_Time_2_Item_Time(proj_time, item, take)
-- e.g. edit/play cursor, proj markers/regions time to take envelope points, take/stretch markers and transient guides time

--local cur_pos = r.GetCursorPosition()
local item_pos = r.GetMediaItemInfo_Value(item, 'D_POSITION')
--OR
--local item_pos = r.GetMediaItemInfo_Value(r.GetMediaItemTake_Item(take), 'D_POSITION')
local item_end = item_pos + r.GetMediaItemInfo_Value(item, 'D_LENGTH')
local within_view = proj_time >= item_pos and proj_time <= item_end -- can be used as a condition to return value if only visible item area is relevant
local offset = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
local playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE') -- affects take start offset and take marker pos
local item_time = (proj_time - item_pos + offset)*playrate
return item_time
end


function Item_Time_2_Proj_Time(item_time, item, take)
-- such as take envelope points, take/stretch markers and transient guides time, item_time is their position within take media source returned by the corresponding functions
-- e.g. take envelope points, take/stretch markers and transient guides time to edit/play cursor, proj markers/regions time

--local cur_pos = r.GetCursorPosition()
local item_pos = r.GetMediaItemInfo_Value(item, 'D_POSITION')
--OR
--local item_pos = r.GetMediaItemInfo_Value(r.GetMediaItemTake_Item(take), 'D_POSITION')
local item_end = item_pos + r.GetMediaItemInfo_Value(item, 'D_LENGTH')
local offset = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
local playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE') -- affects take start offset and take marker pos
local proj_time = item_pos + (item_time - offset)/playrate

return proj_time >= item_pos and proj_time <= item_end and proj_time -- ignoring content outside of item bounds -- OPTIONAL
end


---------------------------- TRIMMING ITEM EDGES --------------------------

-- Only works on selected item

-- necessity of positive or negative values depends on the reverse arg being true or false - reverse: in nudge mode, nudges left (otherwise ignored)

r.ApplyNudge(0, 0, 1, 1, negative value, false, 0) -- 0 - curr proj, 0 nudge by value, 1 - left trim, 1 - nudgeunits sec, reverse false, copies 0 (ignored) // trim left edge, negative value
-- OR r.ApplyNudge(0, 0, 1, 1, positive value, true, 0) -- 0 - curr proj, 0 nudge by value, 1 - left trim, 1 - nudgeunits sec, reverse true, copies 0 (ignored) // trim left edge, positive value

r.ApplyNudge(0, 0, 3, 1, positive value, true, 0) -- 0 - curr proj, 0 nudge by value, 3 - right edge, 1 - nudgeunits sec, reverse true, copies 0 (ignored) // trim right edge, positive value

r.ApplyNudge(0, 0, 1, 1, negative value, false, 0) -- 0 - curr proj, 0 nudge by value, 1 - left trim, 1 - nudgeunits sec, reverse false, copies 0 (ignored) // UNtrim left edge, negative value
-- OR r.ApplyNudge(0, 0, 1, 1, positive value, true, 0) -- 0 - curr proj, 0 nudge by value, 1 - left trim, 1 - nudgeunits sec, reverse true, copies 0 (ignored) // UNtrim left edge, positive value

r.ApplyNudge(0, 0, 3, 1, positive value, false, 0) -- 0 - curr proj, 0 nudge by value, 3 - right edge, 1 - nudgeunits sec, reverse false, copies 0 (ignored) // UNtrim right edge, positive value

---------------------------- TRIMMING ITEM EDGES END --------------------------

function Fades_Exist(itm)

-- D_FADEINLEN_AUTO and D_FADEOUTLEN_AUTO are only relevant when auto-crossfade is ON; doesn't make sense setting them without crossfade because this doesn't affect regular fades and when auto-crossfade occurs the values will change automatically to suit the conditions; when auto-crossfade is ON once items no longer overlap these values are reset to 0 regardless of what they were set to prior to the crossfade and lengths of regular fades which existed prior to crossfade are restored; if auto-crossfade is OFF the length values which were used during the crossfade aren't reset and replace regular fade lengths which existed prior to the crossfade, although regular fade ghost data can still be fetched via D_FADEOUTLEN/D_FADEINLEN; if after separation of items with auto-crossfade OFF, thems are made to overlap again and auto-crossfade is turned ON, after next item separation their original regular fade length is restored and auto-crossfade lengths are reset to 0 as described above;
-- Auto-crossfade in REAPER only creates crossfades with the length of each side being equal to the overlap size
-- Auto-crossfade replaces original fade if existed but doesn't remove it, when items are separated original fades are restored
-- D_FADEOUTLEN, D_FADEINLEN -- regular fade out and in, fade exists when these are greater than 0, setting these params doesn't affect fade out and in of a crossfade if D_FADEOUTLEN_AUTO/D_FADEINLEN_AUTO are greater than 0, so the latter override the former in a crossfade, but regular fade-in and fade-out lengths will change in the background
-- When auto-crossfade is OFF it doesn't matter what to fashion the crossfade with D_FADEOUTLEN_AUTO/D_FADEINLEN_AUTO or D_FADEOUTLEN/D_FADEINLEN but if items prior to being crossfaded have had fade-in/out then using D_FADEOUTLEN_AUTO/D_FADEINLEN_AUTO ensures that the length of these is restored after items are separated while auto-crossfade is turned ON, their shape and curve will still be affected by the crossfade, and their length will also be affected if crossfade was expanded manually

-- D_FADEOUTDIR, D_FADEINDIR are what's called 'curve' in the Crossfade editor and Item properties
-- C_FADEINSHAPE, C_FADEOUTSHAPE -- with regard to getting, shapes selected in the item properties
-- !!!!!! NATIVE AUTO-CROSSFADE MAKES FADE-IN SHORTER THAN THE FADE-OUT AND THE INTERSECTION AREA (which are always equal) by a tiny fraction not reflected in the Console where their values are identical due to being truncated down to 14 decimal places; the difference only transpires after subtracting fade-in length from the length of the intersection area; this doesn't happen when crossfade out and in lengths are set via API; to test equality reliably fade-in value must be converted to a string, which works perhaps because it truncates the values down to the size at which they're equal


local Get = r.GetMediaItemInfo_Value
local itm_start = Get(itm, 'D_POSITION')
local itm_end = itm_start + Get(itm, 'D_LENGTH')
local fadein_len = Get(itm, 'D_FADEINLEN')
local fadeout_len = Get(itm, 'D_FADEOUTLEN')
local itm_xfade_in_len = Get(itm, 'D_FADEINLEN_AUTO')
local itm_xfade_in_len = itm_xfade_in_len > 0 and itm_xfade_in_len or Get(itm, 'D_FADEINLEN')
local itm_xfade_in_len = itm_xfade_in_len > 0 and itm_xfade_in_len or fadein_len -- do prefer auto-crossfade fade-in value but if 0 get regular fade-in
local itm_xfade_out_len = Get(itm, 'D_FADEOUTLEN_AUTO')
local itm_xfade_out_len = itm_xfade_out_len > 0 and itm_xfade_out_len or fadeout_len -- do prefer auto-crossfade fade-out value but if 0 get regular fade-out
local itm_idx = Get(itm, 'IP_ITEMNUMBER')
local itm_tr = r.GetMediaItemTrack(itm)
local prev_itm = r.GetTrackMediaItem(itm_tr, itm_idx-1)
local prev_itm_end = prev_itm and Get(prev_itm, 'D_POSITION') + Get(prev_itm, 'D_LENGTH')
local prev_itm_xfade_out_len = prev_itm and Get(prev_itm, 'D_FADEOUTLEN_AUTO')
local prev_itm_xfade_out_len = prev_itm and (prev_itm_xfade_out_len > 0 and prev_itm_xfade_out_len or Get(prev_itm, 'D_FADEOUTLEN'))
local next_itm = r.GetTrackMediaItem(itm_tr, itm_idx+1)
local next_itm_start = next_itm and Get(next_itm, 'D_POSITION')
local next_itm_xfade_in_len = next_itm and Get(next_itm, 'D_FADEINLEN_AUTO')
local next_itm_xfade_in_len = next_itm and (next_itm_xfade_in_len > 0 and next_itm_xfade_in_len or Get(next_itm, 'D_FADEINLEN'))
local start_xfade_overlap_size = prev_itm and prev_itm_end-itm_start
local end_xfade_overlap_size = next_itm and itm_end-next_itm_start

local xfade_in = prev_itm and prev_itm_end > itm_start and prev_itm_xfade_out_len == start_xfade_overlap_size and tostring(itm_xfade_in_len) == tostring(start_xfade_overlap_size) -- both prev item fadeout and target item fadein and each of these fades is equal to the overlap size
local xfade_out = next_itm and next_itm_start < itm_end and itm_xfade_out_len == end_xfade_overlap_size and tostring(next_itm_xfade_in_len) == tostring(end_xfade_overlap_size) -- both target item fadeout and next item fadein and each of these fades is equal to the overlap size

-- Non-uniform crossfade is one in which one or both fades have length different from items intersection area length and/or from each other's, unlike regular crossfade in which fade-out and fade-in both have the length of the intersection area
local xfade_in_nonuniform = prev_itm and prev_itm_end > itm_start and not xfade_in and itm_xfade_in_len > 0 and itm_xfade_in_len + prev_itm_xfade_out_len > start_xfade_overlap_size
local xfade_out_nonuniform = next_itm and next_itm_start < itm_end and not xfade_out and itm_xfade_out_len > 0 and itm_xfade_out_len + next_itm_xfade_in_len > end_xfade_overlap_size

local fade_in = not xfade_in and not xfade_in_nonuniform and fadein_len > 0
local fade_out = not xfade_out and not xfade_out_nonuniform and fadeout_len > 0

return fade_in, fade_out, xfade_in, xfade_out, xfade_in_nonuniform, xfade_out_nonuniform -- booleans

end

local fade_in, fade_out, xfade_in, xfade_out, xfade_in_nonuniform, xfade_out_nonuniform = Fades_Exist(r.GetSelectedMediaItem(0,0))



function is_audio_src(obj)
-- obj is either take source or take pointer
-- take is advised in cases where source may be set to section or reversed

local validate = r.ValidatePtr
local src, take = validate(obj, 'PCM_source*'), validate(obj, 'MediaItem_Take*')
	if src then
	src = obj
	elseif take then
	src = r.GetMediaItemTake_Source(obj) -- won't return accurate pointer for reversed takes and sections, that is those which have either 'Section' or 'Reverse' checkboxes checked in the 'Item properties' window, hence next line
	src = r.GetMediaSourceParent(src) or src
	end
	
	if src then
	local typ = r.GetMediaSourceType(src, '')
		for k, v in ipairs({'MIDI', 'RPP', 'EMPTY', 'CLICK', 'LTC', 'VIDEO'}) do
			if typ:match(v) then
				if v == 'VIDEO' then -- as of build 7.52 wma and m4a files are recognized as video even though they only contain audio, so need to be validated further
				local ext = r.GetMediaSourceFileName(src, ''):match('.+%.(.+)$')
					if ext == 'wma' and ext == 'm4a' then 
					return true
					end
				end
			return
			end
		end
	return true
	end

end


function Delete_Take_Src(take)
ACT(40440) -- Item: Set selected media temporarily offline // if source is removed before take is removed
-- Thanks to cfillion and MPL
-- https://forum.cockos.com/showthread.php?t=211250
-- https://forum.cockos.com/showthread.php?p=1889202
local src = r.GetMediaItemTake_Source(take)
local src = r.GetMediaSourceParent(src) or src -- in case the item is a section or a reversed source
local file_name = r.GetMediaSourceFileName(src, '')
os.remove(file_name)
os.remove(file_name..'.reapeaks')
ACT(40439) -- Item: Set selected media online // if source is removed before take is removed
end



function Get_Take_Src_Props(take)
	if take then
	local src = r.GetMediaItemTake_Source(take)
	local sect, startoffs, length, rev = r.PCM_Source_GetSectionInfo(src) -- if sect is false startoffs is 0
	local src = (sect or rev) and r.GetMediaSourceParent(src) or src -- retrieve original media source if section or reversed
	local filename = r.GetMediaSourceFileName(src, '') -- source pointer in takes with the same source is different therefore for comparison file name must be retrieved
	return sect, startoffs, length, rev, filename
	end
end


function Select_Items_With_Same_Src_Media(src_take) -- select only items where active take has the same media source as the source take, don't select the source take parent item if it's unselected
-- relies on Get_Take_Src_Props()
local src_take_file = ({Get_Take_Src_Props(src_take)})[5]
r.PreventUIRefresh(1)
r.SelectAllMediaItems(0, false) -- selected false // deselect all
	for i = 0, r.CountMediaItems(0)-1 do
	local item = r.GetMediaItem(0,i)
	local act_take = r.GetActiveTake(item)
		if act_take ~= src_take and src_take_file == ({Get_Take_Src_Props(act_take)})[5] then
		r.SetMediaItemSelected(item, true) -- selected true
		r.UpdateItemInProject(item)
		end
	end
r.PreventUIRefresh(-1)
end


function Audio_Or_MIDI_Takes(item) -- only returns valid value if all takes are either audio or midi
local audio, midi
	for i = 0, r.CountTakes(item)-1 do
	local is_midi = r.TakeIsMIDI(r.GetTake(item,i))
		if is_midi then
		midi = true
		else
		audio = true
		end
	end
return audio and not midi and 'audio' or midi and not audio and 'midi'
end


function Get_Src_Orig_Length(take)
local src = r.GetMediaItemTake_Source(take)
-- retrieve original media source if section or reversed
local sect, startoffs, sect_len, rev = r.PCM_Source_GetSectionInfo(src)
local src = (sect or rev) and r.GetMediaSourceParent(src) or src
local file = r.GetMediaSourceFileName(src, '')
local src = r.PCM_Source_CreateFromFile(file) -- must be re-created because source length within take depends of section properties if enabled and is likely to be inaccurate
local sect, startoffs, src_len, rev = r.PCM_Source_GetSectionInfo(src) -- re-get data from the mint source
--[[ OR
local src_len, lengthIsQN = r.GetMediaSourceLength(src) -- (If the media source is beat-based, the length will be in quarter notes, otherwise it will be in seconds); ONLY RETURNS FULL SOURCE LENGTH when section isn't enabled otherwse it's equal to section length, basically does what PCM_Source_GetSectionInfo() does
local sec_per_QN = 60/r.Master_GetTempo() -- sec per quarter note
local src_len = lengthIsQN and src_len*QN_per_sec or src_len
]]
r.PCM_Source_Destroy(src)
return src_len
end


function Is_Take_Source_Trimmed(take)

local src = r.GetMediaItemTake_Source(take)
local sect, startoffs, sect_len, rev = r.PCM_Source_GetSectionInfo(src) -- sect is true if 'Section' checkbox is checkmarked in 'Item Properties' (can be checkmarked with action 'Item properties: Loop section of audio item source'); when not sect startoffs is 0 and sect_len is full source length, that's because src pointer stems from a specific take; startoffs and sect_len values are raw, i.e. without accounting for the playrate just as they are displayed in the Item Properties
local src = (sect or rev) and r.GetMediaSourceParent(src) or src -- retrieve original media source if section or reversed
local playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE')
local GET = r.GetMediaItemInfo_Value
local item = r.GetMediaItemTake_Item(take)
local itm_start = GET(item,'D_POSITION')
local itm_end = itm_start + GET(item,'D_LENGTH')
local take_startoffs = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')

local src_start, src_end

	if not sect then
	-- when not sect sect_len is entire source length, equal to the original source length, and section startoffs must be ignored
	src_start = itm_start - take_startoffs/playrate
	src_end = src_start + sect_len/playrate
	elseif sect then

	-- Get the source original length unaffected by section // do block to prevent overwriting the section
	local file = r.GetMediaSourceFileName(src, '')
	local src = r.PCM_Source_CreateFromFile(file) -- must be re-created because source length within take depends on section properties if enabled and is likely to be inaccurate
	local _, _, src_len, _ = r.PCM_Source_GetSectionInfo(src) -- re-get data from the mint source
	r.PCM_Source_Destroy(src)

	-- The part of the source included in the section may be shorter than the original source
	local src_sect_len = startoffs > 0 and (sect_len > src_len-math.abs(startoffs) and src_len-math.abs(startoffs) or sect_len) -- trimmed down on the start; startoffs must be subtracted from the section length and source length
	or startoffs <= 0 and (sect_len-math.abs(startoffs) >= src_len and src_len or sect_len-math.abs(startoffs)) -- trimmed out on the start or no change; startoffs must be subtracted from the section length but not source length because in this case source start isn't trimmed down // in both cases use the shortest length, trimmed down source ends are considered its current ends, but if they're trimmed out original source ends are used; math.abs is used to rectify the negative startoffs value when the source left edge is extended because it needs to be subtracted from the section or source length to arrive at the source start within the item
	src_start = itm_start - take_startoffs/playrate - (startoffs < 0 and startoffs/playrate or 0) -- when startoffs < 0 the source left edge is extended therefore the difference beween the extended edge and the source edge must be eliminated, when startoffs >= 0 the section start is already the source start or later; in looped items src start is the start of the 1st visible loop iteration
	src_end = src_start + src_sect_len/playrate
		if rev then
		local sect_start = itm_start - take_startoffs/playrate
		local sect_end = sect_start + sect_len/playrate
		local midline = sect_start + (sect_end - sect_start)/2
		-- swap start and end distances relative to the section midline
		local src_start_dist, src_end_dist = midline - src_start, src_end - midline
		src_start, src_end = midline - src_end_dist, midline + src_start_dist
		end
	end

return sect, itm_start > src_start, itm_end < src_end, src_start, src_end -- src_start & src_end are those within the item, not of the original source

end

-- USE EXAMPLE
-- local sect, trimmed_down_start, trimmed_down_end, src_start, src_end = Is_Take_Source_Trimmed(take)


function Create_Take_Source_Section(item, take, trim_left, trim_right) -- trim_left & trim_right vars can be positive and negative
local src = r.GetMediaItemTake_Source(src_take)
local sect, startoffs, len, rev = r.PCM_Source_GetSectionInfo(src_src) -- sect_src is true if 'Section' checkbox is checkmarked in 'Item Properties' (can be checkmarked with action 'Item properties: Loop section of audio item source')
local src = (sect or rev) and r.GetMediaSourceParent(src) or src -- retrieve original media source if section or reversed
	if sect then r.Main_OnCommand(40547,0) end -- Item properties: Loop section of audio item source // uncheck if checked
r.SetMediaItemTakeInfo_Value(take, 'D_STARTOFFS', trim_left)
r.SetMediaItemInfo_Value(item, 'D_LENGTH', trim_right) -- set to the desired section length
r.Main_OnCommand(40547,0) -- Item properties: Loop section of audio item source // check to enable section in the dest take // ADDS 10 ms OF SECTION FADE, can only be modified via item chunk as OVERLAP parameter in <SOURCE SECTION section
end


function Get_Take_Polarity(take, item) -- relies on GetObjChunk2() function
-- the function redundant because it can be evaluated with
-- r.GetMediaItemTakeInfo_Value(take, 'D_VOL') < 0 -- when polarity is flipped

local idx = r.GetMediaItemTakeInfo_Value(take, 'IP_TAKENUMBER')
local _, GUID = r.GetSetMediaItemTakeInfo_String(take, 'GUID', '', false) -- setNewValue false
local ret, chunk = GetObjChunk2(item)

	if ret then -- if chunk size exceeds the limit without the SWS extension the return val will be nil
	local t, found = {}
		for line in chunk:gmatch('[^\n\r]+') do
			if idx == 0 or line:match(Esc(GUID)) then found = 1 end
			if idx ~= 0 then t[#t+1] = line end -- if take idx is not 0, collect chunk lines to be able to iterate over them in reverse since TAKEVOLPAN parameter precedes take GUID
			if line and found and (line:match('VOLPAN') or #t > 0) then
			local src_phase
				if idx == 0 then
				src_phase = line:match('VOLPAN .- .- ([%d%.%-]+)')
				else
					for i = #t,1,-1 do -- in reverse since TAKEVOLPAN parameter precedes take GUID
						if t[i]:match('TAKEVOLPAN') then
						src_phase = t[i]:match('TAKEVOLPAN .- ([%d%.%-]+)') break
						end
					end
				end
			return src_phase+0 < 0, -- phase is on
			chunk -- return chunk to be re-used at the propagation stage if to_all_takes option is enabled to avoid getting chunk repeatedly for each take of the same item
			end
		end
	end

end


function MPL_Set_Startoffs_With_Stretch_Mrkrs(take, startoffs)
-- overcomes the limitation which prevents changing start offset when there're stretch markers
-- https://forum.cockos.com/showthread.php?t=180571#3

--local item =  r.GetMediaItem(0, 0)
--local take = r.GetActiveTake(item)
r.SetMediaItemTakeInfo_Value(take, "D_STARTOFFS", startoffs)

	for i = 0, r.GetTakeNumStretchMarkers(take)-1 do
	local retval, pos, srcpos = r.GetTakeStretchMarker(take, i)
	r.SetTakeStretchMarker(take, i, pos-startoffs, srcpos)
	end

r.UpdateItemInProject(r.GetMediaItemTake_Item(take))
end


function Re_Store_Apply_Stretch_Markers(src_take, dest_take, t)
-- stretch markers are stored and applied relative to the media source start within take, playrate is taken into account automatically; one scenario it doesn't work as expected is when the source take has a section created after adding SMs and the start is trimmed in either direction which makes the media source shift and leave empty space behind some SMs, in this scenario when the source take is trimmed out the SMs are still pasted to the dest take telative to its media source start as they're supposed to but by this they don't replicate their relative position in the src take, when the src take is trimmed down SMs are pasted starting before the dest take media source and kind of do replicate their relative position in the src take being placed over empty space which however isn't how they are designed to be pasted with this function; in this scenario calculation of the media source start in the source take produces the same result as when this scenario doesn't take place as if the source start got pinned by the SMs, so not sure there's a way to calculate the actual new source start; overall these seem like extremely edge cases (whoever creates sections after adding SMs?) so not worth addressing at this stage

-- https://github.com/ReaTeam/Doc/blob/master/X-Raym_Working%20with%20Stretch%20Markers%20ReaScript%20API.md
-- https://github.com/X-Raym/REAPER-ReaScripts/blob/master/Items%20Properties/X-Raym_Reset%20stretch%20marker%20under%20mouse%20position.lua
-- https://forum.cockos.com/showthread.php?t=248801

	local function get_values_for_offset_calc(take)
	-- Calculate source position within take to adjust markers position if the former doesn't coincide with the item start
	local take_startoffs = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
	local src = r.GetMediaItemTake_Source(take)
	local sect, src_startoffs, sect_len, rev = r.PCM_Source_GetSectionInfo(src) -- when sect is false src_startoffs is 0, sect_len equals full source length
	local item = r.GetMediaItemTake_Item(take)
	local itm_start = r.GetMediaItemInfo_Value(item,'D_POSITION')
	local src_start = itm_start - take_startoffs - (src_startoffs < 0 and src_startoffs or 0) -- when src_startoffs < 0 the source left edge is extended therefore the difference beween the extended edge and the source edge must be eliminated, when src_startoffs >= 0 the
	return itm_start, src_start, src_startoffs
	end

local mrkrs_cnt = r.GetTakeNumStretchMarkers(src_take)
	if not t and mrkrs_cnt > 0 then
	local t = {}
	local itm_start, src_start = get_values_for_offset_calc(src_take)
	local diff = src_start - itm_start
		for idx = 0, mrkrs_cnt-1 do
		local retval, posInitm, posInsrc = r.GetTakeStretchMarker(src_take, idx) -- posInitm is relative to the item start, posInsrc value is equal to posInitm value when no slope and rate is 1, it's constant and independent of slopes and rates
		local slope = r.GetTakeStretchMarkerSlope(src_take, idx)
		t[#t+1] = {posInitm=posInitm-diff, posInsrc=posInsrc, slope=slope} -- adjusting posInitm so it becomes relative to the media source start because it will be pasted relative to it as well, posInsrc apparently doesn't need adjustment
		end
	--[[OR
	local i = -1
		repeat
		local retval, posInitm, posInsrc = r.GetTakeStretchMarker(src_take, i)
			if retval then
			local slope = r.GetTakeStretchMarkerSlope(src_take, retval)
			t[#t+1] = {posInitm=posInitm-diff, posInsrc=posInsrc, slope=slope} -- adjusting posInitm so it becomes relative to the media source start because it will be pasted relative to it as well, posInsrc apparently doesn't need adjustment
			end
		i = i+1
		until retval == -1
	]]
	return t
	elseif t then
	local mrkrs_cnt = r.GetTakeNumStretchMarkers(dest_take)
		if mrkrs_cnt > 0 then -- delete all stretch markers from the dest take
			for i = mrkrs_cnt-1,0,-1 do
			r.DeleteTakeStretchMarkers(dest_take, i, 1) -- countIn 1, don't know what this argument is for but 0 prevents deletion, any INTEGER greater than 0 will do, i-1 leaves first 2 markers undeleted, i-2 leaves first 3 and so on
			end
		end
	-- OR
	-- r.Main_OnCommand(41844, 0) -- Item: Remove all stretch markers // removes from the active take BUT the item must be selected and take activated

	local itm_start, src_start, src_startoffs = get_values_for_offset_calc(dest_take)
	local diff1, diff2
		for k, props in ipairs(t) do -- paste stretch markers relative to current media source start within item accounting for section
		diff1 = not diff1 and src_start - itm_start or diff1 -- only calculate once
		diff2 = not diff2 and (src_startoffs ~= 0 and src_startoffs or 0) or diff2 -- only assign value once
		r.SetTakeStretchMarker(dest_take, -1, props.posInitm + diff1, props.posInsrc - diff2) -- idx is -1 to add a marker
		end
		for idx, props in ipairs(t) do -- setting slope only makes sense when all markers are added because it requires two markers
		r.SetTakeStretchMarkerSlope(dest_take, idx-1, props.slope)
		end

	r.UpdateItemInProject(r.GetMediaItemTake_Item(dest_take))

	end

end

-- USAGE
-- local t = Re_Store_Apply_Stretch_Markers(src_take, dest_take)
-- Re_Store_Apply_Stretch_Markers(src_take, dest_take, t)


function Find_And_Get_New_Items(t)
	if not t then
	local t = {}
		for i = 0, r.CountMediaItems(0)-1 do
		t[r.GetMediaItem(0,i)] = '' -- dummy field
		end
	return t
	elseif t then
	local t2 = {}
		for i = 0, r.CountMediaItems(0)-1 do
		local itm = r.GetMediaItem(0,i)
			if not t[itm] then -- track wasn't stored so is new
			t2[#t2+1] = itm
			end
		end
	return #t2 > 0 and t2
	end
end


function Is_Item_Looped_In_Arrange(item) -- or extended beyond its non-looped source

local src = r.GetMediaItemTake_Source(take)
local is_source_looped = r.GetMediaItemInfo_Value(item, 'B_LOOPSRC') == 1
local is_sect, start_offset_sect, len_sect, is_reversed = r.PCM_Source_GetSectionInfo(src) -- works for both section and full source
local start_offset_take = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS') -- negative if start is extended beyond a non-looped source
local len_item = r.GetMediaItemInfo_Value(item, 'D_LENGTH')

return start_offset_take < 0, -- non-looped extended beyond start // true or false
not is_source_looped and len_item > len_sect - start_offset_take, -- non-looped extended beyond end // same
is_source_looped and start_offset_take >= 0 and len_item > len_sect - start_offset_take -- looped in Arrange // same

end



function Import_Item_To_RS5k(item, track, rs5k_idx) -- doesn't set sample Mode and doesn't map to a keyboard key

local is_source_looped = r.GetMediaItemInfo_Value(item, 'B_LOOPSRC') == 1
local take = r.GetActiveTake(item)
local pitch_shift = r.GetMediaItemTakeInfo_Value(take, 'D_PITCH') -- in semitones
local env = r.GetTakeEnvelopeByName(take, 'Pitch')
local pitch_env_val
	if env then -- pitch of only the 1st point in the envelope is respected
	retval, time, pitch, shape, tens, is_sel = r.GetEnvelopePointEx(env, -1, 0)
	pitch_env_val = pitch ~= 0 and pitch or 0
	end

-- get original media source to calculate unit for convertion of item boundaries into region boundaries within RS5k
local src = r.GetMediaItemTake_Source(take)
local src = r.GetMediaSourceParent(src) or src -- in case the item is a section or a reversed source; if item is a section the next function will return actual item length rather than the source's, hence unsuitable for unit calculation (for which full source length is required) neither suitable for file name retrieval and parent source must be retrieved
-- convert source length to sample region units used in rs5k (0 - 1)
local len_src, is_lengthInQN = r.GetMediaSourceLength(src)
local unit = 1/len_src

local file_name = r.GetMediaSourceFileName(src, '')

local src = r.GetMediaItemTake_Source(take) -- re-initialize to get the actual length of the section in Arrange, if any, rather than the source's which was retrieved above for the sake of unit calculation
local is_sect, start_offset_sect, len_sect, is_reversed = r.PCM_Source_GetSectionInfo(src) -- works for both section and full source
local start_offset_take = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS') -- negative if start is extended beyond a non-looped source
local take_playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE')
local len_item = r.GetMediaItemInfo_Value(item, 'D_LENGTH')*take_playrate
local vol_item = r.GetMediaItemInfo_Value(item, 'D_VOL')
local vol_item_dB = 20*math.log(vol_item,10)
local vol_take = r.GetMediaItemTakeInfo_Value(take, 'D_VOL')
local vol_take_dB = 20*math.log(vol_take,10)
local vol = 10^((vol_item_dB + vol_take_dB)/20)
-- val and dB conversion forumula from SPK77
-- https://forum.cockos.com/showthread.php?p=1608719

-- When item is looped only the very first iteration, which can be partial due to trim, is translated into RS5k sample area
-- Enabling reverse in Item Properties turns item into section even when Section option isn't explicitly checkmarked
-- After import into RS5k of a reversed item, section or not, trimmed or not, looped or not, the sample region accurately reflects boundaries of the non-reversed source; for original section boundaries to be respected special calculations are required which are pointless because the sample area won't match item playback anyway due to reverse
-- If a non-looped item is untrimmed from the left, start_offset_take value is negative throwing the region start position off in RS5k since RS5k respects the negative offset, so it must be accounted for

-- Start is either Section: (first field) or 'Start in source' value in the Media Item Properties window; len is either Length (under Position) or Section: Length in Media Item Properties window; accounting for left and right edges trim
local start = start_offset_take >= 0 and start_offset_sect + start_offset_take or start_offset_sect -- accounting for extension or trim of the left edge; when item source is looped item's left (and right for that matter) edge can't be extended beyond source, otherwise extension is ignored
local len = is_source_looped and len_item > len_sect - start_offset_take and len_sect - start_offset_take -- item is looped in Arrange
or start_offset_take < 0 and len_item + start_offset_take > len_sect and len_sect -- item is extended beyond its source at the start and at the end
or start_offset_take >= 0 and len_item > len_sect - start_offset_take and len_sect - start_offset_take -- item is extended beyond its source at the end
or start_offset_take < 0 and len_item + start_offset_take -- item is extended beyond its source at the start
or len_sect >= len_item and len_item -- item is or isn't trimmed at either end

-- https://forum.cockos.com/showpost.php?p=1817782&postcount=5
r.TrackFX_SetNamedConfigParm(track, rs5k_idx, 'FILE0', file_name)
r.TrackFX_SetNamedConfigParm(track, rs5k_idx, 'DONE', '')

local set_inf = vol < 1 and r.TrackFX_SetParam(track, rs5k_idx, 2, 0) -- 'Gain for minimum velocity' aka 'Min vol' // set to -inf if item/take voulume < 0 so negative vol can be set
r.TrackFX_SetParam(track, rs5k_idx, 0, vol) -- 'Volume' // Normalized type of function must not be used since take (and item) volume scale isn't linear
-- no difference between the result of using functions below with or without Normalized
r.TrackFX_SetParamNormalized(track, rs5k_idx, 13, start*unit) -- 'Sample start offset'
-- r.TrackFX_SetParam(track, rs5k_idx, 13, start*unit)
r.TrackFX_SetParamNormalized(track, rs5k_idx, 14, (start+len)*unit) -- 'Sample end offset'
--r.TrackFX_SetParam(track, rs5k_idx, 14, (start+len)*unit)
r.TrackFX_SetParam(track, rs5k_idx, 15, 0.5+pitch_shift+pitch_env_val*1/160) -- 'Pitch offset' aka Pitch adjust // starting with 0.5 because pitch has positive and negative ranges and 0.5 represents pitch 0 (middle) in the parameter range of 0-1
--r.TrackFX_SetParamNormalized(track, rs5k_idx, 15, 0.5+pitch_shift+pitch_env_val*1/160) -- 'Pitch offset' aka Pitch adjust
end


function Is_Item_Under_Mouse()
-- same as r.GetItemFromPoint(x,y,allow_locked)

-- REAPER devs don't recommend using CountSelectedMediaItems()
-- and GetSelectedMediaItem in favor of CountMediaItems()
-- and IsMediaItemSelected() instead
-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
local GetCnt = r.CountSelectedMediaItems
local sel_t = {}
	for i = 0, GetCnt(0)-1 do -- store selected items
	sel_t[#sel_t+1] = r.GetSelectedMediaItem(0,i)
	end
r.SelectAllMediaItems(0,false) -- selected false // deselect all
r.Main_OnCommand(40528, 0) -- Item: Select item under mouse cursor // selects item under mouse (or keeps selected), deselects others; deselects all if mouse is outside of items within Arrange
local found = GetCnt(0) > 0
	r.SelectAllMediaItems(0,false) -- selected false // deselect all
	for _, itm in ipairs(sel_t) do -- restore item selection
	r.SetMediaItemSelected(itm, true) -- selected true
--	r.UpdateItemInProject(itm) -- same as r.UpdateArrange()
	end
r.UpdateArrange()
return found
end


function Is_Item_Under_Mouse_Locked()
local x, y = r.GetMousePosition()
local item = r.GetItemFromPoint(x,y, true) -- allow_locked true
return item and r.GetMediaItemInfo_Value(item, 'C_LOCK') & 1 == 1
end


-- math.randomseed(math.floor(r.time_precise()*1000)) -- math.floor() because the seeding number must be integer; seems to facilitate greater randomization at fast rate thanks to milliseconds count
function rand_active_take_idx(take_cnt, cur_take_idx, ALLOW_REPEATS)
	repeat
	cur_take_new_idx = math.random(take_cnt)
	until ALLOW_REPEATS and cur_take_new_idx or cur_take_new_idx-1 ~= cur_take_idx

return cur_take_new_idx-1 -- -1 since math.random's range begins with 1 while take count is 0 based
end
-- USE:
-- local cur_take_idx = r.GetMediaItemInfo_Value(item, 'I_CURTAKE')
-- r.SetMediaItemInfo_Value(item, 'I_CURTAKE', rand_active_take_idx(take_cnt, cur_take_idx, ALLOW_REPEATS))


function Split_Item_Into_Takes_And_Reconstruct(item)
-- relies on GetObjChunk and SetObjChunk functions

local chunk = GetObjChunk(item)
local t = {}
local take_cnt = r.r.CountTakes(item)

-- split chunk between takes
local header = chunk:match('(.-)\nNAME')
t[take_cnt] = chunk:match('.+(\nNAME.+)\n>') -- last take chunk just before item chunk closure >, add to last take field // ALTERNATIVELY THIS CAN BE ADDED AFTER THE repeat loop below as t[#t] = chunk:match('.+(\nNAME.+)\n>')
local i, st, fin, capt = 1, 0, 0
	repeat
	st, fin, capt = chunk:find('(\nNAME.-)\nTAKE[%W]', fin) -- excluding 'TAKE' token from the capture because the first one won't have it anyway, will be re-added afterwards
		if not st then break
		else
		t[i] = capt; i=i+1
		end
	until not st

----------------------------------------
-- DO STUFF TO TAKES, e.g. sort/reorder
----------------------------------------

-- reconstruct chunk
local chunk_proc = header
	for k, take_chunk in ipairs(t) do
	chunk_sorted = chunk_proc..(k > 1 and '\nTAKE' or '')..take_chunk -- take 1 isn't preceded by 'TAKE' token
	end
chunk_proc = chunk_proc..'\n>' -- close item chunk

SetObjChunk(item, chunk_proc)

end


function Item_Has_Top_Icon_Bar(item)
-- top icon bar is enabled if 'Draw labels above the item' and 'Volume knob'
-- are enabled at Preferences -> Appearance -> Media
-- doesn't support FIP mode
local item_y = r.GetMediaItemInfo_Value(item, 'I_LASTY')
	if item_y == 15 then return true end
local tr = r.GetMediaItemTrack(item)
local item_h = r.GetMediaItemInfo_Value(item, 'I_LASTH')
local mode = r.GetMediaTrackInfo_Value(tr, 'I_FREEMODE')
local FIL = mode == 2 and r.GetMediaTrackInfo_Value(tr, 'C_LANESCOLLAPSED') == 0
	if FIL then -- FIL mode
	local FIL_cnt = r.GetMediaTrackInfo_Value(tr, 'I_NUMFIXEDLANES') 
	local FIL_idx = r.GetMediaItemInfo_Value(item, 'I_FIXEDLANE')
	return item_y - item_h * FIL_idx >= 15 -- OR item_y - item_h * (FIL_cnt-1) >= 15 -- in FIL mode the gap may be bigger hence >= 15
	elseif mode == 0 then -- applies to overlapping items displayed in lanes
		return item_y%item_h ~= 0 -- when there's top icon bar, Y coordinate of an overlapping item in any lane will be divided by item height with remainder that is non-integer quotient
	end
end



function Get_Default_Take_Rank_Scale()
-- the one defined at Preferences -> Editing behavior -> Take marker ranking level
-- the nested tables contain max and min scale values
-- respectively
local t = {[1]={1,0},[2]={2,0},[3]={3,0},[4]={4,0},[5]={5,0}, -- or 257 - 261
[17]={1,1},[18]={2,1},[19]={3,1},[20]={4,1},[21]={5,1}} -- or 273 - 277
local ret, scale = r.get_config_var_string('itemranks')
-- 256 is added to the value when the option Up/down/cycle actions skip 'no ranking' is Off
return t[scale+0] or t[scale-256]
end


function Get_Take_Rank(take, rank_scale_t)
-- rank_scale_t is a table stemming from Get_Take_Rank_Scale()
-- which contains the number of positive ranks as the 1st value
-- and the number of negative ones as the 2nd, which can be 0
-- optional, if you want to evaluate whether the
-- marker rank is within the current default scale;
-- 1st return value is current rank: 
-- 0 no rank, -1 negative rank (only one level is supported)
-- or positive;
-- 2nd optional return value is boolean indicating whether
-- the take rank is within the currently set default scale;
-- only the first found ranked marker is evaluated;
-- the function complies with stock rank scales
-- defined at Preferences -> Editing behavior -> Take marker ranking level
	for i=0, r.GetNumTakeMarkers(take)-1 do
	local retval, name, color = reaper.GetTakeMarker(take, i)
		if name:match('^:[%(%)]') then -- rank marker, because it starts with a colon and a parenthesis
		local cur_rank = name:match('%(') and -1 or select(2,name:gsub('%)','')) or 0 -- 0 is no rank
		return cur_rank, rank_scale_t and cur_rank <= rank_scale_t[1] and cur_rank >= rank_scale_t[2]*-1 -- multiplying by -1 to make the lowest rank compatible with the 1st return value in case it's negative
		end
	end
end


function Get_Set_Take_Marker_Length(take, mrkr_idx, length)
-- mrkr_idx is 0-based index
-- length arg is a floating number, take marker length in seconds
-- if length arg is invalid GET routine is activated
-- otherwise SET
-- relies on Esc() function

local take_cnt = r.GetNumTakeMarkers(take)
  if take_cnt == 0 or take_cnt-1 < mrkr_idx then return end
  
local ret, chunk = r.GetItemStateChunk(r.GetMediaItemTake_Item(take), '', false) -- isundo false
local GetSet = r.GetSetMediaItemTakeInfo_String
local ret, take_GUID = GetSet(take, 'GUID', '', false) -- setNewValue false
local index, take_chunk, found = 0, length and {}
local mrkr_props

for line in chunk:gmatch('[^\r\n]+') do
	if line and line:match(Esc(take_GUID)) then found = 1 end
	if found then
	local marker = line:match('^TKM [%.%d]+') -- take marker props lie
		if not length and marker and index == mrkr_idx then -- GET
		return line:match('TKM .-([%d%.]+)$') -- last field in marker props which is its length value if supported
		elseif length then -- SET, first collect the take chunk starting from its GUID
		take_chunk[#take_chunk+1] = line
		end
	index = marker and index+1 or index
		if line:match('^GUID {') and not line:match(Esc(take_GUID)) then break end -- next take
	end
end
  
	if take_chunk and #take_chunk > 0 then -- SET
	local take_chunk_init = Esc(table.concat(take_chunk,'\n')) -- store here before it's modified in the loop below
		for line_idx, line in ipairs(take_chunk) do
			if line:match('TKM .-([%.%d]+)$') then -- first take marker props
			local target_idx = line_idx+mrkr_idx -- calc index of the target marker line in the table
			local line = take_chunk[target_idx]
			take_chunk[target_idx] = line:match('(.-)[%.%d]+$')..length -- update
			break
			end
		end
	local take_chunk_upd = table.concat(take_chunk,'\n'):gsub('%%','%%%%') -- escape
	chunk = chunk:gsub(take_chunk_init, take_chunk_upd)
	r.SetItemStateChunk(item, chunk, false) -- isundo false
	end

end


function Media_Items_Exist1(want_sel_tracks)
-- want_sel_tracks is boolean to only evaluate selected tracks

	for i=0, r.GetNumTracks()-1 do
	local tr = r.GetTrack(0,i)
		if (not want_sel_tracks or want_sel_tracks and r.IsTrackSelected(tr))
		and r.GetTrackNumMediaItems(tr) > 0 then
		return true
		end
	end

end


function Media_Items_Exist2(want_sel_tracks) -- more efficient
-- want_sel_tracks is boolean to only evaluate selected tracks
	
	if not want_sel_tracks and r.CountMediaItems(0) > 0 then return true end

	for i=0, r.CountSelectedTracks()-1 do
	local tr = r.GetSelectedTrack(0,i)
		if r.GetTrackNumMediaItems(tr) > 0 then 
		return true
		end
	end

end



function Audio_Take_Exists_In_Selected_Items(want_active_take)
	for i=0, r.CountSelectedMediaItems(0)-1 do
	local item = r.GetSelectedMediaItem(0,i)
		if want_active_take and not r.TakeIsMIDI(r.GetActiveTake(item)) then return true 
		elseif not want_active_take then
			for i=0, r.CountTakes(item, i)-1 do
				if not r.TakeIsMIDI(r.GetTake(item, i)) then return true end
			end
		end
	end
end



function Get_Item_Lane_Index(item) -- 1-based
-- same as r.GetMediaItemInfo_Value(item, 'I_FIXEDLANE')
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo false
local YPOS = chunk:match('(YPOS.-)\n')
	if not YPOS then return end -- track lanes aren't enabled
local Y, ratio = YPOS:match('([%.%d]+) ([%.%d]+)') -- Y is lane relative Y coordinate within track height which is 1, i.e. the height of all preceding lanes, ratio is ratio between track height and single lane height, track height is divided uniformely between lanes
return Y+ratio / ratio -- Y+ratio is the analysed and preceding lanes combined height within track height
end 



function Duplicate_Active_Take_Contiguously(sel_item, want_above)
-- FULLY IMPLEMENTED IN Duplicate active take contiguously in selected items.lua
-- duplicate and place immediately below the source take
-- or above if want_above arg is valid
-- contrary to the stock action which places it at the bottom;
-- the function must be applied to each selected item separately
-- because action is involved which affects all selected items
-- simultaneously, so the function must be preceded and followed 
-- by storage and restoration of item selection;
-- the function must be executed within the Undo block
-- to prevent creation of undo points by actions
-- of which there'll be several

	local function to_top()
	r.Main_OnCommand(41380,0) -- Item: Move active takes to top
	end

local ACT, Activate = r.Main_OnCommand, r.SetActiveTake
local item = sel_item or r.GetSelectedMediaItem(0,0)
local act_take = item and r.GetActiveTake(item)
local act_take_idx = item and r.GetMediaItemTakeInfo_Value(act_take, 'IP_TAKENUMBER') -- OR r.GetMediaItemInfo_Value(item, 'I_CURTAKE')
local take_cnt = item and r.CountTakes(item)

-- empty take inserted with 'Item: Add an empty take after the active take' doesn't have a pointer
-- even though it can be active
	if not item or not act_take then return end
	
--r.Undo_BeginBlock()

ACT(40639, 0) -- Take: Duplicate active take // this will be placed at the bottom // ignores empty takes created with 'Item: Add an empty take after the active take'
local new_take_idx = r.CountTakes(item)-1 -- placed at the bottom hence the 0-based index is equal to take count-1
local new_take = r.GetTake(item, new_take_idx)
--[[ OR
local new_take = r.GetTake(item, r.CountTakes(item)-1)
local new_take_idx = r.GetMediaItemTakeInfo_Value(new_take, 'IP_TAKENUMBER')
--]]

	if act_take_idx ~= take_cnt-1 or want_above then -- if active take is last and want_above is false, not need to cycle, everything will fall in place, even though cycling would still work
	
		if not want_above then
		to_top() -- new take is active, move it to top
		Activate(act_take) -- activate originally active take so it can be affected by the action
		to_top() -- move active take to top, now they're in the expected order relative to each other but at wrong places within the item
		else
		Activate(act_take) -- set originally active take active, because cuurently the duplicate take is active
		to_top() -- move to top
		Activate(new_take) -- set duplicate take active
		to_top() -- move to top, now they're in the expected order relative to each other but at wrong places within the item
		end
	
	-- At this point the index of oringinally active take is 0 
	-- and of the new take is 1,
	-- cycle takes until the originally active take ends up at its original index
	-- and is immediately followed by the new take
		for i=1, act_take_idx do -- cycle as many times as the original index of the originally active take, because it reflects the number of takes which preceded it and whose original position must be restored
		Activate(r.GetTake(item, act_take_idx+1)) -- target take which now occupies position of the originally active take, +1 to account for the newly inserted take which precedes such take in the new take order
		to_top() -- move to top
		end
	end

Activate(new_take) -- activate newly added take
r.UpdateItemInProject(item) -- to make re-activated take immediately visible
--r.Undo_EndBlock('TEST', -1)
return new_take
end



function Move_Active_Take_Within_Item(sel_item, down)
-- fully implemented in Move active take up-down within selected items.lua
-- down is boolean to move down one take lane rather than up;
-- when take is the topmost or the bottommost the movement
-- wraps around;
-- the function must be applied to each selected item separately
-- because action is involved which affects all selected items
-- simultaneously, so the function must be preceded and followed 
-- by storage and restoration of item selection;
-- the function must be executed within the Undo block
-- to prevent creation of undo points by actions
-- of which there'll be several

	local function to_top()
	r.Main_OnCommand(41380,0) -- Item: Move active takes to top
	end

local ACT, Activate = r.Main_OnCommand, r.SetActiveTake
local item = sel_item or r.GetSelectedMediaItem(0,0)
local act_take = item and r.GetActiveTake(item)
local act_take_idx = item and r.GetMediaItemTakeInfo_Value(act_take, 'IP_TAKENUMBER') -- OR r.GetMediaItemInfo_Value(item, 'I_CURTAKE')
local take_cnt = item and r.CountTakes(item)

-- empty take inserted with 'Item: Add an empty take after the active take' doesn't have a pointer
-- even though it can be active
	if not item or not act_take then return end
	
--r.Undo_BeginBlock()

local fin, idx
	if not down then -- up
	to_top() -- start out by moving active take to top lane
	fin = act_take_idx > 0 and act_take_idx-1 or take_cnt-1 -- if active take isn't the topmost, after moving it to top, cycle as many times as take count less 2 because it itself and originally previous take which has not taken its place don't need moving to simulate exchange of places between them, otherwise cycle as many times as take count less 1 because it itself doesn't need moving and only waits until as a result of other takes movement in top in turns it ends up at the bottom in a wrap-round fashion relative to its top positon
	idx = act_take_idx > 0 and act_take_idx-1 or take_cnt-1 -- if active take is not the topmost, after moving it to top use prev take index because the originally previous take which has now assumed active take original index don't need moving in order to remain at the active take original position as if it exchanged places with the active take while the order or earlier takes needs to be restored by moving each of them to top in turns; if the active take is the topmost, use bottommsost take index to move to top in turns all takes which follow the active one as they end up at the bottom until the active take itself ends up at the bottom in a wrap-round fashion relative to its top positon
	else -- down
		if act_take_idx+1 < take_cnt then -- if active take is not the bottommost, first move to top the take which follows the active one so the active one replaces its in the take sequence
		Activate(r.GetTake(item, act_take_idx+1))
		to_top() -- start out by moving the take which follows the active take, to top lane
		fin = act_take_idx -- cycle as many times as the active take index because that's how many take exchanges will have to be made to restore the original order of takes above the active one 
		idx = act_take_idx -- use the active take index because when the following take is moved to top above and the active take is moved down one take lane the prevous take assumes active take index, and during cycling the take at the original active take index, i.e. now immediately above it, must be moved up in turn to restore original take order
		else to_top() -- move the bottommost active take to top in a wrap-round fashion
		end
	end
	if fin then -- fin will be nil if the bottomost take was moved down because by this point it will have been placed at its destination at the top in a wrap-round fashion in the code above
		for i=1, fin do
		Activate(r.GetTake(item, idx))
		to_top()
		end
	end

Activate(act_take) -- restore active take active status
r.UpdateItemInProject(item) -- to make re-activated take immediately visible
--r.Undo_EndBlock('TEST', -1)

end



function get_active_take_index_via_chunk(item)
-- useful when item contains empty takes which don't have a pointer
-- and therefore cannot be evaluated for being active
-- with other API functions
local ret, chunk = r.GetItemStateChunk(item, '', false) -- isundo false
local cntr = 0
	for line in chunk:gmatch('[^\n\r]+') do		
		if line:match('^TAKE$') or line:match('^TAKE ')then cntr = cntr+1 end		
		if line:match('^TAKE SEL') or line:match('^TAKE NULL SEL') then return cntr end -- TAKE NULL is attribute of a take inserted with actions 'Item: Add an empty take before/after the active take'
	end
return 0 -- if no active take found in the chunk, it must be the topmost because in this case its TAKE attribute isn't listed
end



function Convert_Empty_Take_To_Valid_Take(take_idx, item)
-- empty take is either empty item or take inserted with 
-- actions 'Item: Add an empty take before/after the active take';
-- take_idx is 0-based, index is used because empty takes 
-- don't have a pointer so to set them active 
-- 9 instances of the action 'Take: Set X take active' 
-- have to be used, for this reason 9 is the max empty take index
-- supported by the function;
-- the fuction takes advantage of the fact that inserting
-- take marker in an empty take turns it into a valid take
-- which can have a label in paticular;
-- relies on get_active_take_index_via_chunk();
-- THE FUNCTION MUST BE WRAPPED WITHIN undo block
-- so that the included actions don't create their
-- own undo points

	if take_idx > 9 then return end
	
local ACT = r.Main_OnCommand

-- store active take before setting target take active
-- to restore later
local active_take = r.GetActiveTake(item)
local active_take_idx
	if not active_take then -- active take is an empty take
	active_take_idx = get_active_take_index_via_chunk(item)
	end
	
r.PreventUIRefresh(1)
	
local sel_empty_takes = r.GetToggleCommandStateEx(0, 41355) == 1 -- Options: Allow selecting empty takes
	if not sel_empty_takes then ACT(41355, 0) end -- toggle to enable to be able to select empty takes with actions	
	
-- store for rstoration because it will have to be moved
-- to intersect with the item for insert take marker action to work
local cur_pos = r.GetCursorPosition()

local item_st = r.GetMediaItemInfo_Value(item, 'D_POSITION')
local item_len = r.GetMediaItemInfo_Value(item, 'D_LENGTH')

r.SetEditCurPos(item_st + item_len/2, false, false) -- moveview, boolean false // move to the middle of the item

ACT(45000+take_idx, 0) -- set target empty take active

-- store selected items to be able to select the target item exclusively
-- and then restore original item selection
local sel_itms = {}
	for i=0, r.CountMediaItems(0)-1 do
	local item = r.GetMediaItem(0,i)
		if r.IsMediaItemSelected(item) then
		sel_itms[#sel_itms+1] = item
		end
	end
	
-- select target item exclusively
r.SelectAllMediaItems(0, false) -- selected false // deselect all
r.SetMediaItemSelected(item, true) -- selected true
ACT(42390, 0) -- Item: Quick add take marker at play position or edit cursor
ACT(42386, 0) -- Item: Delete take marker at cursor

-- restoration routine
	if active_take then
	r.SetActiveTake(active_take)
	elseif active_take_idx < 10 then -- the action can only target first 9 takes
	-- if originally active take was empty and it's index exceeds 9, it won't be re-activated
	-- although it's possible via chank by setting 'TAKE NULL' to 'TAKE NULL SEL'
	ACT(45000+active_take_idx, 0) -- active take
	end
r.SetEditCurPos(cur_pos, false, false) -- moveview, boolean false // cursor position
r.SelectAllMediaItems(0, false) -- selected false // deselect all
	for k, item in ipairs(sel_itms) do
	r.SetMediaItemSelected(item, true) -- selected true
	end
	
	if not sel_empty_takes then ACT(41355, 0) end -- toggle to disable, restoring original state
	
r.UpdateItemInProject(item)

r.PreventUIRefresh(-1)
	
end




--================================ I T E M S   E N D ==================================


--=================================== C O L O R =======================================


function Theme_Color_To_Native(color)
-- convert color value returned by GetThemeColor()
-- into format returned by object functions
return color|0x1000000 -- 0x1000000 is included in the color code when it's set
end


function Validate_HEX_Color_Setting1(HEX_COLOR) -- see streamlined version below
local HEX_COLOR = type(HEX_COLOR) == 'string' and HEX_COLOR:gsub('[%s%c]','') -- remove empty spaces and control chars just in case

-- default to black if color is improperly formatted
local HEX_COLOR = (not HEX_COLOR or type(HEX_COLOR) ~= 'string' or HEX_COLOR == '' or #HEX_COLOR < 4 or #HEX_COLOR > 7) and '#000' or HEX_COLOR

--[[ alternative to defaulting to black color above, abort color setting if HEX_COLOR var is malformed
local HEX_COLOR = type(HEX_COLOR) == 'string' and #HEX_COLOR >= 4 and #HEX_COLOR <= 7 and HEX_COLOR
	if not HEX_COLOR then return end
]]

-- extend shortened (3 digit) hex color code, duplicate each digit
local HEX_COLOR = #HEX_COLOR == 4 and HEX_COLOR:gsub('%w','%0%0') or not HEX_COLOR:match('^#') and '#'..HEX_COLOR or HEX_COLOR -- adding '#' if absent
return HEX_COLOR -- TO USE THE RETURN VALUE AS ARG IN hex2rgb() function UNLESS IT'S INCLUDED IN THIS ONE AS FOLLOWS
--local R,G,B = hex2rgb(HEX_COLOR) -- R because r is already taken by reaper, the rest is for consistency
--return R, G, B
end


function Validate_HEX_Color_Setting2(HEX_COLOR)
local c = type(HEX_COLOR)=='string' and HEX_COLOR:gsub('[%s%c]','') -- remove empty spaces and control chars just in case
c = c and (#c == 3 or #c == 4) and c:gsub('%w','%0%0') or c -- extend shortened (3 digit) hex color code, duplicate each digit
c = c and #c == 6 and '#'..c or c -- adding '#' if absent
	if not c or #c ~= 7 or c:match('[G-Zg-z]+') -- invalid letters
	or not c:match('#%w+') then return '#000000' -- black
	end
return c
end


function hex2rgb(HEX_COLOR)
-- https://gist.github.com/jasonbradley/4357406
    local hex = HEX_COLOR:sub(2) -- trimming leading '#'
    return tonumber('0x'..hex:sub(1,2)), tonumber('0x'..hex:sub(3,4)), tonumber('0x'..hex:sub(5,6))
end


function FTC_HexToNormRGB(color) -- by FTC
-- https://github.com/iliaspoulakis/Reaper-Tools/blob/master/Media%20explorer/MX%20Tuner.lua
    local r, g, b = r.ColorFromNative(color)
    return {r / 255, g / 255, b / 255}
end

function rgb2hex(r, g, b)
-- https://gist.github.com/yfyf/6704830
    return string.format("#%0.2X%0.2X%0.2X", r, g, b)
end


function RANDOM_RGB_COLOR()
math.randomseed(math.floor(r.time_precise()*1000)) -- math.floor() because the seeding number must be integer; seems to facilitate greater randomization at fast rate thanks to milliseconds count
--[[
local RGB = {}
	for i = 1, 3 do
	RGB[i] = math.random(1,256)-1 -- seem to produce 2 digit numbers more often than (0, 255), but could be my imagination
	end
--]]
--[-[
local RGB = {r = 0, g = 0, b = 0}
	for k in pairs(RGB) do -- adds randomization (i think) thanks to pairs which traverses in no particular order // once it picks up a particular order it keeps at it throughout the entire main repeat loop when multiple colors are being set
	RGB[k] = math.random(1,256)-1 -- seems to produce 2 digit numbers more often than (0,255), but could be my imagination
--Msg(k)
	end
--Msg(RGB.r); Msg(RGB.g); Msg(RGB.b)
--]]
return RGB
end


function Generate_Random_Color_Val()
-- https://stackoverflow.com/questions/36756331/js-generate-random-boolean
-- https://stackoverflow.com/questions/29851873/convert-a-number-between-1-and-16777215-to-a-colour-value
math.randomseed(math.floor(r.time_precise()*1000)) -- seems to facilitate greater randomization at fast rate thanks to milliseconds count; math.floor() because the seeding number must be integer
return math.random(0, 16777215) -- the range of values returned by GR_SelectColor()
end
-- USE:
-- local rand = Generate_Random_Color_Val()
-- local color = math.random(0, rand)|0x1000000 -- gives greater randomization
-- r.SetMediaTrackInfo_Value(tr, 'I_CUSTOMCOLOR', color, true) -- for example


function zaibuyidao_RGBHexToDec(R, G, B)
-- https://raw.githubusercontent.com/zaibuyidao/ReaScripts/239ebd6a73cf5e7b124ef6f65b21e8eae63acd61/Regions/zaibuyidao_Set%20Region%20Color.lua
  local red = string.format("%x", R)
  local green = string.format("%x", G)
  local blue = string.format("%x", B)
  if (#red < 2) then red = "0" .. red end
  if (#green < 2) then green = "0" .. green end
  if (#blue < 2) then blue = "0" .. blue end
  local color = "01" .. blue .. green .. red
  return tonumber(color, 16)
end


function randomize_color()
-- source https://github.com/joabeslopes/Reaper-scripts-multitrack-creation/blob/main/Scripts/createMultipleTracks.lua
local r,g,b
	for n = 100, math.random(150,200) do
	math.randomseed(os.time()..n..n)
	math.random(); math.random();
	r = math.random(0,255)
	g = math.random(0,255)
	b = math.random(0,255)
	end
return r,g,b
end



------------------- ENCODE RGB TO AND DECODE FROM INTEGER ------------------

--https://github.com/ReaTeam/ReaScripts/blob/master/Regions/stepanhlavsa_Big%20region%20progress%20bar%20for%20live%20use.lua

local function rgb2num(r, g, b)
  g = g * 256
  b = b * 256 * 256
  return r + g + b
end

local function num2rgb(integer)
   local R = integer & 255
   local G = (integer >> 8) & 255
   local B = (integer >> 16) & 255
   local R = R/255
   local G = G/255
   local B = B/255
   return R,G,B
end


function RGB_To_From_Integer1(r,g,b,integer)
-- based on https://stackoverflow.com/a/19277438/8883033
-- local r, g, b = 12, 13, 14
	if not integer and r and g and b then
	return integer = (b << 16) + (g << 8) + r
	elseif integer then
	local blueMask, greenMask, redMask = 0xFF0000, 0xFF00, 0xFF
	local b = (integer & blueMask) >> 16
	local g = (integer & greenMask) >> 8
	local r = integer & redMask
	return r, g, b
	end
end



function RGB_To_From_Integer2(r,g,b,integer)
-- based on https://stackoverflow.com/a/29130472/8883033
-- local r, g, b = 111, 222, 121
	if not integer and r and g and b then
	local integer = red*256*256 + green*256 + blue
	return integer
	elseif integer then
	local r = (integer - blue - green*256)/(256*256)
	local g = (integer%(256*256) - blue)/256
	local b = integer%256
	return r, g, b
	end
end


function RGB_To_Normalized(R,G,B)
local unit = 1/255
return R and unit*R or 255, G and unit*G or 255, B and unit*B or 255
end
--[[EXAMPLE:
local R,G,B = table.unpack((not R and not G and not B) and {255,255,255} or {R,G,B}) -- defaults to white if none is supplied
gfx.r, gfx.g, gfx.b = RGB_To_Normalized(R, G, B)
]]



function HEX_color_2_integer(HEX)
-- tonumber(HEX:gsub('#',''), 16) isn't suitable because it converts into a big endian number whereas color code is little endian, which seem only apply to Windows
-- https://forums.cockos.com/showthread.php?t=253981#5
local r,g,b = HEX:match('(%x%x)(%x%x)(%x%x)')
r, g, b = tonumber(r,16), tonumber(g,16), tonumber(b,16)
return r|g<<8|b<<16 -- OR r+(g<<8)+(b<<16)
end



function Split_Integer_To_RGB_And_Combine(color)
-- color is 24 bit integer returned by GR_SelectColor() or r.ColorToNative(r, g, b)

local r, g, b = color & 0xFF, color >> 8 & 0xFF, color >> 16  -- color value returned by GR_SelectColor() is 24 bit little endian (3 clusters of 8 bits each, i.e. 3 ranges of 0 - 255), max decimal value is 16777215 (zero based), count starts on the right, so rgb direction is right to left (seems to only apply to Windows https://forums.cockos.com/showthread.php?t=253981#5) // 'color & 0xFF' is masking rightmost 8 bits with 11111111, 'color >> 8 & 0xFF' is shifting middle 8 bits rightwards 8 places so they replace the original rightmost 8 bits and then masking, 'color >> 16' is shifting leftmost 8 bits 16 places rightwards so they relplace the original rightmost 8 bits, no masking is needed because at this point there're no set bits anymore beyond these 8 // same as r.ColorFromNative()

-- DO STUFF (like randomize or other operations)

local color = b<<16 | g<<8 | r -- combine back into a 24 bit value, b<<16 creates a 24 bit value because b is 8 bit and shifting by 16 places leftwards makes it 8+16 = 24, in reverse order since color value must be little endian, g<<8 is 16 bit value (8+8=16) and r is 8 bit // same as r.ColorToNative(r, g, b)

end



-------------- ENCODE RGB TO AND DECODE FROM INTEGER END ------------------


function Extract_Object_Color(obj)
-- obj is track, item, active take (in multi-take items), envelope
-- relies on Get_Env_Custom_Colors() in ENVELOPES chapter
-- see function Get_Marker_Reg_At_Mouse_Or_EditCursor() for marker/region color extraction in MARKERS/REGIONS chapter

local env_col_key_t = {
tr = {
	['Playrate'] = 'col_env5', -- Envelope: Master playrate -- current RGB: 0,0,0
	['Tempo map'] = 'col_env6', -- Envelope: Master tempo -- current RGB: 0,255,255
	['Volume (Pre-FX)'] = 'col_env1', -- Envelope: Volume (pre-FX) -- current RGB: 0,220,128
	['Volume'] = 'col_env2', -- Envelope: Volume -- current RGB: 64,128,64
	['Pan (Pre-FX)'] = 'col_env3', -- Envelope: Pan (pre-FX) -- current RGB: 255,0,0
	['Pan'] = 'col_env4', -- Envelope: Pan -- current RGB: 255,150,0
	['Trim Volume'] = 'env_trim_vol', -- Envelope: Trim Volume -- current RGB: 0,0,0
	-- Until build 6.11 Trim volume env color was linked to Master track playrate envelope color
	-- https://forum.cockos.com/showthread.php?t=235873
	-- 6.11 changelog: Themes: allow separate configuration of Trim Volume envelope color
	['Mute'] = 'env_track_mute', -- Envelope: Mute -- current RGB: 192,0,0
	['Width'] = 'col_env7', -- Envelope: Send volume -- current RGB: 128,0,0 // incl. pre-FX width
	-- Width color wasn't documented until build 6.59 https://forum.cockos.com/showthread.php?t=267111
	-- 6.59 changelog: Theme: update theme tweaker description for shared theme color
	['Send Mute'] = 'env_sends_mute', -- Envelope: Send mute -- current RGB: 192,192,0
--[[
	Send Volume/Pan (2) explanation https://forum.cockos.com/showthread.php?t=260829
	the color depends on the original order of the sends in the list of receives
	in the desination track: odd - regular color, even - color 2
	BUT if one of the volume/pan sends is deleted the env colors don't update to match the new order
	so there's no way to know which of the colors is active because deleted envelopes
	cannot be accounted for
	hence getting both regular send/volume and send/volume 2 env color is not supported
	['Send Volume'] = 'col_env7', -- Envelope: Send volume -- current RGB: 128,0,0 // same as prev
	['Send Pan'] = 'col_env8', -- Envelope: Send pan -- current RGB: 0,128,128
	'col_env9', -- Envelope: Send volume 2 -- current RGB: 0,128,192
	'col_env10', -- Envelope: Send pan 2 -- current RGB: 0,64,0
--	]]
	['Audio Hardware Output: Volume'] = 'col_env11', -- Envelope: Audio hardware output volume -- current RGB: 0,255,255
	['Audio Hardware Output: Pan'] = 'col_env12', -- Envelope: Audio hardware output pan -- current RGB: 255,255,0
	['Audio Hardware Output: Mute'] = 'env_sends_mute' -- Envelope: Send mute -- current RGB: 192,192,0 // same as ['Send Mute']
	},
take = {
	['Volume'] = 'env_item_vol', -- Envelope: Item take volume -- current RGB: 128,0,0
	['Pan'] = 'env_item_pan', -- Envelope: Item take pan -- current RGB: 0,128,128
	['Mute'] = 'env_item_mute', -- Envelope: Item take mute -- current RGB: 192,192,0
	['Pitch'] = 'env_item_pitch' -- Envelope: Item take pitch -- current RGB: 0,255,255
	},
fx = {
	[0] = 'col_env13', -- Envelope: FX parameter 1 -- current RGB: 128,0,255
	[1] = 'col_env14', -- Envelope: FX parameter 2 -- current RGB: 64,128,128
	[2] = 'col_env15', -- Envelope: FX parameter 3 -- current RGB: 0,0,255
	[3] = 'col_env16' -- Envelope: FX parameter 4 -- current RGB: 255,0,128
	}
}

	local function extract_itm_take_color(color, obj, is_take, is_itm)
	-- item take color if not set explicitly is inherited from the item if item color has been customized and is take default color
	local GetItm, GetTr = r.GetMediaItemInfo_Value, r.GetMediaTrackInfo_Value
		if is_take and color == 0 then -- default take color, i.e. may be inherited from item if item color has been customized, get item color
		local item = r.GetMediaItemTake_Item(obj)
		local color = GetItm(item, 'I_CUSTOMCOLOR')
			-- item color if not set explicitly is inherited from the track if track color has been customized and is item default color
			if color == 0 then -- default item color, inherited from track if track color has been customized, get track color
			color = GetTr(r.GetMediaItemTrack(item), 'I_CUSTOMCOLOR')
				if color ~= 0 and color ~= 16576 then return color end -- only return if not default track color because only in this case it overrides item default color // track default color integer is 16576 immediatedly after REAPER startup which equals 192,64,0 - RGB, the color selected in the track color picker by default but not applied; if 'Track: Set to default color' action was applied at least once the value becomes 0 (relevant to versions 5 - 7, didn't test earlier)
			else -- item custom color
			return color
			end
		-- item color if not set explicitly is inherited from the track if track color has been customized and is item default color
		elseif is_itm and color == 0 then -- default item color, inherited from track if track color has been customized, get track color
		local color = GetTr(r.GetMediaItemTrack(obj), 'I_CUSTOMCOLOR')
			if color ~= 0 and color ~= 16576 then return color end -- only return if not default track color because only in this case it overrides item default color // see comment above
		end
	return color -- no change
	end

local is_tr, is_itm, is_take, is_env = r.ValidatePtr(obj, 'MediaTrack*'), r.ValidatePtr(obj, 'MediaItem*'),
r.ValidatePtr(obj, 'MediaItem_Take*'), r.ValidatePtr(obj, 'TrackEnvelope*')
local GET = is_tr and r.GetMediaTrackInfo_Value or is_itm and r.GetMediaItemInfo_Value
or r.GetMediaItemTakeInfo_Value
local color

	if is_env then
	local retval, env_name = r.GetEnvelopeName(obj)
	local tr_env = obj == r.GetSelectedTrackEnvelope(0)
	local custom_env_col_t = Get_Env_Custom_Colors()
	-- first try to tetrieve custom color, supported since REAPER 7
	-- if none set or not REAPER 7 custom_env_col_t will be nil
		if custom_env_col_t then
			for name, hex_color in pairs(custom_env_col_t) do
				if env_name:match(Esc(name)) then -- all types of envelopes
				-- suffices that the String is included in the FX param name
				-- color associated with the first string match is applied
				local rgb = {hex2rgb(hex_color)}
				return hex_color, rgb, r.ColorToNative(table.unpack(rgb))|0x100000
				end
			end
		end
	--	if custom color wasn't returned, look for theme colors
		if env_name == 'Send Volume' or env_name == 'Send Pan' then
		local err = ' send volume/pan envelope color \n\n   cannot be extracted reliably'
		Error_Tooltip('\n\n'..err..'\n\n', 1,1) -- caps, spaced true
		return 'env error'
		end
	local key = tr_env and env_col_key_t.tr[env_name] or env_col_key_t.take[env_name]
		if not key then -- fx envelope
		local GetParentObj, GetParmName =
		table.unpack(tr_env and {r.Envelope_GetParentTrack, r.TrackFX_GetParamName}
		or {r.Envelope_GetParentTake, r.TakeFX_GetParamName})
		local par_obj, fx_idx, parm_idx = GetParentObj(obj)
		key = parm_idx <= 4 and parm_idx or parm_idx%4 -- env colors repeat every 4 parameters
		key = env_col_key_t.fx[key]
		end
	color = key and r.GetThemeColor(key, 0) -- 0 current color rather than theme's default, determined by the settings in the 'Theme development/tweaker' dialogue (NOT in the .ReaperTheme file) ignoring settings in the 'Theme Color Control' dialogue (https://forum.cockos.com/showthread.php?t=291551)
	elseif obj then -- objects other than envelope
	color = GET(obj, 'I_CUSTOMCOLOR')
	color = is_tr and color or extract_itm_take_color(color, obj, is_take, is_itm)
	end

-- https://www.color-hex.com/

local tr_color_alt

	if color and not is_env then -- process color of objects other than envelope
	-- col_mi_bg (Media item odd tracks) until 7.15 was officially referring to odd tracks when in fact refers to even
	-- col_mi_bg2 (Media item even tracks) until 7.15 was officially referring to even tracks when in fact refers to odd
	-- bug report https://forum.cockos.com/showthread.php?t=289479
	-- col_tr1_itembgsel (Media item selected odd tracks)
	-- col_tr2_itembgsel (Media item selected even tracks)
	-- col_seltrack : Selected track control panel background
	-- col_seltrack2 : Unselected track control panel background (enabled with 'Theme overrides' checkbox above) // if the checkbox is enabled the color integer is negative otherwise positive, should be used as is
	local key
	local tr_default_col = color == 16576 or color == 0 -- default (theme settings dependent) color // track default color integer is 16576 immediatedly after REAPER startup which equals 192,64,0 - RGB, the color selected in the track color picker by default but not applied; if 'Track: Set to default color' action was applied at least once the value becomes 0 (relevant to versions 5 - 7, didn't test earlier)
		if is_tr and tr_default_col then
		key = 'col_seltrack2' -- only non-selected state color is extracted
		elseif (is_take or is_itm) and color == 0 then -- default theme settings dependent color
		local obj = is_take and r.GetMediaItemTake_Item(obj) or obj
		local tr_No = r.CSurf_TrackToID(r.GetMediaItemTrack(obj), false) -- mcpView false // get track number because default item color may differ on odd and even tracks if changed in the 'Theme development/tweaker' dialogue and will be displayed if their track color isn't custom
		key = tr_No%2 > 0 and 'col_mi_bg2' or tr_No%2 == 0 and 'col_mi_bg' -- non-selected on odd or even track, until build 7.15 these were mixed up in the 'Theme development/tweaker', see link to bug report above, the bug fix was cosmetic with no change in the keys association
		end
	color = key and r.GetThemeColor(key, 0) -- get default theme color, determined by the setting in the 'Theme development/tweaker' dialogue dialogue (NOT in the .ReaperTheme file) ignoring settings in the 'Theme Color Control' dialogue (https://forum.cockos.com/showthread.php?t=291551): Media item background (odd, even), Unselected track control panel background
	or color -- either default theme color or custom
	tr_color_alt = is_tr and tr_default_col and color > 0 and r.GSC_mainwnd(4) -- default unselected track color value is negative when 'Theme overrides' checkbox is enabled, i.e. theme default rather than OS default background color is used, when it's positive the OS default background color is used // thanks to cfillion https://forum.cockos.com/showthread.php?t=289509#7 for helping to figure out a way to retrieve the OS default background color, COLOR_WINDOW attribute for Win32 GetSysColor() https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getsyscolor
	-- the default OS background color appears to only be relevant to derivates of the Classic theme, v5 and v6 default themes
	end

	if color then
	local rgb = {r.ColorFromNative(color)}
	local hex_color = rgb2hex(table.unpack(rgb))
	return hex_color, rgb, color|0x1000000, tr_color_alt and tr_color_alt|0x1000000
	end

end


--[[ 'Option: Show theme color controls' dialogue

-- Parameters for use with ThemeLayout_GetParameter, ThemeLayout_SetParameter
-- Supported since last builds of the version 5, exact one is uknown since their addition
-- isn't listed in the changelog
-- In version 5 these are the only one supported
-- Since version 6 and the new default theme there're other parameters with positive indices

 idx		retval					desc							value	defValue	minValue	maxValue
-1000, __color_gamma, 			Gamma, 						1000 	1000 		 250 		2000
-1001, __color_shadows, 		Shadows, 						0 		0 		-256 		 256
-1002, __color_midtones, 		Midtones, 						0 		0 		-256 		 256
-1003, __color_highlights, 	Highlights,						0 		0 		-256		 256
-1004, __color_saturation, 	Saturation, 				 256 	 256 			0 		 512
-1005, __color_tint, 			Tint, 						 192 	 192 			0 		 384
-1006, __color_apply_project, Apply to project colors, 	0 		0 			0 			1

-- Extracted with

local i = 0
	repeat
	local retval, desc, value, defValue, minValue, maxValue = reaper.ThemeLayout_GetParameter(i*-1-1000)
		if retval then
Msg((i*-1-1000)..', '..retval..', '..desc..', '..value..', '..defValue..', '..minValue..', '..maxValue)
		end
	i = i+1
	until not retval

-- GetThemeColor, SetThemeColor flags argument 1 (low bit set)
-- retrieves color value in native format modified by
-- controls in 'Option: Show theme color controls' dialogue
-- and possibly by the version 6 Theme Adjuster

Sources:
https://forum.cockos.com/showthread.php?t=291551#6
https://forum.cockos.com/showthread.php?t=242022 basic_theme_adjuster.lua

]]



function AZpercussion_rgbToHex(rgba)
-- passing a table with percentage like {100, 50, 20, 90}
-- a is Alpha
-- used with ReaImgGUI API functions
-- https://github.com/ReaTeam/ReaScripts/pull/1420/files

  local hexadecimal = '0X'

  for key, value in pairs(rgba) do
    local hex = ''
    if value > 100 or value < 0 then return error('Color must be a percentage value\n between 0 and 100') end
    value = (255/100)*value
    while(value > 0)do
      local index = math.floor(math.fmod(value, 16) + 1)
      value = math.floor(value / 16)
      hex = string.sub('0123456789ABCDEF', index, index) .. hex
    end

    if(string.len(hex) == 0)then
      hex = '00'

    elseif(string.len(hex) == 1)then
      hex = '0' .. hex
    end

    hexadecimal = hexadecimal .. hex
  end

return hexadecimal

end



function RandomizeBackgroundColor()
-- Generate random colors
-- https://stash.reaper.fm/v/49308/Randomizer_neu.lua
local r = math.random(0, 255) / 255
local g = math.random(0, 255) / 255
local b = math.random(0, 255) / 255
gfx.set(r, g, b) -- Set background color
gfx.rect(0, 0, gfx.w, gfx.h, 1) -- Draw the colored rectangle
end


--================================ C O L O R   E N D ==================================


--============================ C L O S U R E S  S T A R T =============================

-- 'Set all selected video items to Ignore Audio.lua' by Claudiohbsantos
function LoopOverSelectedItems(proj) -- iterator function, doesn't depend on items count, doesn't produce error when no (more) items
local i = -1 -- to begin iterator with 0 below
	return function() i = i+1; return r.GetSelectedMediaItem(proj, i) end
end
-- USAGE
-- for item in LoopOverSelectedItems(0) do -- if no items, the loop doesn't start
-- end


function return_captures(src_str, capt_str, patt)
-- patt is boolean, true = pattern, false = literal string
local capt_str = patt and capt_str or capt_str:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0') -- do not escape if pattern; escape if literal string
local i = 1
	return function()
	local st, fin, capt = src_str:find('('..capt_str..')',i) -- in order to return the capture string.find requires explicit formatting of the pattern or literal string as a capture
		if i == fin then i = i + 1 -- allow capturing single characters advancing by 1
		elseif fin then i = fin+1 end -- allow capturing series of characters
	return capt
	end
end

--[[ USAGE
-- if no captures the loop doesn't start
for capt in return_captures(str, 'find') do
-- OR
-- for capt in return_captures(str, '%a+', 1) do -- with 3d argument to enable pattern '%a+'
Msg(capt)
end
]]


function gmatch_alt(str, ...)
-- vararg is a list of alternative capture patterns
local i = 1
local t = {...}
	return function()
	local st, fin, retval
		for _, capt in ipairs(t) do -- the t contains capture patterns, traverse until one of them produces valid capture
		st, fin, retval = str:find('('..capt..')',i) -- if the pattern already includes the parentheses they must be removed here // in order to return the capture string.find requires explicit formatting of the pattern or literal string as a capture
			if retval then break end
		end
	i = fin and fin+1 or i+1 -- advance only after all capture patterns have been tried
	return retval
	end
end
--[[ USE:
local str = 'abcdefgh'
for w in gmatch_alt(str, '%d','%p','%a') do
end
]]


function get_track_parents(parent)
	return function()
	parent = r.GetParentTrack(parent) -- assigning to a global value (or upvalue passed as the argument) is crucial to make it work so that the var is constantly updated during the loop, returning r.GetParentTrack(parent) directly won't work because the var isn't updated, the var won't be accessible outside of the loop
	return parent
	end
end
--[[ USE:
	for parent in get_track_parents(r.GetSelectedTrack(0,0)) do	

	end
]]


function get_track_children_and_grandchildren(tr)
local st_idx = r.CSurf_TrackToID(tr, false) -- mcpView false // starting loop from the 1st child
local depth = r.GetTrackDepth(tr)
return function()
	local chld_tr = r.GetTrack(0,st_idx)
		if if chld_tr and r.GetTrackDepth(chld_tr) > depth then
		st_idx=st_idx+1
		return chld_tr
		end
	end
end
--[[ USE:
for child in get_track_children_and_grandchildren(tr) do

end
]]




-- https://github.com/TeamAudio/reaspeech/blob/main/reascripts/common/libs/ReaIter.lua
-- https://github.com/TeamAudio/reaspeech/blob/main/reascripts/ReaSpeech/tests/TestTranscriptAnnotations.lua
ReaIter = {}
ReaIter._make_iterator = function(count_f, item_f) -- count_f stands for count function, item_f stands for item function, see below
  return function(proj)
    proj = proj or 0
    local i = 0
    local n = count_f(proj)
    return function ()
      if i < n then
        local item = item_f(proj, i)
        i = i + 1
        return item
      end
    end
  end
end
ReaIter.each_media_item = ReaIter._make_iterator(reaper.CountMediaItems, reaper.GetMediaItem)
ReaIter.each_take = ReaIter._make_iterator(reaper.CountTakes, reaper.GetTake)
ReaIter.each_track = ReaIter._make_iterator(reaper.CountTracks, reaper.GetTrack)
-- etc.
--[[ USE
-- https://github.com/TeamAudio/reaspeech/blob/main/reascripts/ReaSpeech/source/TranscriptAnnotations.lua
for item in ReaIter.each_media_item() do
	for take in ReaIter.each_take(item) do
	end
end
https://github.com/TeamAudio/reaspeech/blob/main/reascripts/ReaSpeech/source/ASRActions.lua
for track in ReaIter.each_selected_track() do
	for item in ReaIter.each_track_item(track) do
		for take in ReaIter.each_take(item) do
		end
	end
end
]]


--================================ C L O S U R E S  E N D ==============================


--======================= M A R K E R S  &  R E G I O N S ==========================


--local retval, isrgn, pos, rgnend, name, markID, color = r.EnumProjectMarkers3(0, i)
function is_region_within_time_sel(start, fin, pos, rgnend)
-- start/fin are of time sel, pos/rgnend are of the region
local start, fin = r.GetSet_LoopTimeRange(false, false, 0, 0, false) -- isSet, isLoop  false; start, end - 0, allowautoseek false
local time_sel = start ~= fin
	if time_sel then
	return pos >= start and pos <= fin or rgnend >= start and rgnend <= fin
	end
end



function get_region_at_edit_or_mouse_cursor()

	local function get_region(cur_pos)
	--[[
	local _, regionidx = r.GetLastMarkerAndCurRegion(0, cur_pos) -- DOESN'T RETURN REGION INDEX IF THE EDIT CURSOR IS ALIGNED WITH ITS END, seems like a bug https://forums.cockos.com/showthread.php?t=271806; returns -1 if not preceded by any marker/region contrary to the API doc according to which the return value may be NULL
		if regionidx > -1 then
		local retval, isrgn, pos, rgnend, name, idx, color = r.EnumProjectMarkers3(0, regionidx) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
Msg(name, 'name')
		return {name=name:match('%s*(.+[%w%p]+)') or name, color=color, pos=pos, rgnend=rgnend} -- trimming leading and trailing spaces from the name
		end
	]]
	--[-[-- same as 'if regionidx > -1' statement, would be if it wasn't for the GetLastMarkerAndCurRegion() bug
	local i = 0
		repeat
		local retval, isrgn, pos, rgnend, name, idx, color = r.EnumProjectMarkers3(0, i) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if isrgn and cur_pos >= pos and cur_pos <= rgnend then
			-- DO STUFF --
			return idx end
		i = i+1
		until retval == 0 -- until no more markers/regions
	--]]
	end

local cur_pos_init = r.GetCursorPosition()

local idx = get_region(cur_pos_init)

	if not idx then -- edit cursor isn't at a region
	r.PreventUIRefresh(1)
	ACT(40514) -- View: Move edit cursor to mouse cursor (no snapping)
	local cur_pos = r.GetCursorPosition()
	local return_val = get_region(cur_pos)
	r.SetEditCurPos(cur_pos_init, false, false) -- moveview, seekplay false // restore orig edit curs pos
	r.PreventUIRefresh(-1)
	end

end



function GetRegionAtCursor()
local cur_pos = r.GetCursorPosition()
local _, regionidx = r.GetLastMarkerAndCurRegion(0, cur_pos) -- returns -1 if not preceded by any marker/region contrary to the API doc according to which the return value may be NULL
	if regionidx == -1 then
	_, regionidx = r.GetLastMarkerAndCurRegion(0, cur_pos-.1^10) -- an attempt to overcome the bug https://forums.cockos.com/showthread.php?t=271806 where the region end isn't recognized by the function as part of the region
	return retval, isrgn, pos, rgnend, name, idx, color = r.EnumProjectMarkers3(0, regionidx) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
	end
end



function Get_Marker_Reg_At_Mouse_Or_EditCursor() -- see a more efficient Get_Marker_Reg_At_Time_OR_Mouse_Or_EditCursor() below

	local function get_mrkr_reg(cur_pos)
	local i = 0
		repeat
		local retval, isrgn, pos, rgnend, name, ID, color = r.EnumProjectMarkers3(0, i) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if retval > 0 and (pos == cur_pos or isrgn and rgnend == cur_pos) then
			return color, {idx=i, isrgn=isrgn, pos=pos, rgnend=rgnend, name=name, ID=ID, col=color}
			end
		i = i+1
		until retval == 0 -- until no more markers/regions
	end

local cur_pos = r.GetCursorPosition()
local color, mrkr_reg_props_t = get_mrkr_reg(cur_pos) -- at the edit cursor // see a more efficient Get_Marker_Region_At_Time() below

	-- color condition is script specific
	if not color and r.GetTrackFromPoint(r.GetMousePosition()) then -- the edit cursor is not aligned with marker or region start/end // look for these at the mouse cursor // GetTrackFromPoint() prevents this context from activation if the script is run from a toolbar or the Action list window floating over Arrange or if mouse cursor is outside of Arrange
	r.PreventUIRefresh(1)
	ACT(40513) -- View: Move edit cursor to mouse cursor [with snapping so it can snap to marker / region start/end]
	local new_cur_pos = r.GetCursorPosition()
	color, mrkr_reg_props_t = get_mrkr_reg(new_cur_pos)
	r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false // restore orig edit curs pos
	r.PreventUIRefresh(-1)
	end

return color, mrkr_reg_props_t

--[[ Script specific
	if color then
	local key = not mrkr_reg_props_t.isrgn and 'marker' or 'region'
	color = color == 0 and r.GetThemeColor(key, 0) -- get default theme color, determined by the settings in the 'Theme development/tweaker' dialogue (NOT in the .ReaperTheme file) ignoring settings in the 'Theme Color Control' dialogue (https://forum.cockos.com/showthread.php?t=291551): Markers, Regions
	or color -- either default theme color or custom
	local rgb = {r.ColorFromNative(color)}
	local hex_color = rgb2hex(table.unpack(rgb))
	return hex_color, rgb, color|0x1000000, mrkr_reg_props_t
	end
]]

end




function Get_Marker_Reg_At_Time_OR_Mouse_Or_EditCursor(time, want_mouse, want_next_prev_reg)
-- can be used to get marker/region at time or edit/mouse cursor
-- if time is false/nil
-- without the need to traverse all of them
-- if want_mouse is true, relies on Get_TCP_MCP_Under_Mouse()
-- if want_next_prev_reg is integer 1 next, -1 prev
-- to return either next or previous region, if any,
-- when there's no region at time/cursor

	local function get_next_prev_region(cur_pos, want_next_prev_reg)
	local i, proj_len = 0, r.GetProjectLength(0)
		repeat
		local nxt = want_next_prev_reg > 0
		local incr = nxt and 0.1 or -0.1
		cur_pos = cur_pos+incr -- increment by 100 ms until a region is found
		local mrkr_idx, reg_idx = r.GetLastMarkerAndCurRegion(0, cur_pos)
			if reg_idx > -1 then return reg_idx end
		i=i+1
		until reg_idx > -1 or nxt and cur_pos >= proj_len
		or not nxt and cur_pos <= 0 -- if not found stop at the end/start of the project depending on direction
	end

local tr, info = r.GetTrackFromPoint(r.GetMousePosition())
-- ensuring that mouse cursor is over Arrange allows ignoring mouse position
-- when the script is run via toolbar button, menu item or from the Action list

local cur_pos = time or r.GetCursorPosition() -- store in case want_mouse is true

	if not time want_mouse and tr and not Get_TCP_MCP_Under_Mouse() and info ~= 2 then -- not FX window
	r.PreventUIRefresh(1)
	r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping) // more sensitive than with snapping
	end

local mrkr_idx, rgn_idx = r.GetLastMarkerAndCurRegion(0, cur_pos)
local t = {}
t.mrkr = mrkr_idx > -1 and {r.EnumProjectMarkers3(0,mrkr_idx)}
t.rgn = rgn_idx > -1 and {r.EnumProjectMarkers3(0,rgn_idx)}

	if not t.rgn and want_next_prev_reg then -- the cursor/time is outside a region or coincide with its end because EnumProjectMarkers() ignores region end
	-- marker invalid idx -1 is only possible when the cursor/time precedes the very first project marker, provided there're any
	-- so no function is needed to find the next valid marker because this will be the very 1st one in the project
	rgn_idx = get_next_prev_region(cur_pos, want_next_prev_reg)
	t.rgn = rgn_idx and {r.EnumProjectMarkers3(0,rgn_idx)}
	end

	if t.mrkr then table.insert(t.mrkr,1,t.mrkr[3] == cur_pos) end
	if t.rgn then table.insert(t.rgn,1,t.rgn[3] == cur_pos) end
-- fields:
-- 1 - true if marker or region start are exactly at the cur_pos, false if last marker before cur_pos
-- or region start before cur_pos
-- 2 - sequential index on the cur_pos line, same as mrkr_idx and rgn_idx
-- 3 - isrgn, 4 - position, 5 - rgn_end, 6 - name, 7 - displayed index, 8 - color
-- nil t.mrkr or t.rgn table - no marker or region respectively before or at the cur_pos

	if not time want_mouse and r.GetCursorPosition() ~= cur_pos then -- restore
	r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false // restore orig. edit curs pos
	r.PreventUIRefresh(-1)
	end

return t

end




function Get_Marker_Region_At_Time(time)
-- can be used to get marker/region at edit cursor
-- if r.GetCursorPosition() is passed as time argument
-- without the need to traverse all of them
local mrkr_idx, rgn_idx = r.GetLastMarkerAndCurRegion(0, time)
local t = {}
t.mrkr = mrkr_idx > -1 and {r.EnumProjectMarkers3(0,mrkr_idx)}
t.rgn = rgn_idx > -1 and {r.EnumProjectMarkers3(0,rgn_idx)}
	if t.mrkr then table.insert(t.mrkr,1,t.mrkr[3] == time) end
	if t.rgn then table.insert(t.rgn,1,t.rgn[3] == time) end
-- fields:
-- 1 - true if marker or region start are exactly at the time, false if last marker before time
-- or region start before time
-- 2 - sequential index on the time line, same as mrkr_idx and rgn_idx
-- 3 - isrgn, 4 - position, 5 - rgn_end, 6 - name, 7 - displayed index, 8 - color
-- nil t.mrkr or t.rgn table - no marker or region respectively before or at the time
return t
end



function Delete_Marker_Region_At_Time(time, want_region)
-- want_region is boolean
-- region is deleted if time matches its start
	if time then
	local mrkr_idx, rgn_idx = r.GetLastMarkerAndCurRegion(0, pos)
	local idx = want_region and rgn_idx or mrkr_idx
		if want_region and rgn_idx > -1 or mrkr_idx > -1
		and ({r.EnumProjectMarkers3(0, idx)})[3] == pos then
		r.DeleteProjectMarkerByIndex(0, idx)
		-- OR
		-- local t = {r.EnumProjectMarkers3(0, idx)}
		-- r.DeleteProjectMarker(0, t[6], want_region)
		end
	end
end



function Get_Marker_Reg_In_Time_Sel(mrkrs, rgns)
-- both args are booleans
local t, i = {}, 0
local start, fin = r.GetSet_LoopTimeRange(false, false, 0, 0, false) -- isSet, isLoop, allowautoseek false

	if start == fin then return end -- no time selection

	repeat
	local retval, isrgn, pos, rgnend, name, ID, color = r.EnumProjectMarkers3(0, i) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
		if rgns and isrgn
		and (pos >= start and pos <= fin or rgnend >= start and rgnend <= fin -- region start or end is within time sel
		or pos >= start and rgnend <= fin) -- whole region is within time sel
		or not isrgn and mrkrs and pos >= start and pos <= fin
		then
		t[#t+1] = {idx=i, isrgn=isrgn, pos=pos, rgnend=rgnend, name=name, ID=ID, col=color}
		end
	i = i+1
	until retval == 0 -- until no more markers/regions

	if #t > 0 then return t end

end



function Delete_All_Proj_Markers()

local retval, mrkr_cnt = r.CountProjectMarkers(0)

local i = mrkr_cnt-1
	repeat
	local retval, isrgn, pos, rgnend, name, markr_idx = r.EnumProjectMarkers(i)
		if retval > 0 and not isrgn then
		r.DeleteProjectMarkerByIndex(0, i)
		end
	i = i-1
	until retval == 0

--r.UpdateArrange()
--r.UpdateTimeline()

end



-- ONLY MARKERS
local function Store_Delete_Restore_Proj_Markers(t)	-- the function is to be used twice, first to store markers then to restore them; t is marker table created with this function which is fed at the restration stage
	if not t then -- store and delete
	---------------------------METHOD 1: Store and delete markers within one loop in descending order ------------------------
	local retval, num_markers, num_regions = r.CountProjectMarkers(0)
	local i = num_markers + num_regions-1 -- -1 isn't necessary, if there's no marker with the initial index no error occurs, just one extra loop cycle
	local markers_t = {}
	repeat -- store and delete in decscending order
		local retval, is_rgn, pos, rgn_end, name, mrk_idx, color = r.EnumProjectMarkers3(0, i) -- mrk_id is the actual marker ID displayed in Arrange which may differ from retval // markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if not is_rgn then -- only consider markers
			markers_t[#markers_t+1] = {mrk_idx, pos, name, color}
			end
		r.DeleteProjectMarker(0, mrk_idx, false) -- isrgn is false
		i = i - 1
		until i == -1 -- OR retval == 1 and not is_rgn -- until the iterator is less than the 1st marker index or until the 1st marker
--[[---------------------------METHOD 2: Store and delete markers within one loop in ascending order --------------------
	local i = 0
	local markers_t = {}
	repeat -- store and delete in acscending order
		local retval, is_rgn, pos, rgn_end, name, mrk_idx, color = r.EnumProjectMarkers3(0,i) -- mrk_id is the actual marker ID displayed in Arrange which may differ from retval // markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if retval > 0 and not is_rgn then -- only consider markers
			markers_t[#markers_t+1] = {mrk_idx, pos, name, color}
			r.DeleteProjectMarker(0, mrk_idx, false) -- isrgn is false; can be put outside of the block since only markers are targeted
			i = i - 1 -- compensate i count after each deletion so it keeps matching the indices of the remaining markers
			end
		i = i + 1
		until retval == 0
---------------------METHOD 3: First store markers then delete in a separate loop -----------------
	local i = 0
	local markers_t = {}
		repeat -- store markers
		local retval, is_rgn, pos, rgn_end, name, mrk_idx, color = r.EnumProjectMarkers3(0, i) -- mrk_id is the actual marker ID displayed in Arrange which may differ from retval // markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if retval > 0 and not is_rgn then -- only consider markers
			markers_t[#markers_t+1] = {mrk_idx, pos, name, color}
			end
		i = i + 1
		until retval == 0 -- until no more markers/regions
		for _, v in ipairs(markers_t) do -- delete in a separate loop
		r.DeleteProjectMarker(0, v[1], false) -- isrgn is false; v[1] is mrk_idx, the actual marker ID displayed in Arrange
		end
		]]
	return markers_t
	else -- restore
		for _,v in ipairs(t) do
		local mrk_idx, pos, name, color = table.unpack(v) -- extra step for clarity
		r.AddProjectMarker2(0, false, pos, 0, name, mrk_idx, color) -- isrgn is false
		end
	end
end


-- MARKERS AND REGIONS
local function Store_Delete_Restore_Proj_Mark_Regions(t) -- the function is to be used twice, first to store markers/regions then to restore them; t is marker/region table created with this function which is fed at the restration stage
	if not t then -- store and delete
	---------------------------METHOD 1: Store and delete markers/regions within one loop in descending order ------------------------
	local retval, num_markers, num_regions = r.CountProjectMarkers(0)
	local i = num_markers + num_regions-1 -- -1 isn't necessary, if there's no marker with the initial index no error occurs, just one extra loop cycle
	local mark_reg_t = {}
	repeat -- store and delete in decscending order
		local retval, is_rgn, pos, rgn_end, name, mrk_idx, color = r.EnumProjectMarkers3(0, i) -- mrk_idx is the actual marker ID displayed in Arrange which may differ from retval // markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if retval > 0 then
			local rgn_end = is_rgn and rgn_end
			mark_reg_t[#mark_reg_t+1] = {mrk_idx, pos, rgn_end, name, color}
			end
		-- the cond is needed to avoid deleting objects (markers/regions) with the same index ahead of time
		local del = not is_rgn and r.DeleteProjectMarker(0, mrk_idx, false) -- isrgn is false, markers only
		local del = is_rgn and r.DeleteProjectMarker(0, mrk_idx, true) -- isrgn is true, regions only
		i = i - 1
		until i == -1 or retval == 0 -- OR retval == 1 or retval == 0 -- until the iterator is less than the 1st marker/region index or until the 1st marker/region or until retval == 0 if no markers/regions
--[[---------------------------METHOD 2: Store and delete markers/regions within one loop in ascending order --------------------
	local i = 0
	local  mark_reg_t = {}
	repeat -- store and delete in acscending order
		local retval, is_rgn, pos, rgn_end, name, mrk_idx, color = r.EnumProjectMarkers3(0,i) -- mrk_id is the actual marker ID displayed in Arrange which may differ from retval // markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if retval > 0 then
			local rgn_end = is_rgn and rgn_end
			mark_reg_t[#mark_reg_t+1] = {mrk_idx, pos, rgn_end, name, color}
			-- the cond is needed to avoid deleting objects (markers/regions) with the same index ahead of time
			local del = not is_rgn and r.DeleteProjectMarker(0, mrk_idx, false) -- isrgn is false, markers only; can be put outside of the block
			local del = is_rgn and r.DeleteProjectMarker(0, mrk_idx, true) -- isrgn is true, regions only
			i = i - 1 -- compensate i count after each deletion so it keeps matching the indices of the remaining markers/regions
			end
		i = i + 1
		until retval == 0
---------------------METHOD 3: First store markers/regions then delete in a separate loop -----------------
	local i = 0
	local mark_reg_t = {}
		repeat
		local retval, is_rgn, pos, rgn_end, name, mrk_idx, color = r.EnumProjectMarkers3(0, i) -- mrk_id is the actual marker ID displayed in Arrange which may differ from retval // markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
			if retval > 0 then
			local rgn_end = is_rgn and rgn_end
			mark_reg_t[#mark_reg_t+1] = {mrk_idx, pos, rgn_end, name, color}
			end
		i = i + 1
		until retval == 0 -- until no more markers/regions
		for _, v in ipairs(mark_reg_t) do -- delete in a separate loop since doing it in descending or ascending order in the loop above is pretty complicated due to regions interference with the count
		local del = not v[3] and r.DeleteProjectMarker(0, v[1], false) -- isrgn is false, markers only; v[3] is region end, v[1] is mrk_idx, the actual marker ID displayed in Arrange
		local del = v[3] and r.DeleteProjectMarker(0, v[1], true) -- isrgn is true, regions only
		end
		]]
	return mark_reg_t
	else -- restore
		for _,v in ipairs(t) do
		local mrk_idx, pos, rgn_end, name, color = table.unpack(v) -- extra step for clarity
		-- the cond is needed to avoid inserting markers with region start point and regions with the end point being nil which will throw an error
		local marker = not rgn_end and r.AddProjectMarker2(0, false, pos, 0, name, mrk_idx, color) -- isrgn is false, markers only
		local region = rgn_end and r.AddProjectMarker2(0, true, pos, rgn_end, name, mrk_idx, color) -- isrgn is true, regions only
		end
	end
end



function lexaproductions_Region_IsSelected(idx)
-- https://forum.cockos.com/showthread.php?t=255987#9
local title = r.JS_Localize('Region/Marker Manager', 'common')
local hwnd = r.JS_Window_Find(title, true)
local isOpened = hwnd
	if not hwnd then -- Open Region Manager window if not found,
		r.Main_OnCommand(40326) -- View: Show region/marker manager window
		hwnd = r.JS_Window_Find(title, true)
		if not hwnd then return end
	end
r.DockWindowActivate(hwnd) -- OPTIONAL: Select/show manager if docked
r.JS_Window_SetForeground(hwnd)-- Set focus on Manager window
local lv = reaper.JS_Window_FindChildByID(hwnd, 1071)
	if not isOpened then r.Main_OnCommand(40326) end -- View: Show region/marker manager window
return reaper.JS_ListView_GetItemState(lv, idx-1) > 0
end


-- see also Get_Marker_Region_At_Time() above
function Get_First_MarkerOrRgn_After_Time(time, USE_REGIONS, KEYWORD) -- accounting for all overlaps
-- time in sec
-- USE_REGIONS is boolean
-- KEYWORD is a word included in the merker/region name
local i, mrkr_idx, rgn_idx = 0, -1, -1 -- -1 to count as 0-based
local ret_idx, ret_pos, ret_name, ret_rgn_end--, ref_time
	repeat
	local retval, isrgn, pos, rgn_end, name, idx, color = r.EnumProjectMarkers3(0, i) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
	mrkr_idx = retval > 0 and not isrgn and mrkr_idx+1 or mrkr_idx -- this counting method is used to conform with the type of index expected by the GoToMarker() function
	rgn_idx = retval > 0 and isrgn and rgn_idx+1 or rgn_idx -- relic of the prev version because GoToRegion() was discarded
		if retval > 0 then
			if not USE_REGIONS and not isrgn then
				if not ret_pos and pos > time or ret_pos and pos == ret_pos then -- find 1st then look for overlaps
				ret_idx = mrkr_idx; ret_pos = pos; ret_name = name
				end
			elseif USE_REGIONS and isrgn then
				if not ret_pos and pos > time or ret_pos and pos == ret_pos and rgn_end >= ret_rgn_end then -- find 1st then look for overlaps // automatically respects the longest region
				ret_idx = rgn_idx; ret_pos = pos; ret_name = name; ret_rgn_end = rgn_end
				end
			end
		end
	i = i+1
	until retval == 0 -- until no more markers/regions

	if ret_name and ret_name:lower():match(Esc(KEYWORD)) then -- no overlaps or overlaps, the last of which contains the KEYWORD
	return ret_idx, ret_pos, ret_name, ret_rgn_end
	elseif ret_name then -- no overlaps and no KEYRORD or overlaps, the last of which doesn't contain the KEYWORD, search for next which does
	local ret_idx, ret_pos, ret_name, ret_rgn_end = Get_First_MarkerOrRgn_After_Time(ret_pos, USE_REGIONS, KEYWORD)
	return ret_idx, ret_pos, ret_name, ret_rgn_end
	end

end


function Find_Next_MrkrOrRgn_By_Name(ref_idx, ref_pos, USE_REGIONS, KEYWORD) -- or by the lack of elements in the name; ref_idx is 0-based // accounting for all overlaps

-- when markers are ovelapping and their lanes are collapsed, the displayed index
-- is that of the marker with the lowest index among the overlaping ones,
-- while the name is that of the marker with the highest index,
-- with overlapping regions the name and the index of the region with the greater index
-- covers the name and the index of the region with the smaller index,
-- since in this script the name defines the marker role we need to make sure that
-- the marker with the KEYWORD isn't overlapped by a marker with a greater index without the KEYWORD
-- because in this case the KEYWORD won't be visible and the marker must be treated as a regular one,
-- and that on the other hand a marker without the KEYWORD (the one to jump to) is not overlapped
-- by a marker with a greater index with the KEYWORD, because in this case the KEYWORD will be visible
-- and the marker will have to be treated as the skip trigger

	if not ref_idx then return end
local i, mrkr_idx, rgn_idx = 0, -1, -1 -- -1 to count as 0-based
local ret_idx, ret_pos, ret_name, ret_rgn_end
	repeat
	local retval, isrgn, pos, rgn_end, name, idx, color = r.EnumProjectMarkers3(0, i) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
	mrkr_idx = retval > 0 and not isrgn and mrkr_idx+1 or mrkr_idx -- this counting method is used to conform with the type of index expected by the GoToMarker() function
	rgn_idx = retval > 0 and isrgn and rgn_idx+1 or rgn_idx -- relic of the prev version because GoToRegion() was discarded
		if retval > 0 then
			if not USE_REGIONS and not isrgn then
				if not ret_pos and pos > ref_pos or ret_pos and pos == ret_pos then -- find 1st then look for overlaps
				ret_idx = mrkr_idx; ret_name = name; ret_pos = pos
				end
			elseif USE_REGIONS and isrgn then -- only search for continguous regions, for regions ref_pos is region end
				--[[ WORKS, doesn't respect the longest region
				if pos <= ref_pos and (ret_rgn_end and rgn_end >= ret_rgn_end or rgn_end > ref_pos) then -- find 1st then look for overlaps
				ret_idx = rgn_idx; ret_name = name; ret_rgn_end = rgn_end
				end
				]]
				if pos <= ref_pos and rgn_end > ref_pos then
					if not ret_rgn_end or ret_rgn_end and rgn_end >= ret_rgn_end then -- -- find 1st then look for overlaps respecting the longest region
					ret_idx = rgn_idx; ret_name = name; ret_rgn_end = rgn_end;
					end
				end

			end
		end
	i = i+1
	until retval == 0 -- until no more markers/regions

	if not USE_REGIONS and ret_name then
		if not ret_name:lower():match(Esc(KEYWORD)) then -- no overlaps and no KEYWORD or overlaps, the last of which doesn't contain the KEYWORD, return because this one must be skipped to
		return ret_idx, ret_pos
		else -- no overlaps and KEYWORD or overlaps, the last of which contains the KEYWORD, search for the next until the one without the KEYWORD is found, because this one must be skipped over
		local ret_idx, ret_pos = Find_Next_MrkrOrRgn_By_Name(ret_idx, ret_pos, USE_REGIONS, KEYWORD)
		return ret_idx, ret_pos
		end
	elseif USE_REGIONS then
		if ret_name and ret_name:lower():match(Esc(KEYWORD)) then -- no overlaps and KEYWORD or overlaps, the last of which contains the KEYWORD, so is contigous, search for the next until a non-contiguous is found
		local ret_idx, ret_rgn_end = Find_Next_MrkrOrRgn_By_Name(ret_idx, ret_rgn_end, USE_REGIONS, KEYWORD)
		return ret_idx, ret_rgn_end
		else -- no overlaps and no KEYWORD or overlaps, the last of which doesn't contain the KEYWORD, return the same data which was fed in, because this region must not be skipped
		return ref_idx, ref_pos
		end
	end

end



function Monitor_MrkrsOrRgns(USE_REGIONS, ref_t)
local i, mrkr_idx, rgn_idx = 0, -1, -1 -- -1 to count as 0-based
	if not ref_t then
	local ref_t = {markrs={}, regns={}}
		repeat -- store markers and regions time properties
		local retval, isrgn, pos, rgn_end, name, idx, color = r.EnumProjectMarkers3(0, i) -- markers/regions are returned in the timeline order, if they fully overlap they're returned in the order of their displayed indices
		mrkr_idx = retval > 0 and not isrgn and mrkr_idx+1 or mrkr_idx -- this counting method is used to conform with the type of index expected by the GoToMarker() function
		rgn_idx = retval > 0 and isrgn and rgn_idx+1 or rgn_idx -- relic of the prev version because GoToRegion() was discarded
			if retval > 0 and not isrgn then
			ref_t.markrs[mrkr_idx] = ref_t.markrs[mrkr_idx] or {}
			ref_t.markrs[mrkr_idx].pos = pos; ref_t.markrs[mrkr_idx].name = name:lower():match(Esc(KEYWORD))
			elseif retval > 0 and isrgn then
			ref_t.regns[rgn_idx] = ref_t.regns[rgn_idx] or {}
			ref_t.regns[rgn_idx].pos = pos
			ref_t.regns[rgn_idx].rgn_end = rgn_end
			ref_t.regns[rgn_idx].name = name:lower():match(Esc(KEYWORD))
			end
		i = i+1
		until retval == 0
	return ref_t
	else
	repeat -- search for changes in markers and regions time properties
	local retval, isrgn, pos, rgn_end, name, idx, color = r.EnumProjectMarkers3(0, i)
	mrkr_idx = retval > 0 and not isrgn and mrkr_idx+1 or mrkr_idx -- this counting method is used to conform with the type of index expected by the GoToMarker() function
	rgn_idx = retval > 0 and isrgn and rgn_idx+1 or rgn_idx -- relic of the prev version because GoToRegion() was discarded
		if not USE_REGIONS and retval > 0 and not isrgn and ref_t.markrs[mrkr_idx] and (pos ~= ref_t.markrs[mrkr_idx].pos or name:lower():match(Esc(KEYWORD)) ~= ref_t.markrs[mrkr_idx].name)
		or USE_REGIONS and retval > 0 and isrgn and ref_t.regns[rgn_idx] and (pos ~= ref_t.regns[rgn_idx].pos or rgn_end ~= ref_t.regns[rgn_idx].rgn_end or name:lower():match(Esc(KEYWORD)) ~= ref_t.regns[rgn_idx].name)
		then
		return true
		end
	i = i+1
	until retval == 0
	end
end


-- USAGE (in defer loop):
-- ref_t = update and Monitor_MrkrsOrRgns(USE_REGIONS) or ref_t -- collect markers and regions time data, only update if there's change, otherwise updates constantly and change isn't
-- if update then --[[ SOME ROUTINE ]] end
-- update = Monitor_MrkrsOrRgns(USE_REGIONS, ref_t) -- search for changes in markers and regions time data; update is used as a condition in getting marker/region properties routine above



function Take_Marker_Exists(take, pos)
--[[ pos must be position within source, calculated as follows:
local item_pos = r.GetMediaItemInfo_Value(item, 'D_POSITION')
local offset = r.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
local playrate = r.GetMediaItemTakeInfo_Value(take, 'D_PLAYRATE')
local pos = (cur_pos - item_pos + offset)*playrate
]]
local i = 0
	repeat
	local src_pos, name, color = r.GetTakeMarker(take, i)
		if src_pos == pos then return true end
	i = i+1
	until src_pos == -1
end


-- to be used with SetProjectMarker3, SetProjectMarker4,
-- SetProjectMarkerByIndex, SetProjectMarkerByIndex2
-- to reset to default color, because unlike with tracks/items/takes
-- setting with color 0 simply keeps the current color
function Get_Mrkr_Region_Default_Color(want_region)
-- want_region is boolean
local key = want_region and 'region' or 'marker'
return r.GetThemeColor(key, 0) -- flag 0 theme default color determined by the settings in the 'Theme development/tweaker' dialogue (NOT in the .ReaperTheme file) ignoring settings in the 'Theme Color Control' dialogue (https://forum.cockos.com/showthread.php?t=291551)
end

-- same as above for take markers
function Get_Take_Mrkr_Default_Color()
local key = want_region and 'region' or 'marker'
return r.GetThemeColor('take_marker', 0) -- flag 0 theme default color determined by the settings in the 'Theme development/tweaker' dialogue (NOT in the .ReaperTheme file) ignoring settings in the 'Theme Color Control' dialogue (https://forum.cockos.com/showthread.php?t=291551)
end



function Get_Action_Marker_Data(cmd_ID)
-- cmd_ID is integer, stems from get_action_context()
-- looks for program/preset index or name in the action marker name

local play_state = r.GetPlayState()
	if r.GetToggleCommandStateEx(0, r.NamedCommandLookup('_SWSMA_TOGGLE')) == 1 -- SWS: Toggle marker actions enable
	and (play_state & 1 == 1 -- playing
	or play_state & 4 == 4) -- recording
	then
	local cmd_ID = r.ReverseNamedCommandLookup(cmd_ID)
	local play_pos = r.GetPlayPosition()
	local mrk_idx, reg_idx = r.GetLastMarkerAndCurRegion(0, play_pos) -- returns -1 if not preceded by any marker/region contrary to the API doc according to which the return value may be NULL
	local retval, isrgn, mrk_pos, rgnend, mrk_name, mrk_num = r.EnumProjectMarkers(mrk_idx)
	local prog = mrk_name:match('!%s*_'..cmd_ID..'.-%s;.-%s(.+)$') -- accounting for mulitple leading empty spaces // the command ID and preset index/name must be separated by semi-colon ; padded with spaces, i.e. 'command_ID ; preset index/name', because action markers allow multiple space separated command IDs and preset index separated by a space only will be treated as another action command ID
	prog = prog:match('.*[%w%p]') -- trimming trailing empty space if any, accounting for a single numeral
	return tonumber(prog) and tonumber(prog) or prog -- either index or name
	end

end


function Get_Last_Proj_Mrkr_Pos()

local i = 0
local last_mrkr_pos
	repeat
	local retval, isrgn, pos, rgnend, name, markr_idx = r.EnumProjectMarkers(i)
		if retval > 0 and not isrgn then
		last_mrkr_pos = pos
		end
	i = i+1
	until retval == 0

return last_mrkr_pos

end



function Fix_Overlapping_Regions(reg_color)
-- if reg_color is valid, only processes regions of certain color

local i, rgn_t = 0, {}
	repeat
	local retval, isrgn, pos, rgnend, name, idx, color = r.EnumProjectMarkers3(0,i)
		if retval > 0 and isrgn
		and (reg_color and color == reg_color or nor reg_color) then
		rgn_t[#rgn_t+1] = {pos=pos,fin=rgnend,name=name,idx=idx,color=color}
		end
	i = i+1
	until retval == 0

local fixed	-- script specific

	for k, rgn in ipairs(rgn_t) do
		if k < #rgn_t and rgn.fin > rgn_t[k+1].pos then
		fixed = 'Transcribing B: Fix overlapping segment regions' -- script specific
		r.SetProjectMarker3(0, rgn.idx, true, rgn.pos, rgn_t[k+1].pos, rgn.name, rgn.color) -- isrgn true
		end
	end

return fixed -- script specific

end



function Get_Mrkrs_Of_Takes_At_Mouse_Or_Edit_Curs()

	local function get_take_mrkrs_at_curs(t, item, take, curs_pos)
		for i=r.GetNumTakeMarkers(take)-1,0,-1 do -- in reverse to catch the first take marker left of mouse cursor if there's none under the mouse
		local pos, name, color = r.GetTakeMarker(take, i)
		local pos_proj = Item_Time_2_Proj_Time(pos, item, take) -- the function only returns value if marker is within visible item area
			if pos_proj and pos_proj <= curs_pos then -- take marker is within visible item area and under or just left of the mouse cursor
			t[item].mrkr_idx, t[item].pos, t[item].name, t[item].col = i, pos, name, color
			break end
		end
	return t
	end

local x, y = r.GetMousePosition()
local item, take = r.GetItemFromPoint(x, y, false) -- 0 allow_locked false
local curs_pos_init = r.GetCursorPosition()
local GET = r.GetMediaItemInfo_Value

local t = {}
	if take then -- if take under mouse, track from point prevents getting
		if GET(item, 'C_LOCK')&1 == 1 then
		Error_Tooltip('\n\n the item is locked \n\n', 1, 1) -- caps, spaced true
		return end
	-- get mouse position
	r.PreventUIRefresh(1)
	r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping)
	local curs_pos = r.GetCursorPosition()
	r.SetEditCurPos(curs_pos_init, false, false) -- moveview, seekplay false // restore
	r.PreventUIRefresh(-1)
	local take_idx = r.GetMediaItemTakeInfo_Value(take, 'IP_TAKENUMBER')
	t[item] = {idx=take_idx} -- if no markers in the take or no left of cursor one will be inserted; item pointer and take index are stored to be able to get take with GetTake(item, t.idx)
	t = get_take_mrkrs_at_curs(t, item, take, curs_pos)
	curs_pos_init = curs_pos -- assign mouse position to the var so that's what's returned at the end of the function
	else -- scan items under the edit cursor
	-- REAPER devs don't recommend using CountSelectedMediaItems()
	-- and GetSelectedMediaItem in favor of CountMediaItems()
	-- and IsMediaItemSelected() instead
	-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
		for i=0, r.CountMediaItems(0)-1 do
		local item = r.GetMediaItem(0,i)
			if GET(item, 'C_LOCK')&1 ~= 1 then -- not locked
			local item_st = GET(item, 'D_POSITION')
			local item_end = item_st + GET(item, 'D_LENGTH')
				if r.IsMediaItemSelected(item) and curs_pos_init > item_st and curs_pos_init <= item_end then -- item under edit cursor
				local take = r.GetActiveTake(item)
					if take then -- only respecting active take in each item and ignoring empty items which don't have takes
					local take_idx = r.GetMediaItemTakeInfo_Value(take, 'IP_TAKENUMBER')
					t[item] = {idx=take_idx} -- if no markers in the take or no left of cursor one will be inserted; item pointer and take index are stored to be able to get take with GetTake(item, t.idx)
					t = get_take_mrkrs_at_curs(t, item, take, curs_pos_init)
					end
				end
			end
		end
	end

return t, curs_pos_init

end


function Get_Selected_And_Hidden_Markers_And_Regions()
-- thanks to X-Raym for the hint on where to search for selected marker/region data
-- https://forums.cockos.com/showthread.php?t=261777

--[[
-- first field is marker index which is the displayed index, not ordinal number on the time line
-- but the lines order follows time line order
-- marker GUIDs were presumably added in 6.02 along with support
-- of MARKER_GUID:X  for GetSetProjectInfo_String()
-- field 5 is color
MARKER 1 3.5 "" 8 0 1 R {98544FCA-A197-43C5-A951-849E05FA9E65} 0 -- 8 marker selected
MARKER 2 4.5 "" 0 0 1 R {D2E332B1-B975-43E2-BF9D-352A83D87CCA} 0 -- 0 marker not selected // 24 marker hidden, since 7.36
MARKER 1 5.5 "" 9 0 1 R {A7F21A53-1F31-4AF9-B2CA-5246CB22E13A} 0 -- 9 region selected
MARKER 1 6.5 "" 9
MARKER 2 7.5 "" 1 0 1 R {42CDA6EC-9BD1-4B20-A87C-64986B6FD1E8} 0 -- 1 region not selected // 25 region hidden, since 7.36
MARKER 2 8.5 "" 1
]]

local err = r.CountProjectMarkers(0) == 0 and 'no markers/regions in the project'
or tonumber(r.GetAppVersion():match('[%d%.]+')) < 6.53 and 'requires REAPER build 6.53 and lated'-- build since which Main_SaveProjectEx() is supported

	if err then	return err end 

local cur_proj, proj_path = r.EnumProjects(-1) -- returns path even if the project file was deleted while the project is open

-- if, while the tab is open, proj file associated with the open tab was deleted along with the media folder, REAPER will automatically re-create it in the original directory of the project file when any action is performed provided such original directory still exists and a media folder is configured in the project settings or Preferences -> General -> Paths, so if this is gonna be the scenario, prevent that

local proj_path, proj_name = table.unpack(r.file_exists(proj_path) and proj_path:match('(.+[\\/])(.+)%.[RrPp]') or {}) -- extract path and name sans extension, if project without project file the result will be nils

	if not proj_path then -- project tab without project file or deleted proj file
	-- use script path for temp project file
	local info = debug.getinfo(1,'S');
	proj_path = info.source:match('@(.+[\\/])')
	end

local temp_proj_file = proj_path..(r.time_precise()..''):gsub('%.','')..'.RPP' -- making the name unique to reduce likelihood of clash
r.Main_SaveProjectEx(0, temp_proj_file, 0) -- works with non-saved projects as well

	if r.file_exists(temp_proj_file) then
	local t = {sel={},hid={}}
	local count = -1
		for line in io.lines(temp_proj_file) do
			if line:match('^%s*MARKER ') then
			count = count+1
			local matching = line:match(' %d+ [%.%d]+ ["\']*.+["\']* ([24589]+)') -- 8/0 marker selected/not selected, 9/1 region selected/not selected; 24/25 marker/region hidden, supported since 7.36; selection and visibility are mutually dxclusive, a hidden marker/region cannot be selected in Arrange, their entry selection in the Region/Marker Manager doesn't affect that; if the name doesn't contain spaces it's not enclosed within quotes unless it contains double quote character in which case the entire name is enclosed within single quotes/apostrohe rather than dounle quotes, i.e. '"TEST"' or 'TEST"'
			local reg_end = not line:match('%d+ [%.%d]+ ["\']*.+["\']* %d+ (%d+)') -- region end line only has 4 fields
				if matching and not reg_end then -- excluding region end lines, the complete data will be collected below
				local t_tmp = #matching == 1 and t.sel or t.hid -- one digit long value refers to selection status, two digit long to visibility
				t_tmp[#t_tmp+1] = count -- count is equal to time line index, 0-based
				end
			elseif count > -1 then break -- marker/region data have been parsed
			end
		end
		
	os.remove(temp_proj_file)
	
		if #t.sel + #t.hid == 0 then return end
		
		local function get_data(t)
			for k, index in ipairs(t) do
			local retval, isrgn, pos, rgnend, name, indexnumber, color = r.EnumProjectMarkers3(0, index)
			t[k] = {idx=index, erg=isrgn,pos=pos,reg_end=rgnend,name=name,index=indexnumber,color=color}
			end
		return t
		end
	
	t.sel, t.hid = get_data(t.sel), get_data(t.hid)
	return t
	
	end

end



--========================== M A R K E R S  &  R E G I O N S  E N D =========================

--=======================================  G F X  ===========================================

function GFX_SETFONT_FLAGS(flags)
-- function to calculate multibyte character for gfx.setfont() flags argument
-- flags is a string consisting of up to 4 characters out of: B/b, I/i, O/o, R/r, S/s, U/u, V/v
-- https://www.cuemath.com/numbers/decimal-to-binary/
-- https://flexiple.com/developers/decimal-to-binary-conversion/
-- https://stackoverflow.com/questions/9079853/lua-print-integer-as-a-binary
-- https://www.geeksforgeeks.org/binary-representation-of-a-given-number/
--[[

https://mespotin.uber.space/Ultraschall/Reaper_Api_Documentation.html#lua_gfx.setfont

flags, how to render the text; up to 4 flags can be passed at the same time
a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold.
These flags may or may not be supported depending on the font and OS.

66 and 98, Bold (B), (b)
73 and 105, italic (I), (i)
79 and 111, white outline (O), (o)
82 and 114, blurred (R), (r)
83 and 115, sharpen (S), (s)
85 and 117, underline (U), (u)
86 and 118, inVerse (V), (v)

To create such a multibyte-character, assume this flag-value as a 32-bit-value.
The first 8 bits are the first flag, the next 8 bits are the second flag,
the next 8 bits are the third flag and the last 8 bits are the fourth flag.
The flagvalue(each dot is a bit): .... ....   .... ....   .... ....   .... ....
If you want to set it to Bold(B) and Italic(I), you use the ASCII-Codes of both(66 and 73 respectively),
take them apart into bits and set them in this 32-bitfield.
The first 8 bits will be set by the bits of ASCII-value 66(B), the second 8 bits will be set by the bits of ASCII-Value 73(I).
The resulting flagvalue is: 0100 0010   1001 0010   0101 0110   0000 0000
which is a binary representation of the integer value 18754, which combines 66 and 73 in it
]]

local flags = type(flags) == 'string' and flags:sub(1,4) -- only keep 1st 4 characters because that much is supported by the function
	if not flags then return end

local char_t = {'b','i','o','r','s','u','v'}
local t = {}
	for flag in flags:gmatch('%a') do
	local flag1 = flag:lower()
		for idx, flag2 in ipairs(char_t) do
			if flag1 == flag2 then
			t[#t+1] = string.byte(flag1) -- collect ASCII codes
			table.remove(char_t,idx) -- remove to ignore duplicates in the user argument in the following cycles
			break end
		end
	end


local integer = 0
	for idx, code in ipairs(t) do
	local code = code << 32 - idx*8 -- each new code bits are shifted left, the number of bits to shift by gets reduced with each new code to keep previously set ones unaffected
	integer = integer|code -- bitwise OR to set bits
	-- 1st flag: 00000000 00000000 00000000 <-[11111111] = 11111111 00000000 00000000 00000000 -- (the actual set bits are of course different)
	-- then adding it to 0, i.e. 00000000 00000000 00000000 00000000 + 11111111 00000000 00000000 00000000 = 11111111 00000000 00000000 00000000
	-- 2nd flag: 00000000 00000000 00000000 <-[11111111] = 00000000 11111111 00000000 00000000
	-- then adding it to the last integer, that is 11111111 00000000 00000000 00000000, i.e.
	-- 11111111 00000000 00000000 00000000 + 00000000 11111111 00000000 00000000 = 11111111 11111111 00000000 00000000
	-- and so on each time shiting left by 8 bits less because previous slots are already taken and must remain intact
	end

return integer

end



function Prevent_Floating_Window_Resize1(w,h) -- auto-restore GUI window dimensions
-- w and h are original GUI window dimensions
	if gfx.w ~= w or gfx.h ~= h then gfx.init('', w, h) end -- the crucial part is the empty window name
-- Thanks to Justin & amagalma
-- https://www.askjf.com/?q=5895s
-- https://forum.cockos.com/showpost.php?p=2493416&postcount=40

-- during resize text may disappear so must be reinstated here
-- not sure what this depends on, probably on the way the text
-- has been drawn
end


function Prevent_Floating_Window_Resize2(w, h, expand, contract) -- auto-restore GUI window dimensions
-- w and h are original GUI window dimensions
-- expand, contract are booleans to prevent either expanding or contracting or both or none
-- doesn't work with docked windows
local condition
	if expand then
	condition = gfx.w > w or gfx.h > h
	elseif contract then
	condition = gfx.w < w or gfx.h < h
	else
	condition = gfx.w ~= w or gfx.h ~= h
	end
	if condition then gfx.init('', w, h) end -- the crucial part is the empty window name
-- Thanks to Justin & amagalma
-- https://www.askjf.com/?q=5895s
-- https://forum.cockos.com/showpost.php?p=2493416&postcount=40

-- during resize text may disappear so must be reinstated here
-- not sure what this depends on, probably on the way the text
-- has been drawn
end


function gfx_drawstring(text, cent_h, cent_v, r_just, bot_just, x_right, y_bot)
-- formatting arguments (cent_h, cent_v, r_just, bot_just) are booleans, can be nil, otherwise they can be combined but not all are compatible with each other, incompatible are:
-- cent_v and bot_just, if both are valid cent_v takes precedence being earlier in the arg sequence
-- cent_h and r_just, if both are valid cent_h takes precedence being earlier in the arg sequence
-- if x_right, y_bot aren't supplied they default to the GUI window dimensions, these are only relevant if at least one formatting arg is supplied
-- 1|256 proper horizontal centering
local cent_h, cent_v, r_just, bot_just =
cent_h and 1 or 0, cent_v and 4 or 0, r_just and 2 or 0, bot_just and 8 or 0 -- value of 256 to ignore right & bottom isn't needed, not supplying either x_right or y_bot or both will make them default to the GUI window dimensions as per the line below which amounts to ignoring any custom values
local x_right, y_bot = x_right or 0+gfx.w, y_bot or 0+gfx.h -- if not supplied the GUI window dimensions are used
gfx.drawstr(text, cent_h|cent_v|r_just|bot_just|256, x_right, y_bot) -- each arg can be used by itself, to combine them bitwise OR is employed to set additional bits, thanks to cfillion's snippet https://forum.cockos.com/showthread.php?t=226916#2
end



function Re_Store_GFX_Wnd_Dock_State(bool) -- run to get without the arg, then pass any valid value directly as the arg to store
	if not bool then
	local ret, dock_state = r.GetProjExtState(0, 'PROPAGATE PARAMETERS', 'dock')
	local dock_state = (ret == 0 or #dock_state == 0) and r.GetExtState('PROPAGATE PARAMETERS', 'dock') or dock_state
	gfx.dock(dock_state,wx,wy,ww,wh)
	else
	local dock_state = gfx.dock(-1,wx,wy,ww,wh) -- query with -1
	r.SetExtState('PROPAGATE PARAMETERS', 'dock', dock_state, false) -- !!!!! persist false, in the final version may true to store in reaper-extstate.ini
	r.SetProjExtState(0, 'PROPAGATE PARAMETERS', 'dock', dock_state)
	end
end

-- EXAMPLE:
-- Get_Store_GFX_Dock_State() -- load
-- RUN ROUTINE
-- Get_Store_GFX_Dock_State(1) -- store
-- terminate the script


function Re_Store_GFX_Wnd_Coordinates(bool) -- run to get without the arg, then pass any valid value directly as the arg to store
	if not bool then
	local ret, wnd_coord = r.GetProjExtState(0, 'PROPAGATE PARAMETERS', 'wnd_coordinates')
	local wnd_coord = (ret == 0 or #wnd_coord == 0) and r.GetExtState('PROPAGATE PARAMETERS', 'wnd_coordinates') or wnd_coord
	return wnd_coord:match('(.+), (.+)') -- x & y to be used in gfx.init()
	else
	local x, y = gfx.clienttoscreen(0,0) -- will only work while the gfx window is open
	r.SetExtState('PROPAGATE PARAMETERS', 'wnd_coordinates', x..', '..y, false) -- !!!!! persist false, in the final version may true to store in reaper-extstate.ini
	r.SetProjExtState(0, 'PROPAGATE PARAMETERS', 'wnd_coordinates', x..', '..y)
	end
end



function close_gfx_wnd_and_store_coordinates(scr_cmdID)
-- when gfx window has been closed by mouse click or with a key press
-- gfx.clienttoscreen(0,0) will only return zeros because there's no window any longer
-- however fetching coordinatess relative to the mouse cursor
-- allows calculating their more or less exact original location on the screen;
-- when closing with the click on the close button located in the upper right hand corner:
-- x = mouse_x-gfx.w+5 (or 10), accounting for gfx window width because the close button
-- is located opposite to the window X coordinate but short of the window's right edge
-- y = mouse_y-10, accounting for mouse location which is below the gfx window y coordinate
-- by about 10 px;
-- otherwise the coordinates need to be updated constantly while the script runs
-- this however isn't suitable for closing with key press because mouse cursor can be anywhere

local click, escape = gfx.getchar() == -1, gfx.getchar() == 27

	if click or escape then -- WITH ESCAPE AND LIKELY ANY KEY PRESS THIS REQUIRES LONG PRESS UNTIL IT'S REGISTERED, HOWEVER IN THE MAIN DEFER FUNCTION OUTSIDE OF THIS FUNCTION gfx.getchar() == 27 CAN BE REGISTERED IMMEDIATELY WITH THE FOLLOWING SYNTAX:
	-- 'if gfx.getchar() == 27 or gfx.getchar() == -1 then'
	-- INSIDE THIS FUNCTION HOWEVER EVEN THIS ORDER OF CONDITIONS DOESN'T PRODUCE IMMEDIATE RESPONSE
	-- the code inside the function doesn't need adjustment, just add the condition outside of it on top
	-- of the condition inside it

	local stored_coord = r.GetExtState(scr_cmdID, 'LAST GFX COORDINATES') -- load coordinates stored last during session
	local x, y = stored_coord:match('(%d+),(%d+)')
	local cur_x, cur_y = table.unpack(click and {r.GetMousePosition()} or escape and {gfx.clienttoscreen(0,0)} or {})
		if not x or cur_x ~= x+0 or cur_y+0 ~= y then
		x, y = table.unpack(click and {cur_x-gfx.w+5, cur_y-10} or escape and {cur_x, cur_y}) -- if click, subtraction of the window width ensures that when re-opened it's situated more or less at the same spot, otherwise the window will be re-opened at the last click coordinate which is the close button X location thus shifting righwards by it's length from the last location // +5 (10 also works) and -10 adjust the coordinates so if the mouse cursor stays put the window will open with the close button presicely under the cursor, because the close button doesn't sit on the window's right edge so gfx.w is greater than cursor's cur_x value at the moment of the click, likewise cursor's cur_y value doesn't match the window y coordinate exactly because the close button sits lower than the window's top edge
		r.SetExtState(scr_cmdID, 'LAST GFX COORDINATES', math.floor(x)..','..math.floor(y), false) -- persist false // truncating the trailing decimal zero from integers
		gfx.quit() -- only needed if quitting at a key press rathen than by a click on the close button, placed here to allow getting coordinates above while the window is open
		end

	return true

	end

end
--[[ USE:
	if gfx.getchar() == 27 or gfx.getchar() == -1 then -- close either with close button click or with Escape key
	close_gfx_wnd_and_store_coordinates(scr_cmdID)
	return end
--]]


function monitor_window_properties()
-- must be run inside the deferred function
-- to store in extended state with atexit()
-- https://forum.cockos.com/showpost.php?p=2652656&postcount=121
local wnd_open = gfx.getchar() > -1
wnd_x, wnd_y = table.unpack(wnd_open and {gfx.clienttoscreen(0,0)} or {wnd_x, wnd_y})
wnd_w, wnd_h, dock = table.unpack(wnd_open and {gfx.w, gfx.h, gfx.dock(-1)} or {wnd_w, wnd_h, dock})
proj = wnd_open and reaper.EnumProjects(-1) or proj
end
--[[ USE:
local wnd_x, wnd_y, wnd_w, wnd_h, dock, proj -- declare outside of the defered function
function run()
monitor_window_properties()
r.defer(run)
end
run()
r.atexit(function() r.SaveExtenedProjState(proj, 'SECTION NAME', 'KEY NAME', wnd_x..';'..wnd_y..';'..wnd_w..';'..wnd_h..';'..dock) end)
]]



function mouse_click_within_gfx_wnd()
gfx.x, gfx.y = 0, 0 -- reset for mouse capture
--local left, bott = gfx.x + gfx.w, gfx.y + gfx.h
return gfx.mouse_cap&1 == 1 and gfx.mouse_x > gfx.x and gfx.mouse_x < gfx.w
and gfx.mouse_y > gfx.y and gfx.mouse_y < gfx.h
end


function restore_gfx_wnd_focus() -- NEW
local wnd_x, wnd_y = gfx.clienttoscreen(0,0)
local w, h, dock = gfx.w, gfx.h, gfx.dock(-1)
	if dock&1 ~= 1 then -- only when undocked, when docked focus loss isn't a problem
	gfx.quit()
	gfx.init("", w, h, 0, wnd_x-4, wnd_y-23) -- 4 and 23 px are width of gfx window right/left/bottom frame and the top bar which aren't accounted for in gfx window coordinates // https://www.askjf.com/?q=5895s https://forum.cockos.com/showpost.php?p=2493416&postcount=40
	end
end



function RandomizeBackgroundColor()
-- Generate random colors
-- https://stash.reaper.fm/v/49308/Randomizer_neu.lua
local r = math.random(0, 255) / 255
local g = math.random(0, 255) / 255
local b = math.random(0, 255) / 255
gfx.set(r, g, b) -- Set background color
gfx.rect(0, 0, gfx.w, gfx.h, 1) -- Draw the colored rectangle
end


-- see also RGB_To_Normalized in the "C O L O R" section


--[[ MANAGING DOCKING cfillion

https://forums.cockos.com/showthread.php?p=2778359#121
OR
-- https://forum.cockos.com/showpost.php?p=2652656&postcount=121

-- Scripts can use gfx.dock or gfx.init to dock their gfx window. The first bit enables docking and the second byte has the docker index (0..15).
-- The position of each of the 16 available dockers is user customizable. There's a DockGetPosition function to read the current position of a given docker.

local function setDock(enable, whichDock)
  gfx.dock((enable and 1 or 0) | (whichDock << 8))
end

local function getDock()
  local dock = gfx.dock(-1)
  return dock & 1 == 1, dock >> 8
end

local function toggleDock()
  -- preserves whichDock
  gfx.dock(gfx.dock(-1) ~ 1)
end

local DOCKER_POS = {
  unknown  = -1,
  bottom   =  0,
  left     =  1,
  top      =  2,
  right    =  3,
  floating =  4,
}
local function findDockerAt(wantPos)
  for i = 0, 15 do
    local pos = reaper.DockGetPosition(i)
    if pos == wantPos then return i end
  end
end

local leftDocker = findDockerAt(DOCKER_POS.left)
if leftDocker then
  setDock(true, leftDocker)
else
  -- ask the user to move a docker to the left
  -- or pick a different docker?
end


]]



--==================================== G F X  E N D ==================================

--==================================== W I N D O W S =================================

--[[
How to get ID for using with JS_Window_FindChildByID on MAC
Hold your mouse over the target window (the child window), and run this script:
w = reaper.JS_Window_FromPoint(reaper.GetMousePosition())
ID = reaper.JS_Window_GetLong(w, "ID")
https://forum.cockos.com/showthread.php?p=2349444#post2349444
]]

function Loka_Window_At_Mouse(w, h) -- Lokasenna // https://forum.cockos.com/showpost.php?p=1689028&postcount=15
-- This will open a window centered on the mouse cursor, adjusted to make sure it's all on the screen and clear of the taskbar
local mouse_x, mouse_y = reaper.GetMousePosition()
local x, y = mouse_x - (w / 2), mouse_y - (h / 2)
local l, t, r, b = x, y, x + w, y + h
local __, __, screen_w, screen_h = reaper.my_getViewport(l, t, r, b, l, t, r, b, 1) -- https://forum.cockos.com/showthread.php?t=195629#4

	if l < 0 then x = 0 end
	if r > screen_w then x = (screen_w - w - 16) end
	if t < 0 then y = 0 end
	if b > screen_h then y = (screen_h - h - 40) end

gfx.init("My window", w, h, 0, x, y)

end


function Loka_Window_At_Center(w, h) -- Lokasenna // https://forum.cockos.com/showpost.php?p=1689028&postcount=15
-- if you just want a window centered on the screen
local l, t, r, b = 0, 0, w, h
local __, __, screen_w, screen_h = reaper.my_getViewport(l, t, r, b, l, t, r, b, 1)
local x, y = (screen_w - w) / 2, (screen_h - h) / 2

gfx.init("My window", w, h, 0, x, y)

end



-- https://forum.cockos.com/showthread.php?t=257766 SWS windows state // may apply to native as well in the reaper-screensets.ini
--[[
input = '6B010000F900000039040000030200000000000000000000A7'
data = input:gsub('%x%x', function(byte) return string.char(tonumber(byte, 16)) end)
left, top, right, bottom, state, whichdock = string.unpack('<iiiiII', data) -- state is a bitfield: 1=open, 2=docked
]]
function SWS_wnd_open(input)
local data = input:gsub('%x%x', function(byte) return string.char(tonumber(byte, 16)) end)
return ({string.unpack('<iiiiII', data)})[5] == '1'
end

function SWS_wnd_data(input)
local data = input:gsub('%x%x', function(byte) return string.char(tonumber(byte, 16)) end)
local left, top, right, bottom, state, dockermode = string.unpack('<iiiiII', data) -- state is a bitfield: 1=open, 2=docked
return left, top, right, bottom, state+0&1 == 1, state+0&2 == 2, dockermode -- +0 is accommodating for Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
end


local wnd_ident_t1 = {
-- transport docked pos in the top or bottom dockers can't be ascertained;
-- transport_dock=0 any time it's not docked at its reserved positions in the main window (see below)
-- which could be floating or docked in any other docker;
-- When 'Dock transport in the main window' option is enabled the values of the 'transport_dock_pos' key
-- corresponding to options under 'Docked transport position' menu item are:
-- 0 - Below arrange (default) [above bottom docker]; 1 - Above ruler [below top docker];
-- 2 - Bottom of main window [below bottom docker]; 3 - Top of main window [above top docker]
--	[40279] = 'Docker', -- View: Show docker ('Docker') // not supported by the script
[40078] = 'mixwnd_vis', -- View: Toggle mixer visible ('Mixer')
[40605] = 'actions', -- Show action list ('Actions') // doesn't keep size
--=============== 'Project Bay' // 8 actions // dosn't keep size ===============
[41157] = 'projbay_0', -- View: Show project bay window
[41628] = 'projbay_1', -- View: Show project bay window 2
[41629] = 'projbay_2', -- View: Show project bay window 3
[41630] = 'projbay_3', -- View: Show project bay window 4
[41631] = 'projbay_4', -- View: Show project bay window 5
[41632] = 'projbay_5', -- View: Show project bay window 6
[41633] = 'projbay_6', -- View: Show project bay window 7
[41634] = 'projbay_7', -- View: Show project bay window 8
--============================== Matrices ======================================
[40768] = 'routingwnd_vis', -- View: Show track grouping matrix window ('Grouping Matrix')
[40251] = 'routingwnd_vis', -- View: Show routing matrix window ('Routing Matrix')
[42031] = 'routingwnd_vis', -- View: Show track wiring diagram ('Track Wiring Diagram')
--===========================================================================
[40326] = 'regmgr', -- View: Show region/marker manager window ('Region/Marker Manager')	// doesn't keep size
[50124] = 'reaper_explorer', -- Media explorer: Show/hide media explorer ('Media Explorer') // doesn't keep size
[40906] = 'trackmgr', -- View: Show track manager window ('Track Manager')	// doesn't keep size
[40327] = 'grpmgr', -- View: Show track group manager window ('Track Group Manager')
[40378] = 'bigclock', -- View: Show big clock window ('Big Clock') // doesn't keep size
[50125] = 'reaper_video', -- Video: Show/hide video window ('Video Window')
[40240] = 'perf', -- View: Show performance meter window ('Performance Meter') // doesn't keep size
[40268] = 'navigator', -- View: Show navigator window ('Navigator') // doesn't keep size
[40377] = 'vkb', -- View: Show virtual MIDI keyboard ('Virtual MIDI Keyboard') // doesn't keep size
--	[41226] = 'nudge_vis', -- Item edit: Nudge/set... // non-toggle
[41827] = 'fadeedit', -- View: Show crossfade editor window ('Crossfade Editor')
[40072] = 'undownd_vis', -- View: Show undo history window ('Undo History')
[41076] = 'converter', -- File: Batch file converter ('Batch File/Item Converter')
-- !!! the ident string seems to be wrong as the value isn't updated --
--	[40271] = 'fxadd_vis', -- View: Show FX browser window ('Add FX to Track #')
--	[40271] = 'fxadd_vis', -- View: Show FX browser window ('Add FX to: Item')
--	[40271] = 'fxadd_vis', -- View: Show FX browser window ('Browse FX')
[40271] = 'fxadd_vis', -- View: Show FX browser window ('Add FX to Track #' or 'Add FX to: Item' or 'Browse FX')
[41589] = 'itemprops', -- Item properties: Toggle show media item/take properties ('Media Item Properties')
--=========== TOOLBARS // don't keep size; the ident strings are provisional ==========
-- when a toolbar is positioned at the top of the main window its dock and visibility states are 0
[41679] = 'toolbar:1', -- Toolbar: Open/close toolbar 1 ('Toolbar 1')
[41680] = 'toolbar:2', -- Toolbar: Open/close toolbar 2 ('Toolbar 2')
[41681] = 'toolbar:3', -- Toolbar: Open/close toolbar 3 ('Toolbar 3')
[41682] = 'toolbar:4', -- Toolbar: Open/close toolbar 4 ('Toolbar 4')
[41683] = 'toolbar:5', -- Toolbar: Open/close toolbar 5 ('Toolbar 5')
[41684] = 'toolbar:6', -- Toolbar: Open/close toolbar 6 ('Toolbar 6')
[41685] = 'toolbar:7', -- Toolbar: Open/close toolbar 7 ('Toolbar 7')
[41686] = 'toolbar:8', -- Toolbar: Open/close toolbar 8 ('Toolbar 8')
[41936] = 'toolbar:9', -- Toolbar: Open/close toolbar 9 ('Toolbar 9')
[41937] = 'toolbar:10', -- Toolbar: Open/close toolbar 10 ('Toolbar 10')
[41938] = 'toolbar:11', -- Toolbar: Open/close toolbar 11 ('Toolbar 11')
[41939] = 'toolbar:12', -- Toolbar: Open/close toolbar 12 ('Toolbar 12')
[41940] = 'toolbar:13', -- Toolbar: Open/close toolbar 13 ('Toolbar 13')
[41941] = 'toolbar:14', -- Toolbar: Open/close toolbar 14 ('Toolbar 14')
[41942] = 'toolbar:15', -- Toolbar: Open/close toolbar 15 ('Toolbar 15')
[41943] = 'toolbar:16', -- Toolbar: Open/close toolbar 16 ('Toolbar 16')
[42404] = 'toolbar:17', -- Toolbar: Open/close media explorer toolbar ('Toolbar 17')
--	[41084] = 'Toolbar Docker' -- Toolbar: Show/hide toolbar docker // not supported by the script
--====================== NON-TOGGLE WINDOWS // for restoration stage only, on the evaluation stage these are taken care of with wnds_extra_t =========================================
[41888] = 'routingwnd_vis', -- View: Show region render matrix window ('Region Render Matrix') // non-toggle
[41226] = 'nudge_vis', -- Item edit: Nudge/set... ('Nudge/set items') // non-toggle
[40604] = 'recopts', -- Track: View track recording settings (MIDI quantize, file format/path) for last touched track ('Track Recording Settings: Track #') // var. name, not toggle // the ident name seems wrong as its value doesn't change but since it's been allowed through at the restoration stage anyway, the ident name doesn't matter
-- >>>>>>>> MIDI Editor has been excluded from wnds_extra_t on the evaluation stage, so the following two entries won't be used <<<<<<<<<<<<
--	[40153] = 'MIDI take:', -- Item: Open in built-in MIDI editor (set default behavior in preferences) ('MIDI take:' or 'Edit MIDI (docked)' occasionally appears when MIDI Editor is in a floating docker but the tab name is the former) // var. name, not toggle
--	[40153] = 'Edit MIDI', -- see above
--[[======================== SWS EXTENSION ======================================
-- SWS extension windows which don't need resizing or pos changed since they maintain them, excluded since there's no way to get their state from reaper.ini, the value which can be extracted from there with the above function SWS_wnd_data() is not updated or updated inconsistently when window state changes, from reaper.ini it's possible to get the dockermode and visibility from the action toggle state but the actual dock state is not;
_SWSAUTOCOLOR_OPEN = 'SWSAutoColor', -- SWS: Open auto color/icon/layout window ('Auto Color/Icon/Layout')
_BR_CONTEXTUAL_TOOLBARS_PREF = 'BR - ContextualToolbars WndPos', -- SWS/BR: Contextual toolbars... ('Contextual toolbars')
['_S&M_CYCLEDITOR'] = 'SnMCyclaction', -- SWS/S&M: Open/close Cycle Action editor ('Cycle Actions') // doesn't remember section selection BUT all 3 actions toggle
['_S&M_SHOWFIND'] = 'SnMFind', -- SWS/S&M: Find ('Find')
_FNG_GROOVE_TOOL = 'FNGGroove', -- SWS/FNG: Show groove tool ('Groove')
['_S&M_SHOWMIDILIVE'] = 'SnMLiveConfigs', -- SWS/S&M: Open/close Live Configs window ('Live Config')
_BR_ANALAYZE_LOUDNESS_DLG = 'BR - AnalyzeLoudness WndPos', -- SWS/BR: Analyze loudness... ('Loudness')
_SWSMARKERLIST1 = 'SWSMarkerList', -- SWS: Open marker list ('Marker List')
['_S&M_SHOW_NOTES_VIEW'] = 'SnMNotesHelp', -- SWS/S&M: Open/close Notes window ('Notes') // does remember notes type selection so other 11 actions will likely be redundant
_SWS_PROJLIST_OPEN = 'SWSProjectList', -- SWS: Open project list ('Project List')
_SWSCONSOLE = 'ReaConsole', -- SWS: Open console ('ReaConsole')
['_S&M_SHOW_RGN_PLAYLIST'] = 'SnMRgnPlaylist', -- SWS/S&M: Open/close Region Playlist window ('Region Playlist')
['_S&M_SHOW_RESOURCES_VIEW'] = 'SnMResources', -- SWS/S&M: Open/close Resources window ('Resources') // does remember resource type selection so other 7 actions will likely be redundant
_SWSSNAPSHOT_OPEN = 'SWSSnapshots', -- SWS: Open snapshots window ('Snapshots') // (caused redraw problem)
['_SWSTL_OPEN'] = 'SWSTrackList' -- SWS: Show Tracklist
]]
}


local wnd_ident_t = { -- to be used in Get_Mixer_Wnd_Dock_State() function
-- the keys are those appearing in reaper.ini [REAPERdockpref] section
-- transport docked pos in the top or bottom dockers can't be ascertained;
-- transport_dock=0 any time it's not docked at its reserved positions in the main window (see below)
-- which could be floating or docked in any other docker;
-- When 'Dock transport in the main window' option is enabled the values of the 'transport_dock_pos' key
-- corresponding to options under 'Docked transport position' menu item are:
-- 0 - Below arrange (default) [above bottom docker]; 1 - Above ruler [below top docker];
-- 2 - Bottom of main window [below bottom docker]; 3 - Top of main window [above top docker]
-- window 'dock=0' keys do not get updated if the window was undocked before a screenset where it's docked was (re)loaded which leads to false positives
-- The following key names are keys used in [REAPERdockpref] section
-- % escapes are included for use within string.match()
mixer = {'mixwnd_vis', 'mixwnd_dock'}, -- 40078 View: Toggle mixer visible ('Mixer')
actions = {'%[actions%]', 'wnd_vis', 'dock'}, -- Show action list ('Actions')
--=============== 'Project Bay' // 8 actions // dosn't keep size ===============
projbay_0 = {'%[projbay_0%]', 'wnd_vis', 'dock'}, -- View: Show project bay window
projbay_1 = {'%[projbay_1%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 2
projbay_2 = {'%[projbay_2%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 3
projbay_3 = {'%[projbay_3%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 4
projbay_4 = {'%[projbay_4%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 5
projbay_5 = {'%[projbay_5%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 6
projbay_6 = {'%[projbay_6%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 7
projbay_7 = {'%[projbay_7%]', 'wnd_vis', 'dock'}, -- View: Show project bay window 8
--============================== Matrices ======================================
routing = {'routingwnd_vis', 'routing_dock'}, -- View: Show track grouping matrix window ('Grouping Matrix'); View: Show routing matrix window ('Routing Matrix'); View: Show track wiring diagram ('Track Wiring Diagram')
--===========================================================================
regmgr = {'%[regmgr%]', 'wnd_vis', 'dock'}, -- View: Show region/marker manager window ('Region/Marker Manager')
explorer = {'%[reaper_explorer%]', 'visible', 'docked'}, -- Media explorer: Show/hide media explorer ('Media Explorer')
trackmgr = {'%[trackmgr%]', 'wnd_vis', 'dock'}, -- View: Show track manager window ('Track Manager')
grpmgr = {'%[grpmgr%]', 'wnd_vis', 'dock'}, -- View: Show track group manager window ('Track Group Manager')
bigclock = {'%[bigclock%]', 'wnd_vis', 'dock'}, -- View: Show big clock window ('Big Clock')
video = {'%[reaper_video%]', 'visible', 'docked'}, -- Video: Show/hide video window ('Video Window')
perf = {'%[perf%]', 'wnd_vis', 'dock'}, -- View: Show performance meter window ('Performance Meter')
navigator = {'%[navigator%]', 'wnd_vis', 'dock'}, -- View: Show navigator window ('Navigator')
vkb = {'%[vkb%]', 'wnd_vis', 'dock'}, -- View: Show virtual MIDI keyboard ('Virtual MIDI Keyboard')
fadeedit = {'%[fadeedit%]', 'wnd_vis', 'dock'}, -- View: Show crossfade editor window ('Crossfade Editor')
undo = {'undownd_vis', 'undownd_dock'}, -- View: Show undo history window ('Undo History')
fxbrowser = {40271, 'fxadd_dock'}, -- View: Show FX browser window ('Add FX to Track #' or 'Add FX to: Item' or 'Browse FX') // fxadd_vis value doesn't change hence action to check visibility
itemprops = {'%[itemprops%]', 'wnd_vis', 'dock'}, -- Item properties: Toggle show media item/take properties ('Media Item Properties')
midiedit = {'%[midiedit%]', 'dock'}, -- there's no key for MIDI Editor visibility
--=========== TOOLBARS // don't keep size; the ident strings are provisional ==========
toolbar = {'toolbar', 'wnd_vis', 'dock'} -- Toolbar: Open/close toolbar X ('Toolbar X')
}


function Get_Mixer_Wnd_Dock_State(wnd_ident_t, wantDockPos) -- get Mixer dock state WHEN the SWS extension IS NOT INSTALLED to verify whether there're other windows sharing a docker with the Mixer in the split mode and so whether its full window width can be used; returns false if there's a window which shares a docker with the Mixer, otherwise true

-- dockermode of closed docked windows isn't updated, so when the Mixer doesn't share docker with any other windows
-- in the split mode at a given moment because these windows are closed, to ensure that its full width, obtained with
-- my_getViewport(), can be used, these closed windows visibility toggle state must be evaluated as well
-- a more reliable method would be to read screenset data

local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local mixwnd_dock = r.GetToggleCommandStateEx(0, 40083) == 1 -- or cont:match('mixwnd_dock=1') -- Mixer: Toggle docking in docker // mixwnd_dock value is likely to not update when state changes hence alternative
local mixer_dockermode = cont:match('%[REAPERdockpref%].-%f[%a]mixer=[%d%.]-%s(%d+)\n') -- find mixer dockermode number // the frontier operator %f is needed to avoid false positive of 'mastermixer' which refers to the Master track
local mixer_dock_pos = cont:match('dockermode'..mixer_dockermode..'=(%d+)') -- get mixer docker position

	if wantDockPos then return mixer_dock_pos end -- if requested, return pos in case the entire docker is closed and not the Mixer window itself, to condition the rightmost position routine because in this case it won't work, but nevertheless will run because Mixer toggle state will still be OFF and hence true; plus if dockerpos is not 0 (bottom) or 2 (top) the rightmost position won't be needed anyway as without SWS extension in other docks and in floating window only the leftmost pos is honored by the script; must come before the next condition so it's not blocked by it if the latter is true
	if not mixwnd_dock -- in floating Mixer window wihtout SWS extension only use leftmost position
	or (mixer_dock_pos ~= '0' and mixer_dock_pos ~= '2') -- if sits in side dockers, only use leftmost position because the Mixer window cannot have full width anyway
	then return false
	elseif mixwnd_dock and mixer_dockermode and (mixer_dock_pos == '0' or mixer_dock_pos == '2') -- bottom or top, where Mixer window can stretch to the full width of the main window
	then
	local temp = cont -- temp var to perform repeats count below without risking to affect the orig. data
	local _, reps = temp:gsub('dockermode','%0') -- get number of repeats
	local dockermode_t = {cont:match(string.rep('.-(dockermode%d+=%d)', reps))} -- collect all dockermode entries
	local adjacent_dockermode_t = {}
		for _, v in ipairs(dockermode_t) do -- collect dockermode indices of all windows which share the docker with the Mixer in the split mode
			if v:match('(%d+)=') ~= mixer_dockermode -- exclude mixer's own dockermode entry
			and v:match('=(%d)') == mixer_dock_pos then -- if positon is the same as that of Mixer which means the docker is split and causes change in Mixer window size
			adjacent_dockermode_t[#adjacent_dockermode_t+1] = v:match('(%d+)=')
			end
		end
		if #adjacent_dockermode_t > 0 then -- if there're dockermodes which share docker with the Mixer
		local REAPERdockpref = cont:match('%[REAPERdockpref%](.-)%[')
		local REAPERdockpref_t = {}
			for line in REAPERdockpref:gmatch('\n?(.-%s%d+)\n?') do -- extract all [REAPERdockpref] section entries
			REAPERdockpref_t[#REAPERdockpref_t+1] = line
			end
		local adjacent_wnd_t = {}
			for _, v1 in ipairs(adjacent_dockermode_t) do -- collect names of windows sitting in a split docker with the Mixer (having dockermode with the same position as that of the Mixer) whether visible or not
				for _, v2 in ipairs(REAPERdockpref_t) do
					if v1 == v2:match('.+%s(%d+)') then
					adjacent_wnd_t[#adjacent_wnd_t+1] = v2:match('(.+)=') end
				end
			end
			for _, v in ipairs(adjacent_wnd_t) do -- evaluate the collected windows visibility and dock state
			local t = wnd_ident_t[v] or wnd_ident_t[v:match('toolbar')] -- toolbar key is separate since in adjacent_wnd_t toolbar keys contain numbers and can't select the table nested inside wnd_ident_t directly; match to isolate 'toolbar' word specifically since the list may include SWS window identifiers
				if t and #t == 3 and t[1] ~= 'toolbar' then -- or if v ~= 'toolbar'; windows with a dedicated section in reaper.ini besides toolbars which are treated below // additional t truthfulness evaluation because if the adjacent_wnd_t list contains SWS window identifiers the t will be false
				local sect = cont:match(t[1]..'(.-)%[') or cont:match(t[1]..'(.-)$') -- capture section content either followed by another section or at the very end of the file
					if sect:match(t[2]..'=1') and sect:match(t[3]..'=1') then return false end
				elseif t and #t == 2 and tonumber(t[1]) then -- fxbrowser command ID and a key
					if r.GetToggleCommandStateEx(0, t[1]) == 1 and cont:match(t[2]..'=1') then return false end
				elseif t and #t == 2 and v == 'midiedit' then -- MIDI Editor, always returns false if docked in the same docker as the Mixer regardless of visibility because the latter cannot be ascertained from reaper.ini
					local sect = cont:match(t[1]..'(.-)%[') or cont:match(t[1]..'(.-)$') -- capture section content either followed by another section or at the very end of the file
						if sect:match(t[2]..'=1') then return false end
				elseif t and #t == 2 then -- windows without a dedicated section
					if cont:match(t[1]..'=1') and cont:match(t[2]..'=1') then
					return false end
				elseif t and t[1] == 'toolbar' then -- or if v == 'toolbar'
				local sect = cont:match('%['..v..'%](.-)%[') or cont:match('%['..v..'%](.-)$') -- capture section content either followed by another section or at the very end of the file
					if sect and sect:match(t[2]..'=1') and sect:match(t[3]..'=1') then return false end -- sect can be false if the stored toolbar has no section, in particular 'toolbar' (without a number) representing Arrange main toolbar
				end
			end
		end
	end

return true

end


local wnd_ident_t = { -- to be used with Detect_Docker_Pane_Change(), Get_Mixer_Width()
-- the keys are those appearing in reaper.ini [REAPERdockpref] section
-- visibility key isn't used, the preceding action command ID is used instead to evaluate visibility
-- dockheight_t= height of the top docker // doesn't change when a new window with greater height is added to the docker, only when the docker is resized manually, just like toppane= value
-- transport docked pos in the top or bottom dockers can't be ascertained;
-- transport_dock=0 any time it's not docked at its reserved positions in the main window (see below)
-- which could be floating or docked in any other docker;
-- When 'Dock transport in the main window' option is enabled the values of the 'transport_dock_pos' key
-- corresponding to options under 'Docked transport position' menu item are:
-- 0 - Below arrange (default) [above bottom docker]; 1 - Above ruler [below top docker];
-- 2 - Bottom of main window [below bottom docker]; 3 - Top of main window [above top docker]
-- FX chain, MIDI Editor, IDE windows, of course scripts which have dockable windows aren't covered
transport = {'transport_dock_pos', 'transport_dock', 40259}, -- View: Toggle transport visible // transport_dock_pos must be 1 or 3; see 2nd key explanation above
-- mixer = {'mixwnd_dock', 'mixwnd_vis'},
mixer = {
40083, -- Mixer: Toggle docking in docker
40078 -- View: Toggle mixer visible ('Mixer')
},
actions = {'%[actions%]', 'dock', 40605, 'wnd_vis'}, -- Show action list ('Actions')
--=============== 'Project Bay' // 8 actions ===============
projbay_0 = {'%[projbay_0%]', 'dock', 41157, 'wnd_vis'}, -- View: Show project bay window
projbay_1 = {'%[projbay_1%]', 'dock', 41628, 'wnd_vis'}, -- View: Show project bay window 2
projbay_2 = {'%[projbay_2%]', 'dock', 41629, 'wnd_vis'}, -- View: Show project bay window 3
projbay_3 = {'%[projbay_3%]', 'dock', 41630, 'wnd_vis'}, -- View: Show project bay window 4
projbay_4 = {'%[projbay_4%]', 'dock', 41631, 'wnd_vis'}, -- View: Show project bay window 5
projbay_5 = {'%[projbay_5%]', 'dock', 41632, 'wnd_vis'}, -- View: Show project bay window 6
projbay_6 = {'%[projbay_6%]', 'dock', 41633, 'wnd_vis'}, -- View: Show project bay window 7
projbay_7 = {'%[projbay_7%]', 'dock', 41634, 'wnd_vis'}, -- View: Show project bay window 8
--============================== Matrices ======================================
routing = {'routing_dock', 'routingwnd_vis', 40768, 40251, 42031, 41888}, -- 3 toggles: View: Show track grouping matrix window ('Grouping Matrix'); View: Show routing matrix window ('Routing Matrix'); View: Show track wiring diagram ('Track Wiring Diagram'); one non-toggle: View: Show region render matrix window ('Region Render Matrix') -- so using reaper.ini is more reliable because it reflects the state of the 'Region Render Matrix' as well
--===========================================================================
regmgr = {'%[regmgr%]', 'dock', 40326, 'wnd_vis'}, -- View: Show region/marker manager window ('Region/Marker Manager')	// doesn't keep size
explorer = {'%[reaper_explorer%]', 'docked', 50124, 'visible'}, -- Media explorer: Show/hide media explorer ('Media Explorer') // doesn't keep size
trackmgr = {'%[trackmgr%]', 'dock', 40906, 'wnd_vis'}, -- View: Show track manager window ('Track Manager')	// doesn't keep size
grpmgr = {'%[grpmgr%]', 'dock', 40327, 'wnd_vis'}, -- View: Show track group manager window ('Track Group Manager')
bigclock = {'%[bigclock%]', 'dock', 40378, 'wnd_vis'}, -- View: Show big clock window ('Big Clock') // doesn't keep size
video = {'%[reaper_video%]', 'docked', 50125, 'visible'}, -- Video: Show/hide video window ('Video Window')
perf = {'%[perf%]', 'dock', 40240, 'wnd_vis'}, -- View: Show performance meter window ('Performance Meter') // doesn't keep size
navigator = {'%[navigator%]', 'dock', 40268, 'wnd_vis'}, -- View: Show navigator window ('Navigator') // doesn't keep size
vkb = {'%[vkb%]', 'dock', 40377, 'wnd_vis'}, -- View: Show virtual MIDI keyboard ('Virtual MIDI Keyboard') // doesn't keep size
fadeedit = {'%[fadeedit%]', 'dock', 41827, 'wnd_vis'}, -- View: Show crossfade editor window ('Crossfade Editor')
undo = {'undownd_dock', 40072, 'undownd_vis'}, -- View: Show undo history window ('Undo History')
fxbrowser = {'fxadd_dock', 40271}, -- View: Show FX browser window ('Add FX to Track #' or 'Add FX to: Item' or 'Browse FX')  // fxadd_vis value doesn't change hence action to check visibility
itemprops = {'%[itemprops%]', 'dock', 41589, 'wnd_vis'}, -- Item properties: Toggle show media item/take properties ('Media Item Properties')
-- MIDI editor assignment to dockermode index only changes when it's being docked by dragging
-- if it's being docked via context menu the dockermode it's already assigned to is re-pointed to the new location
-- could be applicable to any window
-- midiedit key dockermode data only changes for the last active MIDI Editor even if there're several in the project
-- MIDI editor dock state like any MIDI editior toggle action can only be retrieved when MIDI editor is active
-- if there're more than one MIDI editor window open each one will have to be activated in turn and its dock state checked
-- which is impossible; decided to use it anyway so any change in MIDI Editor window regardless of its dock position
-- will trigger update just in case;
-- besides, MIDIEditor_GetActive() isn't reliable since it returns the pointer of the last focused MIDI Editor
-- attached to a docker when the docker is closed https://forum.cockos.com/showthread.php?t=278871
-- but since docker state is evaluated as well this doesn't pose a problem
midiedit = {'%[midiedit%]', 'dock', r.MIDIEditor_GetActive()},
--=========== TOOLBARS // the ident strings are provisional ==========
-- when a toolbar is positioned at the top of the main window its dock and visibility states are 0
['toolbar:1'] = {'%[toolbar:1%]', 'dock', 41679, 'wnd_vis'}, -- Toolbar: Open/close toolbar 1 ('Toolbar 1')
['toolbar:2'] = {'%[toolbar:2%]', 'dock', 41680, 'wnd_vis'}, -- Toolbar: Open/close toolbar 2 ('Toolbar 2')
['toolbar:3'] = {'%[toolbar:3%]', 'dock', 41681, 'wnd_vis'}, -- Toolbar: Open/close toolbar 3 ('Toolbar 3')
['toolbar:4'] = {'%[toolbar:4%]', 'dock', 41682, 'wnd_vis'}, -- Toolbar: Open/close toolbar 4 ('Toolbar 4')
['toolbar:5'] = {'%[toolbar:5%]', 'dock', 41683, 'wnd_vis'}, -- Toolbar: Open/close toolbar 5 ('Toolbar 5')
['toolbar:6'] = {'%[toolbar:6%]', 'dock', 41684, 'wnd_vis'}, -- Toolbar: Open/close toolbar 6 ('Toolbar 6')
['toolbar:7'] = {'%[toolbar:7%]', 'dock', 41685, 'wnd_vis'}, -- Toolbar: Open/close toolbar 7 ('Toolbar 7')
['toolbar:8'] = {'%[toolbar:8%]', 'dock', 41686, 'wnd_vis'}, -- Toolbar: Open/close toolbar 8 ('Toolbar 8')
['toolbar:9'] = {'%[toolbar:9%]', 'dock', 41936, 'wnd_vis'}, -- Toolbar: Open/close toolbar 9 ('Toolbar 9')
['toolbar:10'] = {'%[toolbar:10%]', 'dock', 41937, 'wnd_vis'}, -- Toolbar: Open/close toolbar 10 ('Toolbar 10')
['toolbar:11'] = {'%[toolbar:11%]', 'dock', 41938, 'wnd_vis'}, -- Toolbar: Open/close toolbar 11 ('Toolbar 11')
['toolbar:12'] = {'%[toolbar:12%]', 'dock', 41939, 'wnd_vis'}, -- Toolbar: Open/close toolbar 12 ('Toolbar 12')
['toolbar:13'] = {'%[toolbar:13%]', 'dock', 41940, 'wnd_vis'}, -- Toolbar: Open/close toolbar 13 ('Toolbar 13')
['toolbar:14'] = {'%[toolbar:14%]', 'dock', 41941, 'wnd_vis'}, -- Toolbar: Open/close toolbar 14 ('Toolbar 14')
['toolbar:15'] = {'%[toolbar:15%]', 'dock', 41942, 'wnd_vis'}, -- Toolbar: Open/close toolbar 15 ('Toolbar 15')
['toolbar:16'] = {'%[toolbar:16%]', 'dock', 41943, 'wnd_vis'}, -- Toolbar: Open/close toolbar 16 ('Toolbar 16')
['toolbar:17'] = {'%[toolbar:17%]', 'dock', 42404, 'wnd_vis'} -- Toolbar: Open/close media explorer toolbar ('Toolbar 17')
}


function Detect_Docker_Pane_Change(wnd_ident_t, pos)
-- pos is integer signifying docker position: 0 - bottom, 1 - left, 2 - top, 3 - right
-- a) store current dock and visibility state values of windows from wnd_ident_t table as extended state
-- b) recall them and collate with their current values if their dockermode belongs to the docker corresponding to the 'pos' arg, if pos is 2 (top) it's needed because main window header height affects Arrange height
-- c) if change is detected, update the stored values and return truth to trigger Get_Arrange_and_Header_Heights() function to get the new Arrange height

	local function get_windows(t, dockermode)
		for _, v in ipairs(t) do
			if v == dockermode then return true end
		end
	end
	local function vis(cmdID)
	return r.GetToggleCommandStateEx(0,cmdID) == 1
	end
	local function get_ini_cont()
	local f = io.open(r.get_ini_file(), 'r')
	local cont = f:read('*a')
	f:close()
	return cont
	end
	local function concat_updated_vals(ref_t)
		for k, v in ipairs(ref_t) do -- string keys and non-sequential numeric keys such as action command IDs will be ignored
		local tab = ref_t[v]
		ref_t[k] = (k >= 1 and k <= 4 or k > 47) and tab or k == 5 and tab[1]..tab[2]..tab[3] or tab[1]..tab[2] -- update values in numeric keys with values from string keys; values for the first 4 numeric and 48+ keys of ref_t are singular without a nested table; for transport (5) it's a triplet; the rest are dual - dock state & visibility
		end
	-- first concatenate, then return, otherwise what will be returned is the function
	local upd_vals = table.concat(ref_t, ' ') -- concatenation ignores non-numeric and non-sequential keys
	return upd_vals
	end
	local function vals_changed(dock, vis, dock_ref, vis_ref)
	return dock == '1' and dock ~= dock_ref and (vis == '1' and vis ~= vis_ref or vis_ref == '1') -- window became docked AND visible or WHILE being visible
	or dock == '0' and dock ~= dock_ref and vis == '1' and vis == vis_ref -- window became undocked from the top WHILE being visible
	or dock == '1' and dock == dock_ref and vis ~= vis_ref -- docked window visibility changed
	end

-- Store/retrieve stored values, storage disregards attachment of a window to the top docker, all are stored

-- ref_t is list of stored values a change in which will trigger arrange height update with Get_Arrange_and_Header_Heights()
-- the order of values corresponds to the order of keys in wnd_ident_t with 4 additional fields added at the beginning for non-dual values and which will be evaluated separately
-- 47 native window fields
local dock_h = pos == 0 and 'dockheight' or pos == 1 and 'dockheight_l' or pos == 2 and 'dockheight_t' or pos == 3 and 'dockheight_r'
local pane = pos == 0 and 'invalid' or pos == 1 and 'leftpanewid' or pos == 2 and 'toppane'
or pos == 3 and (r.GetToogleCommandStateEx(0,42373) and 'leftpanewid' or 'invalid') -- View: Show TCP on right side of arrange // 'leftpanewid' is also relevant when pos argument is 3 (right) and the tracklist is on the right, otherwise irrelevant)
local ref_t = {41297, 40279, dock_h, pane, 'transport', 'mixer', 'actions', 'projbay_0',
'projbay_1', 'projbay_2', 'projbay_3', 'projbay_4', 'projbay_5', 'projbay_6', 'projbay_7', 'routing',
'regmgr', 'explorer', 'trackmgr', 'grpmgr', 'bigclock', 'video', 'perf', 'navigator', 'vkb', 'fadeedit',
'undo', 'fxbrowser', 'itemprops', 'midiedit', 'toolbar:1', 'toolbar:2', 'toolbar:3', 'toolbar:4', 'toolbar:5',
'toolbar:6', 'toolbar:7', 'toolbar:8', 'toolbar:9', 'toolbar:10', 'toolbar:11', 'toolbar:12', 'toolbar:13',
'toolbar:14', 'toolbar:15', 'toolbar:16', 'toolbar:17'}

local retval, vals = r.GetProjExtState(0, 'DOCK'..pos..' WINDOWS STATE', 'stored_vals')
local vals = (retval == 0 or #vals == 0) and r.GetExtState('DOCK'..pos..' WINDOWS STATE', 'stored_vals') or vals
	if #vals == 0 then -- initial storage
	local cont = get_ini_cont()
		for k, v in ipairs(ref_t) do
		local tab = wnd_ident_t[v]
			if k >= 1 and k <= 4 then
			ref_t[k] = k < 3 and (vis(v) and '1' or '0') -- Toolbar: Show/hide toolbar at top of main window, View: Show docker
			or k >= 3 and cont:match(v..'=(%d-)\n') or '0' -- dock height and pane height/width, the latter is only relevant for top/left panes hence alternative 0 for bottom which is invalid, leftpane is also relevant when the tracklist is displayed on the right and pos argument is 3 (right) but otherwise won't be valid either
			-- next store dock state:visibility
			-- first windows with mixed values and without dedicated section in reaper.ini
			elseif v == 'transport' then -- 1st field holds dock state key, 2nd - docked status outside of the reserved positions, 3d holds command ID
			ref_t[k] = (cont:match(tab[1]..'=(%d-)\n') or '0')..(cont:match(tab[2]..'=(%d-)\n') or '0')..(vis(tab[3]) and '1' or '0')
			elseif v == 'mixer' then -- both fields in the nested table hold command IDs
			ref_t[k] = (vis(tab[1]) and '1' or '0')..(vis(tab[2])  and '1' or '0')
			elseif v == 'routing' then -- only 1st two fields are used, both hold reaper.ini keys
			local dock, vis = cont:match(tab[1]..'=(%d-)\n') or '0', cont:match(tab[2]..'=(%d-)\n') or '0'
			ref_t[k] = dock..vis
			elseif v == 'undo' or v == 'fxbrowser' then -- 1st field holds dock state key, 2nd holds command ID
			local dock, vis = cont:match(tab[1]..'=(%d-)\n') or '0', vis(tab[2]) and '1' or '0'
			ref_t[k] = dock..vis
			elseif v:match('[%u]') then -- SWS ext window identifier name, they all have upper case chars unlike the native ones // ignored if ref_t doesn't contain them
			ref_t[k] = r.GetToggleCommandStateEx(0, r.NamedCommandLookup(v)) == 1 and '1' or '0' -- only visibility since it's impossible to get SWS ext windows dock state
			-- then windows with dedicated section in reaper.ini and hence 3 fields in the nested table
			else -- section and key may not exist yet so must be ascertained, if not found zeros are stored
			local sect = cont:match(tab[1])
			local dock = sect and cont:match(sect..'.-'..tab[2]..'=(%d-)\n') or '0' -- sect is already escaped
			local vis = v == 'midiedit' and tab[3] or v ~= 'midiedit' and vis(tab[3]) -- for MIDI editor visibility evaluation a function is used
			ref_t[k] = dock..(vis and '1' or '0')
			end
		end
	local vals = table.concat(ref_t, ' ')
	r.SetExtState('DOCK'..pos..' WINDOWS STATE', 'stored_vals', vals, false) -- persist false
	r.SetProjExtState(0, 'DOCK'..pos..' WINDOWS STATE', 'stored_vals', vals)
	return true -- exit function and trigger initial arrange props storage in Get_Arrange_and_Header_Heights()
	else -- retrieve stored values
	local cntr = 0
		for data in vals:gmatch('%d+') do
			if data then
			cntr = cntr+1
		--	add as string keys in ref_t for easier evaluation against reaper.ini data, won't interfere with the already present numeric keys
			local a, b, c = table.unpack((cntr >= 1 and cntr <= 4 or cntr > 47) and {data} or cntr == 5 and {data:match('(%d)(%d)(%d)')} or {data:match('(%d)(%d)')}) -- first 4 vals and 48+ are singular, 5th (transport) is a triplet, the rest are dual - dock state:visibility
			ref_t[ref_t[cntr]] = c and {a, b, c} or b and {a, b} or a -- a, b, c are dock, reserved, visible for transport; a, b are dock, visible; a - dock for keys 1-4, and visibility for key 48+ (SWS ext)
			end
		end
	end

-- Compare stored values with the current one looking for changes and update stored values if there's any change

local update

-- top toolbar visibility
local tb_top, tb_top_ref = vis(41297) and '1' or '0', ref_t[41297] -- Toolbar: Show/hide toolbar at top of main window
	if tb_top ~= tb_top_ref then
	ref_t[41297] = tb_top; update = 1
	end
-- docker visibility
local dock, dock_ref = vis(40279) and '1' or '0', ref_t[40279] -- View: Show docker // there not necessarily should be an active top docker, but since it's difficult to ascertain, trigger whenever the action toggle state changes
	if dock ~= dock_ref then
	ref_t[40279] = dock; update = 1
	end
-- top docker/pane hight change
local cont = get_ini_cont()
local dock_h_ref, pane_ref = ref_t[dock_h], ref_t[pane]
local dock_h_cur, pane_cur = cont:match(ref_t[3]..'=(%d-)\n'), cont:match(ref_t[4]..'=(%d-)\n')
		if dock_h_cur ~= dock_h_ref then
		ref_t[dock_h] = dock_h_cur; update = 1
		elseif pane_cur and pane_cur ~= pane_ref then -- pane_cur var can be nil if pos argument is 0 (bottom), or 3 (right) and the tracklist isn't displayed on the right
		ref_t[pane] = pane_cur; update = 1
		end
-- 'transport', 1st field holds dock state key, 2nd - floating or docked elsewhere; 3d holds command ID; transport dock position other than the reserved ones attached in the main window cannot be ascertained, see comments to wnd_ident_t table, therefore its evaluated outside of the loop below separately from windows whose dock position can be ascertained
local tab = wnd_ident_t.transport
local dock, reserv, visib = cont:match(tab[1]..'=(%d)\n') or '0', cont:match(tab[2]..'=(%d)\n') or '0', vis(tab[3]) and '1' or '0'

local tab = ref_t.transport
local dock_ref, reserv_ref, vis_ref = tab[1], tab[2], tab[3] -- ref nested table only holds 2 values, dock state and visibility
	if reserv ~= reserv_ref and (dock_ref == '1' or dock_ref == '3') and visib == '1' and visib == vis_ref -- window got detached from or attached to reserved position at the top while being visible
	or (dock == '1' or dock == '3') and dock_ref ~= '1' and dock_ref ~= '3' and (visib == '1' and visib ~= vis_ref
	or vis_ref == '1') -- window became docked at the top at one of the reserved positions AND visible or WHILE being visible
	or dock ~= '1' and dock ~= '3' and (dock_ref == '1' or dock_ref == '3') and visib == '1' and visib == vis_ref -- window became docked in one of the reserved positions OTHER than at the top WHILE being visible
	or (dock == '1' or dock == '3') and dock == dock_ref and visib ~= vis_ref -- visibility of transport docked at the top in one of the reserved positions changed
	then
	ref_t.transport = {dock, reserv, visib}
	update = 1
	end

local ini_path = r.get_ini_file()
local top_t = {}
	for line in io.lines(ini_path) do -- collect all dockermode indices pointing to the docker specified in pos arg
	local dockermode = line:match('dockermode(%d+)='..pos)
		if dockermode then
		top_t[#top_t+1] = dockermode end
	end

local wnd_t, found = {}
	-- lines don't capture line break
	for line in io.lines(ini_path) do -- collect key names of all windows attached to the collected dockermodes
		if line:match('REAPERdockpref') then found = 1
		elseif found and line:match('%[.-%]') then break -- new section
		elseif found and get_windows(top_t, line:match('.+ (%d+)')) then -- before the capture space is required otherwise double digit dockermode index won't be captured since the greedy operator will only stop at the last digit
		wnd_t[#wnd_t+1] = line:match('(.+)=')
		end
	end

	for _, v in ipairs(wnd_t) do -- evaluate collected windows docker and visibility status against stored retrieved values, first 4 have been evaluated above // by itself assignment of a window to a dockermode isn't significant as this is merely the last known value of the docked window which currently can be floating, therefore the actual dock and visibility status must be evaluated
		if wnd_ident_t[v] then
		local sws = v:match('[%u]') -- SWS ext window identifier name, they all have upper case chars unlike the native ones // ignored if wnd_ident_t doesn't contain them
		local tab = wnd_ident_t[v]
		local dock_ref, vis_ref, dock, visib = ref_t[v][1], ref_t[v][2] -- visib instead of vis to prevent clash with vis() function
			if v == 'mixer' then -- both fields in the nested table hold command IDs
			dock, visib = vis(tab[1]) and '1' or '0', vis(tab[2]) and '1' or '0'
			update = vals_changed(dock, visib, dock_ref, vis_ref) or update
			elseif v == 'routing' then -- only 1st two fields are used, both hold reaper.ini keys
			dock, visib = cont:match(tab[1]..'=(%d-)\n') or '0', cont:match(tab[2]..'=(%d-)\n') or '0' -- in case the key hasn't been added yet to reaper.ini
			update = vals_changed(dock, visib, dock_ref, vis_ref) or update
			elseif (v == 'undo' or v == 'fxbrowser') then -- 1st field holds dock state key, 2nd holds command ID
			dock, visib = cont:match(tab[1]..'=(%d-)\n') or '0', vis(tab[2]) and '1' or '0'
			update = vals_changed(dock, visib, dock_ref, vis_ref) or update
			elseif sws then
			visib = r.GetToggleCommandStateEx(0, r.NamedCommandLookup(v)) == 1 and '1' or '0'
			update = ref_t[v] ~= visib or update -- SWS ext only ref value (visibility) isn't stored in a nested table
			else -- windows with dedicated section in reaper.ini and hence 3 fields in the nested table
			dock = cont:match(tab[1]..'.-'..tab[2]..'=(%d-)\n') or '0'
			visib = v == 'midiedit' and (tab[3] and '1' or '0') or v ~= 'midiedit' and (vis(tab[3]) and '1' or '0') -- for MIDI editor visibility evaluation the MIDIEditor_GetActive() function stored in the nested table is used, but the function isn't reliable in determining visibilty when the MIDI editor is attached to a closed docker because in this case it still returns its pointer when no other MIDI editor window has focus, as if it were visible https://forum.cockos.com/showthread.php?t=278871
			update = vals_changed(dock, visib, dock_ref, vis_ref) or update
			end
			if update then -- store under window identifier name used as a string key in the same table which won't interfere with its indexed part
			ref_t[v] = sws and visib or {dock, visib} -- SWS ext windows only have visibility stored // ignored if wnd_ident_t doesn't contain them
			end
		end
	end
	if update then
	local vals = concat_updated_vals(ref_t)
	r.SetExtState('DOCK'..pos..' WINDOWS STATE','stored_vals', vals, false) -- persist false
	r.SetProjExtState(0, 'DOCK'..pos..' WINDOWS STATE', 'stored_vals', vals)
	return true end -- exit function and trigger initial arrange props storage in Get_Arrange_and_Header_Heights()

end



function Get_Mixer_Width(wnd_ident_t)
-- if no extension is installed only returns width when the mixer is docked

local GetToggle = r.GetToggleCommandStateEx
	if GetToggle(0, 40078) == 0 then return end -- View: Toggle mixer visible // also if open along with other windows in a tabbed docker and its tab isn't selected
local master_vis = GetToggle(0, 41209) == 1 -- Mixer: Master track visible
-- OR
-- local master_vis = r.GetMasterTrackVisibility()&2 == 2 -- in fact contrary to the old versions of the API doc this is true if Master is hidden in the Mixer, if visible the expression will be false
local master_right = GetToggle(0, 40389) == 1 -- Mixer: Toggle show master track on right side
local master_docked = GetToggle(0, 41610) == 1 -- Mixer: Toggle master track in docked window
-- OR
-- local master_docked = r.GetToggleCommandStateEx(0, 41609) == 1 -- View: Toggle master track in separate/docked window
local master_w = master_vis and not master_docked and r.GetMediaTrackInfo_Value(r.GetMasterTrack(0), 'I_MCPW') or 0
local sws, js = r.APIExists('BR_Win32_GetMixerHwnd'), r.APIExists('JS_Window_Find')

	if sws or js then -- if SWS/js_ReaScriptAPI ext is installed
	local mixer = sws and r.BR_Win32_GetMixerHwnd() or js and r.JS_Window_Find('Mixer', false) -- exact is false because  in a floating docker it's 'Mixer (docked)'
	local retval, rt, top, lt, bot = table.unpack(sws and {r.BR_Win32_GetWindowRect(mixer)} or js and {r.JS_Window_GetRect(mixer)})
	return lt-rt-master_w
	end

	if GetToggle(0, 40083) == 0 then return end -- Mixer: Toggle docking in docker // Mixer isn't docked, with native API its window size cannot be determined

-- without the extensions only respect docked Mixer, at the top/bottom its width will be considered equal full screen width, on the left/right it will be equal 1 track

local ini = r.get_ini_file()
	-- a floating docker cannot be split, only tabbed
local found, dockermode_init
	for line in io.lines(ini) do -- get Mixer dockermode
		if line:match('REAPERdockpref') then found = 1
		elseif found and line:match('^mixer=') then
		dockermode_init = line:match('.+ (%d+)')
		break end
	end
local pos
	for line in io.lines(ini) do
	pos = line:match('dockermode'..dockermode_init..'=(%d+)')
		if pos then break end
	end

	if pos == '32768' or pos == '32770' then return end -- floating docker, no point to continue because with native API size of a floating Mixer window cannot be determined

local t = {}
	for line in io.lines(ini) do -- collect dockermodes assigned to the same pos as the Mixer
	local dockermode = line:match('dockermode(%d+)='..pos)
		if dockermode and dockermode ~= dockermode_init then t[dockermode] = '' end -- dummy field // if dockermodes are the same the windows aren't displayed in the docker in the split mode in which case part of the docker width occupied by a window doesn't change, in this case only one window can be visible at a time within the same docker space
	end
local splits_num, found = 1
	for line in io.lines(ini) do -- count windows associated with the collected dockermodes and visible, that is which share the docker with the Mixer in split mode (different dockermodes, same position)
		if line:match('REAPERdockpref') then found = 1
		elseif found and line:match('%[.-%]') then break -- new section after 'REAPERdockpref'
		elseif found then
		local dockermode = line:match('.-=.+ (%d+)')
			if t[dockermode] then
			local wnd = line:match('(.+)=')
				if wnd ~= 'mixer' and wnd_ident_t[wnd] then
				local tab = wnd_ident_t[wnd]
					if wnd == 'routing' then
						for line in io.lines(ini) do
							if line:match(tab[2]..'=1') then
							splits_num = splits_num+1 break
							end
						end
					elseif wnd == 'undo' or wnd == 'fxbrowser' then
						if GetToggle(0, tab[2]) == 1 then
						splits_num = splits_num+1
						end
					elseif wnd == 'midiedit' then
						if tab[3] then splits_num = splits_num+1 end
					elseif GetToggle(0, tab[3]) == 1 then
					splits_num = splits_num+1
					end
				end
			end
		end
	end
local lt, top, rt, bot = r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true) -- true/1 - work area, false/0 - the entire screen // https://forum.cockos.com/showthread.php?t=195629#4 // !!!! MAY NOT WORK ON MAC since there Y axis starts at the bottom
local mixer_w = rt/splits_num - master_w
return mixer_w, pos -- pos will determine scroll type, full range of options when it's 0/2 (bottom/top) and by track only if it's 1/3 (left/right)
end



function GetTCP_Width(content) -- LIKELY OBSOLETE DUE TO time_pos_to_pixels() FUNCTION

local left_docker_on
-- find dockermode(s) keys assigned position value 1 - left
	for mode in content:gmatch('dockermode(%d*)=1') do
		if mode then
		-- find if windows/toobars keys assigned the found dockermode in the [REAPERdockpref] section
		local REAPERdockpref = content:match('REAPERdockpref%](.-)\n%[') -- isolate this section contents
			for str in REAPERdockpref:gmatch('[^\n\r]*') do
--Msg(str:match('.-=[%-%.%d]*%s'..v..'$'))
			local key = str:match('.-=[%-%.%d]*%s'..mode..'$') and str:match('^(.-)=')
			-- determine if windows/toolbars found in the [REAPERdockpref] section are docked and visible in the lefthand docker
			local sect = key and content:match('(%['..key..'%].-)%[') or (key and content:match('(%['..key..'%].-)$'))
				if sect then -- keys which have a dedicated section
				vis, dock = sect:match('wnd_vis=(%d)') or sect:match('visible=(%d)'), sect:match('dock=(%d)') or sect:match('docked=(%d)')
				else -- keys without a dedicated section, not exhaustive
					if key == 'fxbrowser' then vis, dock = content:match('fxadd_vis=(%d)'), content:match('fxadd_dock=(%d)')
					elseif key == 'mixer' then vis, dock = content:match('mixwnd_vis=(%d)'), content:match('mixwnd_dock=(%d)')
					elseif key == 'transport' then vis, dock = content:match(key..'_vis=(%d)'), content:match(key..'_dock=(%d)')
					end
				end
				if vis == '1' and vis == dock then left_docker_on = true break end
			end
		end
		if left_docker_on == true then break end
	end

--Msg('DOCKER = '..tostring(left_docker_on))

local TCP_width = content:match('leftpanewid=(.-)\n')
local dockheight_l = content:match('dockheight_l=(.-)\n') -- if left docker is open  https://forums.cockos.com/showpost.php?p=1991096&postcount=11

-- https://forum.cockos.com/showpost.php?p=2303259&postcount=4 thanks to IXix
-- https://forum.cockos.com/showthread.php?t=238128

	if left_docker_on then TCP_width = TCP_width + dockheight_l end -- shifted righwards TCP right edge

--Msg(dockheight_l)
--Msg(TCP_width)

return TCP_width

end



function Re_Store_Windows_Props_By_Names1(names_t, t) -- relies on Esc() function
-- works if screenset was changed because in this case window nandles will change as well while names won't
-- doesn't support docked windows since they're not top level and won't be detected by JS_Window_ArrayAllTop()
-- https://forums.cockos.com/showthread.php?p=2538915
-- https://forum.cockos.com/showthread.php?t=249817
	if not t then
	local main_HWND = r.GetMainHwnd()
	local array = r.new_array({}, 1023)
	r.JS_Window_ArrayAllTop(array) -- docked windows are not top level hence won't be listed
	local array = array.table()
	local t = {}
		for k, address in ipairs(array) do -- duplicate names with different hwnd may occur, such as FX chain windows, so the number of windows which satisfy the search may be greater than the number of visible windows
		local hwnd = r.JS_Window_HandleFromAddress(address)
		local title = r.JS_Window_GetTitle(hwnd)
			for _, name in pairs(names_t) do
				if title:match(Esc(name)) and r.JS_Window_IsVisible(hwnd) -- FX chain windows may happen to be visible even when closed, there're no fx and the object is hidden in Arrange, fx floating window are only visible when floating
				then
				local retval, lt, tp, rt, bt = r.JS_Window_GetRect(hwnd)
				local w, h = rt-lt, r.GetOS():match('OSX') and tp-bt or bt-tp -- isn't necessary if r.JS_Window_Move() is used for restoration rather than r.JS_Window_SetPosition()
				t[#t+1] = {tit=title, lt=lt, tp=tp, w=w, h=h, foregrnd=r.JS_Window_GetForeground()==hwnd}
				end
			end
		end
	return t
	else
		for _, wnd in ipairs(t) do
		local hwnd = r.JS_Window_Find(wnd.tit, true) -- exact true
		local dock_idx, isFloatingDocker = r.DockIsChildOfDock(hwnd)
			if dock_idx == -1 then -- not docked to prevent undocking window in which case it'll become invisible
			r.JS_Window_Move(hwnd, wnd.lt, wnd.tp)
		--  OR
		--	r.JS_Window_SetPosition(hwnd, wnd.lt, wnd.tp, wnd.w, wnd.h) -- ZOrder, flags are ommitted
				--	if wnd.focus then r.JS_Window_SetFocus(hwnd) end -- focus is not stored above but it's more granular and targets elements in the foreground window which isn't really necessary
				if wnd.foregrnd then r.JS_Window_SetForeground(hwnd) end -- only restored if the script is run via a shortcut because clicking changes foreground window, r.JS_Window_SetZOrder() should be avoided as it's global to the OS
			end
		end
	end
end



function Re_Store_Windows_Props_By_Names2(names_t, t)
-- works if screenset was changed because in this case window nandles will change as well while names won't
-- supports docked windows
-- https://forums.cockos.com/showthread.php?p=2538915
-- https://forum.cockos.com/showthread.php?t=249817
	if not t then
	local main_HWND = r.GetMainHwnd()
--	local name_t = {'FX:','- Track','- Item'}
	local t = {}
	for k, name in pairs(names_t) do
	local array = r.new_array({}, 1023)
	r.JS_Window_ArrayFind(name, false, array) -- exact false
	local array = array.table()
		for k, address in ipairs(array) do -- duplicate names with different hwnd may occur, such as FX chain windows, so the number of windows which satisfy the search may be greater than the number of visible windows
		local hwnd = r.JS_Window_HandleFromAddress(address)
			if r.JS_Window_IsVisible(hwnd) -- FX chain windows may happen to be visible even when closed, there're no fx and the object is hidden in Arrange, fx floating window are only visible when floating
			local title = r.JS_Window_GetTitle(hwnd)
			local retval, lt, tp, rt, bt = r.JS_Window_GetRect(hwnd)
			local w, h = rt-lt, r.GetOS():match('OSX') and tp-bt or bt-tp -- isn't necessary if r.JS_Window_Move() is used for restoration rather than r.JS_Window_SetPosition()
			t[#t+1] = {tit=title, lt=lt, tp=tp, w=w, h=h, focus=r.JS_Window_GetForeground()==hwnd}
			end
		end
	end
	return t
	else
		for _, wnd in ipairs(t) do
		local hwnd = r.JS_Window_Find(wnd.tit, true) -- exact true
		local dock_idx, isFloatingDocker = r.DockIsChildOfDock(hwnd)
			if dock_idx == -1 then -- not docked to prevent undocking window in which case it'll become invisible
			r.JS_Window_Move(hwnd, wnd.lt, wnd.tp)
		--  OR
		--	r.JS_Window_SetPosition(hwnd, wnd.lt, wnd.tp, wnd.w, wnd.h) -- ZOrder, flags are omitted
				--	if wnd.focus then r.JS_Window_SetFocus(hwnd) end -- focus is not stored above but it's more granular and targets elements in the foreground window which isn't really necessary
				if wnd.foregrnd then r.JS_Window_SetForeground(hwnd) end -- only restored if the script is run via a shortcut because clicking changes foreground window, r.JS_Window_SetZOrder() should be avoided as it's global to the OS
			end
		end
	end
end



function Re_Store_Windows_Props_By_Names_And_Handles1(names_t, t) -- relies on Esc() function
-- store by names, restore by handles
-- works if screenset was NOT changed because in this case window handles won't change and can be used to restore windows
-- doesn't support docked windows since they're not top level and won't be detected by JS_Window_ArrayAllTop()
-- https://forums.cockos.com/showthread.php?p=2538915
-- https://forum.cockos.com/showthread.php?t=249817
	if not t then
	local main_HWND = r.GetMainHwnd()
	local array = r.new_array({}, 1023)
	r.JS_Window_ArrayAllTop(array) -- docked windows are not top level hence won't be listed
	local array = array.table()
	local t = {}
		for k, address in ipairs(array) do -- duplicate names with different hwnd may occur, such as FX chain windows, so the number of windows which satisfy the search may be greater than the number of visible windows
		local hwnd = r.JS_Window_HandleFromAddress(address)
		local title = r.JS_Window_GetTitle(hwnd)
			for _, name in pairs(names_t) do
				if title:match(Esc(name)) and r.JS_Window_IsVisible(hwnd) -- FX chain windows may happen to be visible even when closed, there're no fx and the object is hidden in Arrange, fx floating window are only visible when floating
				then
				local retval, lt, tp, rt, bt = r.JS_Window_GetRect(hwnd)
				local w, h = rt-lt, r.GetOS():match('OSX') and tp-bt or bt-tp -- isn't necessary if r.JS_Window_Move() is used for restoration rather than r.JS_Window_SetPosition()
				t[#t+1] = {id=hwnd, lt=lt, tp=tp, w=w, h=h, foregrnd=r.JS_Window_GetForeground()==hwnd}
				end
			end
		end
	return t
	else
		for _, wnd in ipairs(t) do
		local dock_idx, isFloatingDocker = r.DockIsChildOfDock(wnd.id)
			if dock_idx == -1 then -- not docked to prevent undocking window in which case it'll become invisible
			r.JS_Window_Move(wnd.id, wnd.lt, wnd.tp)
		--  OR
		--	r.JS_Window_SetPosition(wnd.id, wnd.lt, wnd.tp, wnd.w, wnd.h) -- ZOrder, flags are ommitted
				--	if wnd.focus then r.JS_Window_SetFocus(hwnd) end -- focus is not stored above but it's more granular and targets elements in the foreground window which isn't really necessary
				if wnd.foregrnd then r.JS_Window_SetForeground(hwnd) end -- only restored if the script is run via a shortcut because clicking changes foreground window, r.JS_Window_SetZOrder() should be avoided as it's global to the OS
			end
		end
	end
end



function Re_Store_Windows_Props_By_Names_And_Handles2(names_t, t)
-- store by names, restore by handles
-- works if screenset was NOT changed because in this case window handles won't change and can be used to restore windows
-- supports docked windows
-- https://forums.cockos.com/showthread.php?p=2538915
-- https://forum.cockos.com/showthread.php?t=249817
	if not t then
	local main_HWND = r.GetMainHwnd()
--	local name_t = {'FX:','- Track','- Item'}
	local t = {}
	for k, name in pairs(names_t) do
	local array = r.new_array({}, 1023) -- 1023 array length
	r.JS_Window_ArrayFind(name, false, array) -- exact false
	local array = array.table()
		for k, address in ipairs(array) do -- duplicate names with different hwnd may occur, such as FX chain windows, so the number of windows which satisfy the search may be greater than the number of visible windows
		local hwnd = r.JS_Window_HandleFromAddress(address)
			if r.JS_Window_IsVisible(hwnd) -- FX chain windows may happen to be visible even when closed, there're no fx and the object is hidden in Arrange, fx floating window are only visible when floating
			local retval, lt, tp, rt, bt = r.JS_Window_GetRect(hwnd)
			local w, h = rt-lt, r.GetOS():match('OSX') and tp-bt or bt-tp -- isn't necessary if r.JS_Window_Move() is used for restoration rather than r.JS_Window_SetPosition()
			t[#t+1] = {id=hwnd, lt=lt, tp=tp, w=w, h=h, foregrnd=r.JS_Window_GetForeground()==hwnd}
			end
		end
	end
	return t
	else
		for _, wnd in ipairs(t) do
		local dock_idx, isFloatingDocker = r.DockIsChildOfDock(wnd.id)
			if dock_idx == -1 then -- not docked to prevent undocking window in which case it'll become invisible
			r.JS_Window_Move(wnd.id, wnd.lt, wnd.tp)
		--  OR
		--	r.JS_Window_SetPosition(wnd.id, wnd.lt, wnd.tp, wnd.w, wnd.h) -- ZOrder, flags are omitted
				--	if wnd.focus then r.JS_Window_SetFocus(hwnd) end -- focus is not stored above but it's more granular and targets elements in the foreground window which isn't really necessary
				if wnd.foregrnd then r.JS_Window_SetForeground(hwnd) end -- only restored if the script is run via a shortcut because clicking changes foreground window, r.JS_Window_SetZOrder() should be avoided as it's global to the OS
			end
		end
	end
end



function Is_Window_Visible1(hwnd)
-- takes advantage of the fact that the following functions don't affect invisible windows
-- docked windows will be considered invisible because focus and foreground status can't be applied to them, they're children windows
-- r.JS_Window_IsVisible() isn't suitable since it may return true for invisible (closed) windows as well, such as FX chain;
-- may not be sutable when many windows are open because it changes foreground window or focus
-- OK if windows will get closed anyway
-- r.JS_Window_GetForeground() is safer when the window is surely closed because it doesn't remove focus from children of the currently focused window, e.g. list entry active status
--[-[
local ForeGrnd = r.JS_Window_GetForeground
local foregrnd = ForeGrnd()
	if foregrnd == hwnd then return true end
r.JS_Window_SetForeground(hwnd)
local foregrnd = ForeGrnd()
return foregrnd == hwnd
--]]
--[[ OR
Msg(r.JS_Window_GetTitle(hwnd))
local Focus = r.JS_Window_GetFocus
local focus = Focus()
	if focus == hwnd then return true end
r.JS_Window_SetFocus(hwnd)
local focus = Focus()
return focus == hwnd
--]]
end



function Is_Window_Visible2(handle)
-- OR BR_Win32_IsWindowVisible()
-- handle arg is the target window handle, either a string created with BR_Win32_HwndToString()
-- or light user data, i.e. direct handle
-- because it can be stored in extended state
-- and retrieved later to evaluate new state of the window it points at
-- https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlonga
-- https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles
local wnd = type(handle) == 'string' and r.BR_Win32_StringToHwnd(string_handle) or handle
local long = r.BR_Win32_GetWindowLong(wnd, -16) -- -16 GWL_STYLE // 0x10000000L WS_VISIBLE
return long&0x10000000 == 0x10000000 -- true if visible, false if not
end



function Exclude_Visible_Windows(t) -- t stems from Re_Store_Windows_Props_By_Names[_And_Handles]() functions
	for i=#t,1,-1 do
	local wnd = t[i]
	local hwnd = r.JS_Window_Find(wnd.tit, true) -- exact true
		if Is_Window_Visible1(hwnd) then
		table.remove(t,i)
		end
	end
end


function Move_Window_To_Another_Dock(wnd_id, new_pos, cur_pos)
-- same as the native 'Docker: Show in bottom/top/left/right of main window'
-- only that the action affects explicitly selected window;
-- wnd_id is window identifier string found in reaper.ini, see table keys below,
-- if routing, add digit without space: routing1 - routing matrix;
-- routing2 - group matrix; routing3 - track wiring;
-- routing4 - region render matrix -- non-toggle
-- cur_pos and new_pos args are integer: 0 - bottom, 1 - left, 2 - top, 3 - right, 4 - floating
-- cur_pos is optional, if passed, docker position will only be changed of the window's current pos matches cur_pos value, otherwise position will be changed regardless of the current one
-- also to figure out how to toggle midi editor visibility
-- some info on docks https://forum.cockos.com/showthread.php?t=207081
-- https://github.com/Buy-One/Dox/blob/main/reaper.ini%20toolbars%20and%20dockers

	if not new_pos or not tonumber(new_pos)
	or tonumber(new_pos) < 0 or tonumber(new_pos) > 4 then
	return end

	if cur_pos and (not tonumber(new_pos)
	or tonumber(new_pos) < 0 or tonumber(new_pos) > 4) then
	return end

local dockermode = r.GetConfigWantsDock(wnd_id) -- get dockermode the window is currently assigned to, there're 16 dockermodes in the range of 0-15 each of which can be assigned one of 4 positons (left, top, right, bottom)

	if cur_pos and r.DockGetPosition(dockermode) ~= cur_pos then return end -- compare the position the dockermode belongs to with the cur_pos value if any

-- in actual Routing menu order
local routing = {40251, -- View: Show routing matrix window ('Routing Matrix')
42031, -- View: Show track wiring diagram ('Track Wiring Diagram')
40768, -- View: Show track grouping matrix window ('Grouping Matrix')
41888 -- View: Show region render matrix window ('Region Render Matrix') -- non-toggle
}

local function is_region_render_vis(routing)
	for _, commID in ipairs(routing) do
		if r.GetToggleCommandStateEx(0,commID) == 1
		then -- one of the other 3 windows which have toggle state is visible
		return end -- so region render matrix visibility is false
	end
-- if the function didn't exit early, all windows with toggle action are closed
-- 'View: Show region render matrix window' is not a toggle, so evaluate that via reaper.ini
	for line in io.lines(r.get_ini_file()) do
		if line:match('routingwnd_vis') and line:sub(-1) == '1' then
		-- the key has value 1 when region render matrix is open as well
		return true
		end
	end
end

local t = {transport = 40259, mixer = 40078, actions = 40605,
projbay_0 = 41157, projbay_1 = 41628, projbay_2 = 41629,
projbay_3 = 41630, projbay_4 = 41631, projbay_5 = 41632,
projbay_6 = 41633, projbay_7 = 41634, --routing = rout,
regmgr = 40326, explorer = 50124, trackmgr = 40906, grpmgr = 40327,
bigclock = 40378, video = 50125, perf = 40240, navigator = 40268,
vkb = 40377, fadeedit = 41827, undo = 40072, fxbrowser = 40271,
itemprops = 41589, midiedit = '', ['toolbar:1'] = 41679,
['toolbar:2'] = 41680, ['toolbar:3'] = 41681, ['toolbar:4'] = 41682,
['toolbar:5'] = 41683, ['toolbar:6'] = 41684, ['toolbar:7'] = 41685,
['toolbar:8'] = 41686, ['toolbar:9'] = 41936, ['toolbar:10'] = 41937,
['toolbar:11'] = 41938, ['toolbar:12'] = 41939, ['toolbar:13'] = 41940,
['toolbar:14'] = 41941, ['toolbar:15'] = 41942, ['toolbar:16'] = 41943,
['toolbar:17'] = 42404, -- MX toolbar // toolbars don't work, the numbers in their window titles are likely to not correspond to their section numbers in reaper.ini
SWSAutoColor = '_SWSAUTOCOLOR_OPEN', -- SWS: Open auto color/icon/layout window ('Auto Color/Icon/Layout')
['BR - ContextualToolbars WndPos'] = '_BR_CONTEXTUAL_TOOLBARS_PREF', -- SWS/BR: Contextual toolbars... ('Contextual toolbars')
SnMCyclaction = '_S&M_CYCLEDITOR', -- SWS/S&M: Open/close Cycle Action editor ('Cycle Actions') // doesn't remember section selection BUT all 3 actions toggle
SnMFind = '_S&M_SHOWFIND', -- SWS/S&M: Find ('Find')
FNGGroove = '_FNG_GROOVE_TOOL', -- SWS/FNG: Show groove tool ('Groove')
SnMLiveConfigs = '_S&M_SHOWMIDILIVE', -- SWS/S&M: Open/close Live Configs window ('Live Config')
SnMLiveConfigMonitor1 = '_S&M_OPEN_LIVECFG_MONITOR1', -- SWS/S&M: Live Config #1 - Open/close monitoring window
SnMLiveConfigMonitor2 = '_S&M_OPEN_LIVECFG_MONITOR2', -- SWS/S&M: Live Config #2 - Open/close monitoring window
SnMLiveConfigMonitor3 = '_S&M_OPEN_LIVECFG_MONITOR3', -- SWS/S&M: Live Config #3 - Open/close monitoring window
SnMLiveConfigMonitor4 = '_S&M_OPEN_LIVECFG_MONITOR4', -- SWS/S&M: Live Config #4 - Open/close monitoring window
SnMLiveConfigMonitor5 = '_S&M_OPEN_LIVECFG_MONITOR5', -- SWS/S&M: Live Config #5 - Open/close monitoring window
SnMLiveConfigMonitor6 = '_S&M_OPEN_LIVECFG_MONITOR6', -- SWS/S&M: Live Config #6 - Open/close monitoring window
SnMLiveConfigMonitor7 = '_S&M_OPEN_LIVECFG_MONITOR7', -- SWS/S&M: Live Config #7 - Open/close monitoring window
SnMLiveConfigMonitor8 = '_S&M_OPEN_LIVECFG_MONITOR8', -- SWS/S&M: Live Config #8 - Open/close monitoring window
['BR - AnalyzeLoudness WndPos'] = '_BR_ANALAYZE_LOUDNESS_DLG', -- SWS/BR: Analyze loudness... ('Loudness')
SWSMarkerList = '_SWSMARKERLIST1', -- SWS: Open marker list ('Marker List')
SnMNotesHelp = '_S&M_SHOW_NOTES_VIEW', -- SWS/S&M: Open/close Notes window ('Notes') // does remember notes type selection so other 11 actions will likely be redundant
SWSProjectList = '_SWS_PROJLIST_OPEN', -- SWS: Open project list ('Project List')
ReaConsole = '_SWSCONSOLE', -- SWS: Open console ('ReaConsole')
SnMRgnPlaylist = '_S&M_SHOW_RGN_PLAYLIST', -- SWS/S&M: Open/close Region Playlist window ('Region Playlist')
SnMResources = '_S&M_SHOW_RESOURCES_VIEW', -- SWS/S&M: Open/close Resources window ('Resources') // does remember resource type selection so other 7 actions will likely be redundant
SWSSnapshots = '_SWSSNAPSHOT_OPEN' -- SWS: Open snapshots window ('Snapshots') // (caused redraw problem)
}

local function wrapper(func,...)
-- https://forums.cockos.com/showthread.php?t=218805 Lokasenna
local t = {...}
return function() func(table.unpack(t)) end
end

--[[ WORKS isn't sutable for Region Render matrix window
local function wait_and_reopen(commandID)
	if r.GetToggleCommandStateEx(0,commandID) == 1 then
	r.defer(wrapper(wait_and_reopen, commandID))
	else
	r.Main_OnCommand(commandID, 0) -- re-open /// must be inside defer loop, for some reason when the defer loop stops commandID  is not accessible to Main_OnCommand() function outside
	end
end
--]]
--[-[ WORKS
local function wait_and_reopen(commandID)
	if commandID ~= 41888 and r.GetToggleCommandStateEx(0,commandID) == 0 then
	r.Main_OnCommand(commandID, 0) -- re-open // must be inside defer loop, for some reason when the defer loop stops commandID is not accessible to Main_OnCommand() function outside
	return
	elseif commandID == 41888 then
		for line in io.lines(r.get_ini_file()) do
			if line:match('routingwnd_vis') and
			-- the key has value 0 when region render matrix is closed as well
			line:sub(-1) == '0' then
			r.Main_OnCommand(commandID, 0) return end
		end
	end
r.defer(wrapper(wait_and_reopen, commandID))
end
--]]

-- extract index if routing and select command ID
local commandID = wnd_id:match('routing') and routing[wnd_id:sub(-1)+0] or r.NamedCommandLookup(t[wnd_id]) -- accounting for SWS ext command IDs
local vis = commandID ~= 41888 and r.GetToggleCommandStateEx(0,commandID) == 1
or commandID == 41888 and is_region_render_vis(routing)

	if not vis then return end -- only update visible windows

local wnd_id = wnd_id:match('routing') and 'routing' or wnd_id

	for i = 0, 15 do -- there're 16 dockermode indices in total
		if r.DockGetPosition(i) == new_pos then -- find dockermode associated with the desired position
		-- in reaper.ini it's e.g. dockermode5=0;
		-- update position of dockermode to which the window is assigned in reaper.ini
		-- in [REAPERdockpref] section
		r.Dock_UpdateDockID(wnd_id, i)
	--	r.UpdateArrange() -- doesn't work to visually update window position
		-- must be refreshed for the change to become visible, that is its visibility toggled
		-- THESE r.DockWindowRefresh() AND r.DockWindowRefreshForHWND(wnd_id) DON'T WORK FOR REFRESHING
			if commandID ~= 41888 and r.GetToggleCommandStateEx(0,commandID) == 1
			or commandID == 41888 and is_region_render_vis(routing)
			then -- visible // will work when updating dock position of a window regardless of visibility if 'if not vis then' condition isn't used above, in which case only if a window is visible it will be reloaded, the rest will be moved in the background
			r.Main_OnCommand(commandID, 0) -- close
			wait_and_reopen(commandID) -- toggle state is updated slower than the function runs hence the need to wait and only then re-open, the same is true for routingwnd_vis value update in reaper.ini
		-- OR
		--	r.defer(wrapper(wait_and_reopen, commandID)) -- re-open
			end
		break end
	end
end



function JS_Window_IsVisible(hwnd)
-- visibility functions JS_Window_IsVisible() and BR_Win32_IsWindowVisible() aren't suitable for visibility validation of windows in multi-window dockers because these return false if a docked window is inactive, but they're accurate if there's only one window in a docker
local parent, parent_tit
local toggle_state = r.GetToggleCommandStateEx
local docker = toggle_state(0, 40279) == 1 -- 'View: Show docker'
	for i = 1, 2 do
	parent = r.JS_Window_GetParent(hwnd)
	parent_tit = r.JS_Window_GetTitle(parent)
		-- floating dockers
		if parent_tit == 'Toolbar Docker' and toggle_state(0, 41084) == 1 -- 'Toolbar: Show/hide toolbar docker'
		or parent_tit == 'Docker' and docker -- regular docker
		or parent_tit:match('(docked)') and r.JS_Window_IsVisible(hwnd) -- single window in a floating toolbar / regular docker
		then return hwnd end
	hwnd = parent -- update for the next cycle
	end
	-- if floating docker wasn't found, search docker attached to the main window
	-- it cannot be searched in the loop above because being a child of the floating docker window it precedes it in the parent search and would cause loop exit before the floating docker window title could be evaluated
	if parent_tit == 'REAPER_dock' and docker then return hwnd end

end


-- r.BR_Win32_SendMessage(identifier hwnd, integer msg, integer lParam, integer wParam)
-- https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues
-- https://learn.microsoft.com/en-us/windows/win32/controls/bumper-scroll-bars-reference-messages
-- https://learn.microsoft.com/en-us/windows/win32/controls/bumper-scroll-bars-reference-notifications
-- https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll
-- https://learn.microsoft.com/en-us/windows/win32/controls/about-scroll-bars
-- https://learn.microsoft.com/en-us/windows/win32/controls/sbm-setpos
-- https://ecs.syr.edu/faculty/fawcett/Handouts/CoreTechnologies/windowsprogramming/WinUser.h
-- https://github.com/justinfrankel/snapease/blob/master/WDL/swell/swell-types.h
-- https://github.com/justinfrankel/WDL/blob/main/WDL/swell/swell-types.h
-- https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/Controls/scroll-bars.md


function Find_Window_SWS(wnd_name, want_main_children)
-- THE FUNCTION IS CASE-AGNOSTIC
-- finds main window children, their siblings, their grandchildren and their siblings, including docked ones, floating windows and probably their children as well
-- want_main_children is boolean to search for internal or non-dockable main window children and for their children regardless of the dock being open, the dock condition in the routine is only useful for validating visibility of windows which can be docked

-- 1. search floating toolbars with BR_Win32_FindWindowEx(), including docked
-- https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtexta#return-value
-- 2. search floating docker with BR_Win32_FindWindowEx() using 2 title options, and loop to find children and siblings
-- 3. search dockers attached to the main window with r.GetMainHwnd() and loop to find children and siblings

	local function Find_Win(title)
	return r.BR_Win32_FindWindowEx('0', '0', '', title, false, true) -- hwndParent, hwndChildAfter '0', className empty string, searchClass false, searchName true // does find single windows and single windows docked in floating dockers with '(docked)' appendage in the title, doesn't find children windows, such as docked in multi-tab docks and single docked in dockers attached to the main window, hence the actual function Find_Window_SWS()
	end

	local function get_wnd_siblings(hwnd, val, wnd_name)
	-- val = 2 next; 3 prev doesn't work if hwnd belongs
	-- to the very 1st child returned by BR_Win32_GetWindow() with val 5, which seems to always be the case
	local Get_Win = r.BR_Win32_GetWindow
	-- evaluate found window
	local ret, tit = r.BR_Win32_GetWindowText(hwnd)
		if tit == wnd_name then return hwnd
		elseif tit == 'REAPER_dock' then -- search children of the found window
		-- dock windows attached to the main window have 'REAPER_dock' title and can have many children, each of which is a sibling to others, if nothing is attached the child name is 'Custom1', 15 'REAPER_dock' windows are siblings to each other
		local child = Get_Win(hwnd, 5) -- get child 5, GW_CHILD
		local hwnd = get_wnd_siblings(child, val, wnd_name) -- recursive search for child siblings
			if hwnd then return hwnd end
		end
	local sibl = Get_Win(hwnd, 2) -- get next sibling 2, GW_HWNDNEXT
		if sibl then return get_wnd_siblings(sibl, val, wnd_name) -- proceed with recursive search for dock siblings and their children
		else return end
	end

	local function search_floating_docker(docker_hwnd, docker_open, wnd_name) -- docker_hwnd is docker window handle, docker_open is boolean, wnd_name is a string of the sought window name
		if docker_hwnd and docker_open then -- windows can be found in closed dockers hence toggle state evaluation
	-- https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindow
		local child = r.BR_Win32_GetWindow(docker_hwnd, 5) -- get child 5, GW_CHILD // 1st docker child is the last added window
		local ret, tit = r.BR_Win32_GetWindowText(child) -- floating docker window 1st child name is 'REAPER_dock', attached windows are 'REAPER_dock' child and/or the child's siblings
		return get_wnd_siblings(child, 2, wnd_name) -- go recursive enumerating child siblings; sibling 2 (next) - GW_HWNDNEXT, 3 (previous) - GW_HWNDPREV, 3 doesn't seem to work regardless of the 1st child position in the docker, probably because BR_Win32_GetWindow with val 5 always retrieves the very 1st child, so all the rest are next
		end
	end

-- search for floating window
-- won't be found if closed
local wnd = Find_Win(wnd_name)

	if wnd then return wnd end -- if not found the function will continue

-- docker toggle states are used for visibility validation instead of extension functions due to unreliabiliy of the latter which return false in multi-window docker scenarios when a window is inactive
local tb_dock = r.GetToggleCommandStateEx(0, 41084) == 1 -- 'Toolbar: Show/hide toolbar docker' // non-toolbar windows can be attached to a floating toolbar docker as well
local dock = r.GetToggleCommandStateEx(0, 40279) == 1 -- 'View: Show docker'

-- search for a floating docker with one attached window // toolbars can be attached to a regular floating docker and regular windows can be attached to a floating toolbar docker
-- !!!! if in the floating docker the window name differs from the original apart from the '(docked)' prefix
-- here the alternative name must be passed in full rather than in concatenated form
local docker = Find_Win(wnd_name..' (docked)') -- when a single window is attached to a floating docker its title is 'Name (docked)' with '(docked)' added regardless of whether this a regular docker or a toolbar docker
wnd = search_floating_docker(docker, dock, wnd_name)
	if wnd and (r.JS_Window_IsVisible and r.JS_Window_IsVisible(wnd) or dock) then return wnd -- JS_Window_IsVisible() isn't suitable for multi-window dockers because it returns false when a window is inactive, but it works reliably when floating docker only has one attached window which cannot be inactive
	end -- if not found the function will continue

-- search toolbar docker with multiple attached windows which can house regular windows
local docker = Find_Win('Toolbar Docker') -- when toolbars are collected in the floating toolbar docker to begin with and there're more than 1, its title is 'Toolbar Docker', non-toolbar windows can be attached to a floating toolbar docker as well
wnd = search_floating_docker(docker, tb_dock, wnd_name)
	if wnd then return wnd end -- if not found the function will continue

-- search floating docker with multiple attached windows which can house toolbars
local docker = Find_Win('Docker') -- when a docker attached to the main window is detached from it by toggling 'Attach docker to the main window' and there're several windows in it, the floating docker title is 'Docker'
wnd = search_floating_docker(docker, dock, wnd_name)
	if wnd then return wnd end -- if not found the function will continue

-- search docks attached to the main window
	if dock and not want_main_children or want_main_children then -- windows can be found in closed dockers hence toggle state evaluation
	local main = r.GetMainHwnd() -- the name of the dock window is 'REAPER_dock' of which there're 15 all being children of the main window and siblings of each other, attached windows are dock children and are siblings of each other
	local child = r.BR_Win32_GetWindow(main, 5) -- get child 5, GW_CHILD // 1st docker child is the last added window
	return get_wnd_siblings(child, 2, wnd_name)
	end

end



function Get_Child_Windows_JS1(parent_hwnd) -- see alternative method of collecting chilren in Get_Window_And_Children_JS below
local retval, list = r.JS_Window_ListAllChild(parent_hwnd)
local t = {}
	for address in list:gmatch('0x%x+') do
	local wnd = r.JS_Window_HandleFromAddress(address)
	t[#t+1] = {child=wnd, title=r.JS_Window_GetTitle(wnd)}
	end
return #t > 0 and t
end


function Get_Child_Windows_JS2(parent_name, want_exact)  -- see alternative method of collecting chilren in Get_Window_And_Children_JS below
local parent_wnd = r.JS_Window_Find(parent_name, want_exact)
	if parent_wnd then
	local retval, list = r.JS_Window_ListAllChild(parent_hwnd)
	local t = {}
		for address in list:gmatch('0x%x+') do
		local wnd = r.JS_Window_HandleFromAddress(address)
		t[#t+1] = {child=wnd, title=r.JS_Window_GetTitle(wnd)}
		end
	return #t > 0 and t
	end
end



function Get_Window_And_Children_JS(wnd_title, want_exact_title)
-- want_exact_title is boolean

local want_exact_title = want_exact_title or false -- the argument in the function doesn't support nil

local Find = r.JS_Window_Find
-- more reliable if want_exact_title is true to ignore string appearances
-- for example in script/action names in the Action list
local wnd = not want_exact_title and Find(wnd_title, want_exact_title)
or want_exact_title and Find(wnd_title, want_exact_title) or (Find(wnd_title..' (docked)', want_exact_title) )
local child = wnd and r.JS_Window_GetRelated(wnd, 'CHILD')
local child_t = {}
	if child then
		repeat
		local title = r.JS_Window_GetTitle(child)
		child_t[title] = child
	--[[ OR, depending on the design
		child_t[#child_t+1] = {title=title, child=child}
	]]
		child = r.JS_Window_GetRelated(child, 'NEXT')
		until not child
	end

return wnd, child_t

end



function Get_Child_Windows_SWS(parent_wnd)
-- https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindow
-- the function doesn't cover grandchildren
-- once window handles have been collected
-- they can be analyzed further for presence of certain string
-- using BR_Win32_GetWindowText()

	if not parent_wnd then return end

local child = r.BR_Win32_GetWindow(parent_wnd, 5) -- 5 = GW_CHILD, returns 1st child
	if not child then return end -- no children
local i, t = 0, {}
	repeat
		if child then
		local ret, txt = r.BR_Win32_GetWindowText(child)
		t[#t+1] = {child=child, title=txt}
	--[[ -- OR, depending on the design
		t[txt] = child
	]]
		end
	child = r.BR_Win32_GetWindow(child, 2) -- 2 = GW_HWNDNEXT // get next sibling of each next found child window advancing until no child is found
	i=i+1
	until not child
return #t > 0 and t
end



function Get_All_Parent_Windows(wnd)
local wnd = wnd
	repeat
	wnd = r.BR_Win32_GetParent(wnd)
	local retval, title = r.BR_Win32_GetWindowText(wnd)
	until not wnd
end



function Get_Top_Parent_Window(wnd, ignore_dock)
-- ignore_dock is boolean to ignore internal 'REAPER_dock' window
-- get window top parent window
-- the one inclding the window title,
-- excluding REAPER main window,
-- useful for windows with many child windows
-- which may be parents to one another
-- in which case a single instance of BR_Win32_GetParent won't be enough
-- as is the case with track routing window
local wnd = wnd
	repeat
	local parent = r.BR_Win32_GetParent(wnd)
	local retval, title = r.BR_Win32_GetWindowText(parent)
--Msg('par handle', wnd, 'par title', title)
		if title:match('REAPER') and
		(ignore_dock and title ~= 'REAPER_dock' or not ignore_dock)
		then return wnd -- if REAPER main window, return the previous window
		else
		wnd = parent
		end
	until not parent
end



function Is_Parent_Window(hwnd, parent_hwnd) -- this one wasn't properly tested
--retval, text = reaper.BR_Win32_GetWindowText(hwnd)
--r.ShowConsoleMsg(tostring(text)..'\n')
local hwnd = hwnd
local last
	repeat
	hwnd = r.BR_Win32_GetParent(hwnd)
--retval, text = reaper.BR_Win32_GetWindowText(hwnd)
--r.ShowConsoleMsg(tostring(text)..'\n')
		if hwnd == parent_hwnd then return parent_hwnd 
		else
		last = last ~= hwnd and hwnd or last
		end
	until not hwnd or hwnd == last
end




function Is_Window_Docked(wnd)
-- includes floating docker as well
local wnd = wnd
	repeat
	wnd = r.BR_Win32_GetParent(wnd)	
	local retval, title = r.BR_Win32_GetWindowText(wnd)
		if title == 'REAPER_dock' then return true end
	until not wnd
end



function Traverse_List1(list_wnd, col_cnt)
-- go over columns for each row
-- hidden colums are still accessible to the functions
-- but only traversing the visible ones may not yield
-- the positive result because the loop
-- won't reach the correct one and the item won't be found
-- so all columns must be traversed

	if not list_wnd then return end

local col_cnt = col_cnt or 1 -- only traverse 1st column if arg isn't provided
local itm_cnt = r.JS_ListView_GetItemCount(list_wnd) -- number of rows

	if itm_cnt == 0 then return end
	
local row_idx = 0
	repeat
	local col_idx, text = 0
		repeat
		text = r.JS_ListView_GetItemText(list_wnd, row_idx, col_idx)
			if text == item_text then return row_idx end
		col_idx=col_idx+1
		until col_idx == col_cnt
	row_idx=row_idx+1
	until row_idx == itm_cnt or not text

end
	

function Traverse_List2(list_wnd, col_cnt)
-- go over rows for each column
-- hidden colums are still accessible to the functions
-- but only traversing the visible ones may not yield
-- the positive result because the loop
-- won't reach the correct one and the item won't be found
-- so all columns must be traversed

	if not list_wnd then return end

local col_cnt = col_cnt or 1 -- only traverse 1st column if arg isn't provided
local itm_cnt = r.JS_ListView_GetItemCount(list_wnd) -- number of rows

	if itm_cnt == 0 then return end
	
local col_idx = 0
	repeat
	local row_idx, text = 0
		repeat
		text = r.JS_ListView_GetItemText(list_wnd, row_idx, col_idx)
			if text == item_text then return row_idx end
		row_idx=row_idx+1
		until row_idx == itm_cnt or not text
	col_idx=col_idx+1
	until col_idx == col_cnt

end



function GetSet_SWS_Notes_Wnd_Scroll_Pos(search_term, scroll_dir, notes_wnd, scroll_pos)
-- Applies to SWS Notes window
-- works successfully with Track Notes
-- search_term is any character sure to be found in the Notes or single empty space
-- scroll_dir is string, either 'v', 'SB_VERT' or 'VERT' for vertical scrollbar
-- and 'h', 'SB_HORZ' or 'HORZ' for horizontal
-- notes_wnd, scroll_pos are values returned at the Get stage and are only relevant at the Set stage
-- arg 1 is only relevant for Get stage, arg 2 for both Get and Set stages, 3-4 only for the Set stage;
-- meant to store and restore scroll position
-- can be repurposed for any other window
-- for general reference:
-- https://github.com/reaper-oss/sws/blob/master/SnM/SnM_Notes.cpp
-- https://github.com/reaper-oss/sws/blob/master/SnM/SnM_Notes.h

	if not r.JS_Window_Find then return end

	if not notes_wnd then -- Get
	local parent_wnd
		for k, title in ipairs({'Notes', 'Notes (docked)'}) do -- the names cover docked and undocked wrapper window
		parent_wnd = r.JS_Window_Find(title, true) -- exact true
			if parent_wnd then break end
		end
		if parent_wnd then
		local notes_wnd = r.JS_Window_FindChild(parent_wnd, search_term, false) -- exact false, Track notes window containing text can be found with blank space or 0 or colon (:) which is very likely to be included in the Notes (depending on the content), the entire Notes content is returned as Track notes child window title with JS_Window_GetTitle(), if not found there're no Notes
			if notes_wnd then
			local retval, top_pos, pageSize, min_px, max_px, scroll_pos = r.JS_Window_GetScrollInfo(notes_wnd, scroll_dir) -- the shorter the window the greater the bottomost scroll_pos value // when window is a list (to be handled with functions JS_ListView), min and max are the lowest and highest 0-based row index, the scroll position is the number of hidden rows at the top
			return notes_wnd, scroll_pos
			end
		end
	else -- Set
	r.JS_Window_SetScrollPos(notes_wnd, scroll_dir, scroll_pos)
	end

end
--[[ USE:
local notes_wnd, scroll_pos = GetSet_SWS_Notes_Wnd_Scroll_Pos(search_term, scroll_dir) -- store
-- DO STAFF WHICH CHANGES SCROLL POSITION
GetSet_SWS_Notes_Wnd_Scroll_Pos(search_term, scroll_dir, notes_wnd, scroll_pos) -- restore, search_term can be nil
]]


function Scroll_Region_Marker_Mngr_SWS(mngr_child_t, line_idx)
-- mngr_child_t stems from Get_Child_Windows_SWS()
-- line_idx is index of the list entry which preceded the one the Manager is scrolled to
local wnd
	for title, child in pairs(mngr_child_t) do
	-- 'Region/Marker Manager' list window is named 'List2', address is '0x10033C',
	-- discovered with Get_All_Child_Wnds(), the hex value with JS_Window_ListAllChild()
		if title == 'List2' then wnd = child break end
	end
	if wnd then
	local SendMsg = r.BR_Win32_SendMessage
	--	set scrollbar to top to procede from there on down by lines
	SendMsg(wnd, 0x0115, 6, 0) -- msg 0x0115 WM_VSCROLL, 6 SB_TOP, 7 SB_BOTTOM, 2 SB_PAGEUP, 3 SB_PAGEDOWN, 1 SB_LINEDOWN, 0 SB_LINEUP https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll
		for i=1, line_idx-1 do -- -1 to stop scrolling at the target line and not scroll past it
		SendMsg(wnd, 0x0115, 1, 0) -- msg 0x0115 WM_VSCROLL, lParam 0, wParam 1 SB_LINEDOWN scrollbar moves down / 0 SB_LINEUP scrollbar moves up that's how it's supposed to be as per explanation at https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll but in fact the message code must be passed here as lParam while wParam must be 0, same as at https://stackoverflow.com/questions/3278439/scrollbar-movement-setscrollpos-and-sendmessage
		-- WM_VSCROLL is equivalent of EM_SCROLL 0x00B5 https://learn.microsoft.com/en-us/windows/win32/controls/em-scroll
		end
	end
end



function Scroll_SWS_Notes_Window(parent_wnd, str, tr, want_highlight)
-- relies on Esc() function
-- parent_wnd is window titled 'Notes' or 'Notes (docked)' found with Find_Window_SWS() function
-- str is string to be found in the Notes
-- tr is selected track, only relevant for Track Notes
-- want_highlight is boolean to trigger highlighting of the line being scrolled to;
-- no scrolling will occur if the track notes aren't found in the Notes window
-- the function may require waiting until window fully loads if script is short
-- and runs through faster than window loads, otherwise it won't affect the window
-- for this run the function inside a defer function which must be the last in the script
-- so the script can exit once it's executed, e.g.
--[[
a, b, c, time_init = notes_wnd, str, tr, r.time_precise() -- assign as globals to be used in SCROLL() function
function SCROLL()
	if r.time_precise() - time_init > 0.1 then -- 0.03 also works but leaving 100 ms for a leeway
	Scroll_SWS_Notes_Window(a, b, c) -- a, b, c are notes_wnd, mrkr_name, tr
	return end
r.defer(SCROLL)
end
]]
-- for general reference:
-- https://github.com/reaper-oss/sws/blob/master/SnM/SnM_Notes.cpp
-- https://github.com/reaper-oss/sws/blob/master/SnM/SnM_Notes.h

	local function string_exists(txt, str)
		for line in txt:gmatch('[^\n]+') do
		-- str is escaped to cover all cases
			if line:match(Esc(str)) then return txt end
		end
	end

local child = r.BR_Win32_GetWindow(parent_wnd, 5) -- 5 = GW_CHILD, returns 1st child

	if not child then end

-- search str in all children of parent_wnd
local i, notes = 1
	repeat
		if child then
		local ret, txt = r.BR_Win32_GetWindowText(child) -- before SWS build 2.14.0.3 was limited to 1kb therefore couldn't return the entire Track Notes content https://github.com/reaper-oss/sws/issues/1896
		-- overcoming BR_Win32_GetWindowText() limitation by falling back on alternatives
		-- to cover all cases str must be escaped with Esc() function but here it's not necessary
		notes = ret and string_exists(txt, str) or r.JS_Window_GetTitle and string_exists(r.JS_Window_GetTitle(child), str)
			-------------------------------------------------
			-- this is method of finding str in Track Notes for SWS extention builds
			-- where BR_Win32_GetWindowText() is limited to 1kb
			-- simple fall back on r.NF_GetSWSTrackNotes(tr) will produce false positives
			-- because it will return notes where the window won't
			-- ONLY RELEVANT FOR TRACK NOTES
			if not notes then
			local notes_tmp = r.NF_GetSWSTrackNotes(tr)
				if #notes_tmp:gsub('[%c%s]','') > 0 then
				local test_str = 'ISTRACKNOTES' -- the test string is initialized without line break char to be able to successfully find it in the window text because search with the line break char will fail due to carriage return \r being added to the end of the line and thus preceding the line break, i.e. 'ISTRACKNOTES\r\n'
				r.NF_SetSWSTrackNotes(tr, test_str..'\n'..notes_tmp) -- add a test string to start of the notes so it's sure to be included in the string returned by the limited BR_Win32_GetWindowText() version
				local ret, txt = r.BR_Win32_GetWindowText(child)
					if ret and txt:match(test_str) and string_exists(notes_tmp, str) then
					notes = notes_tmp
					end
				r.NF_SetSWSTrackNotes(tr, notes_tmp) -- restore original notes without the test string
				end
			end
			-------------------------------------------------
			if notes then break end
		end
	-- get for evaluation in the next cycle if valid
	child = r.BR_Win32_GetWindow(child, 2) -- 2 = GW_HWNDNEXT // get next sibling of each next found child window advancing until no child is found
	i=i+1
	until not child

	if notes then
	local line_cnt, notes = 0, notes:sub(-1) ~= '\n' and notes..'\n' or notes -- ensures that the last line is captured with gmatch search
	local target_line
		for line in notes:gmatch('(.-)\n') do	-- accounting for empty lines because all must be counted
			if line:match(str) then
			target_line = line
			break end -- stop counting because that's the line which should be reached by scrolling but not scrolled past; to cover all cases str must be escaped with Esc() function but here it's not necessary
		line_cnt = line_cnt+1 -- if this expression preceded 'break end' above, 1 would have to be subtracted from it in the scroll loop below to stop scrolling at the target line and not scroll past it
		end
	-- r.PreventUIRefresh(1) doesn't affect windows
	--	set scrollbar to top to procede from there on down by lines
	r.BR_Win32_SendMessage(child, 0x0115, 6, 0) -- msg 0x0115 WM_VSCROLL (undocumented in the SWS API doc), 6 SB_TOP, 7 SB_BOTTOM, 2 SB_PAGEUP, 3 SB_PAGEDOWN, 1 SB_LINEDOWN, 0 SB_LINEUP https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll
		for i=1, line_cnt do
		r.BR_Win32_SendMessage(child, 0x0115, 1, 0) -- msg 0x0115 WM_VSCROLL, lParam 0, wParam 1 SB_LINEDOWN scrollbar moves down / 0 SB_LINEUP scrollbar moves up that's how it's supposed to be as per explanation at https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll but in fact the message code must be passed here as lParam while wParam must be 0, same as at https://stackoverflow.com/questions/3278439/scrollbar-movement-setscrollpos-and-sendmessage
		-- WM_VSCROLL is equivalent of EM_SCROLL 0x00B5 https://learn.microsoft.com/en-us/windows/win32/controls/em-scroll
		end
		if want_highlight then
		r.BR_Win32_SetFocus(child) -- window must be focused for selection to work
	--	SendMsg(child, 0x00B1, char_cnt+1, char_cnt+20) -- EM_SETSEL 0x00B1, wParam start char index, lParam -1 to select all text or end char index // char_cnt isn't accurate because it doesn't include line breaks which are ignored in the gmatch pattern

		-- THE FOLLOWING line_st VALUE IS ONLY ACCURATE BECAUSE notes VAR STEMS FROM BR_Win32_GetWindowText()
		-- or JS_Window_GetTitle() WHICH RETURN TEXT FROM WINDOW AND IN THE WINDOW EACH LINE FOLLOWED
		-- BY A NEW LINE IS TERMINATED WITH CARRIAGE RETURN \r WHICH IS COUNTED AS WELL.
		-- THIS WOULDN'T HAVE BEEN THE CASE IF notes VAR STEMMED FROM NF_GetSWSTrackNotes()
		-- and the count of lines preceding the target line would have to be added to line_st
		-- e.g. notes:find(Esc('\n'..target_line)) + line_cnt or 0
		local line_st = notes:find(Esc('\n'..target_line)) or 0 -- if not the first line, new line char must be taken into account for start value to refer to the visible start of the line otherwise the start will be offset by 1 because for accurate selection the cursor must start before the first selection character which is the same as past the previous one

		-- correct the char count of notes preceding the target line by subtracting extra (continuation or trailing) bytes count
		-- in case Unicode chars are present so that text selection/highlighting is accurate
		-- because it's performed on the basis of characters rather than bytes
		local extra_bytes_cnt = select(2, notes:match('(.-)'..Esc(target_line)):gsub('[\128-\191]',''))
		line_st = line_st - extra_bytes_cnt

		local line_len = #target_line:match('(.+:%d+.%d+)') -- in segment entry only heghlight the time stamp(s)
		-- https://learn.microsoft.com/en-us/windows/win32/controls/em-setsel
		SendMsg(child, 0x00B1, line_st, line_st+line_len) -- EM_SETSEL 0x00B1, wParam line_st, lParam line_st+line_len
	--	r.BR_Win32_SetFocus(r.GetMainHwnd()) -- removing focus clears selection
		end
	end

end


function Scroll_Window(wnd, line_idx)
-- line_idx is 1-based index of the target line

	if not line_idx or line_idx == 0 then return end

	if wnd then
	--	set scrollbar to top to procede from there on down by lines
		if r.BR_Win32_SendMessage then
		r.BR_Win32_SendMessage(wnd, 0x0115, 6, 0) -- msg 0x0115 WM_VSCROLL, wParam 6 SB_TOP, 7 SB_BOTTOM, 2 SB_PAGEUP, 3 SB_PAGEDOWN, 1 SB_LINEDOWN, 0 SB_LINEUP, lParam 0, https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll
		elseif r.JS_WindowMessage_Send then
		r.JS_WindowMessage_Send(wnd, 'WM_VSCROLL', 6, 0, 0, 0) -- wParamHighWord and lParamHighWord 0
		end		
		for i=1, line_idx-1 do -- -1 to stop scrolling at the target line and not scroll past it
			if r.BR_Win32_SendMessage then
			r.BR_Win32_SendMessage(wnd, 0x0115, 1, 0) -- msg 0x0115 WM_VSCROLL, wParam 1 SB_LINEDOWN scrollbar moves down / 0 SB_LINEUP scrollbar moves up that's how it's supposed to be as per explanation at https://learn.microsoft.com/en-us/windows/win32/controls/wm-vscroll, same as at https://stackoverflow.com/questions/3278439/scrollbar-movement-setscrollpos-and-sendmessage. lParam 0
		-- WM_VSCROLL is equivalent of EM_SCROLL 0x00B5 https://learn.microsoft.com/en-us/windows/win32/controls/em-scroll
			elseif r.JS_WindowMessage_Send then
			r.JS_WindowMessage_Send(wnd, 'WM_VSCROLL', 1, 0, 0, 0) -- wParamHighWord and lParamHighWord 0
			end
		end
	end

end



function Scroll_Region_Mngr_JS(rgn_mngr_closed, rgn_name)
-- example of working with list windows using Region/Marker Manager
-- supports selected markers as well
-- rgn_mngr_closed value must be obtained before opening the Manager
-- rgn_name is only relevant when no region/marker is selected in Arrange
-- because in this case the entry for scrolling into view
-- is searched for by region name

	if not r.JS_Window_Find then return end

local parent_wnd = r.JS_Window_Find('Region/Marker Manager', true) -- exact true // covers both docked and undocked window

	if parent_wnd then

	local mngr_list_wnd = r.JS_Window_FindChild(parent_wnd, 'List2', true) -- exact true, 'Region/Marker Manager' list window is named 'List2', address is '0x10033C', discovered with Get_All_Child_Wnds_JS(), the hex value with JS_Window_ListAllChild()

	local list_itm_cnt = r.JS_ListView_GetItemCount(mngr_list_wnd)
		for idx=0, list_itm_cnt-1 do
			if not rgn_name then -- look for highlighted item in the list
			local highlighted = r.JS_ListView_GetItemState(mngr_list_wnd, idx) == 2 -- items in the Region/Marker Manager aren't selected by a click on a region/marker in Arrange but are highlighted, they're selected when clicked directly, code is 3 which is irrelevant for this script
		-- OR
		--	local text, state = r.JS_ListView_GetItem(mngr_list_wnd, idx, 0) -- state is the same value as the one returned by r.JS_ListView_GetItemState(), column index is 0, in most lists item is highlighted across all columns therefore column index is immaterial
		-- the state codes: 0 - neither heighlighted, selected or was last selected, 1 - last selected while none is currently selected, 2 - highlighted, 3 - selected by a click
				if highlighted then
				-- this doesn't need scrolling with JS_Window_SetScrollPos() at all;
				-- if Region/Marker Manager is closed when the script is executed
				-- and then is opened by the script, JS_ListView_GetItemState()
				-- sometimes seems to make the color of entries of non-selected objects
				-- brighter than the selected MARKERS (within range between 10 to 30
				-- counting from the 1st marker), same with JS_ListView_GetItem()
				-- which returns both text and state,
				-- never happens with selected regions and when moving into view based
				-- on the region/marker name below;
				-- to compensate for this added JS_Window_SetFocus() so that
				-- if the Manager window is initially closed, when opened
				-- the entry of the selected object becomes darker and thus more discernible,
				-- JS_Window_Update() doesn't help in this regard
				local focus = rgn_mngr_closed and r.JS_Window_SetFocus(mngr_list_wnd)
				r.JS_ListView_EnsureVisible(mngr_list_wnd, idx, false) -- partialOK false
				return true end
			else -- no item is highlighted, search by text in the column, in this case region name
				for col_idx=0,15 do -- currently (build 7.22) there're 10 columns in Region/Marker Manager, but using 16 in case the number will increase in the future
				-- colums can be reordered therefore all must be traversed to find the right one
					if r.JS_ListView_GetItemText(mngr_list_wnd, idx, col_idx) == rgn_name then -- item arg is row index, subitem is column index, both 0-based
					r.JS_ListView_EnsureVisible(mngr_list_wnd, idx, false) -- partialOK false
					end
				end
			end
		end
	end

end



-- child_t = Get_Child_Windows_SWS('Media Explorer')
-- local displayall = Check_reaper_ini('reaper_explorer', 'displayall')
-- options = Get_Media_Explorer_Show_Submenu_Options(displayall+0) -- must stay global to be accesible inside Scroll_MX_File_List() function
-- time_init = r.time_precise()
-- defer version is required when scrolling must be performed
-- after changing folder, because the window is slow to update
-- and target file won't be found immediately
function Scroll_MX_File_List1() -- defer version
-- relies on Get_Media_Explorer_Column_Count(), 
-- Traverse_List2() functions

	if r.time_precise() - time_init >= 0.03 then -- waiting 30 ms before scrolling
	local list_wnd
		for k, data in ipairs(child_t) do
			if data.title == 'List1' then -- MX list view window title is List1
			list_wnd  = data.child break
			end
		end
		if list_wnd then
		local file_name = options[3] and stored_path:match('.+[\\/](.+)') or stored_path:match('.+[\\/](.+)%.') -- include extension if enabled in 'Show' settings as 'File extension even if file type displayed'
		local col_cnt = Get_Media_Explorer_Column_Count()
		local row_idx = Traverse_List2(list_wnd, col_cnt, file_name) -- isolating file name to the exclusion of its extension because it may be turned off in the 'Show' settings
			if row_idx then
			Scroll_Window(list_wnd, row_idx+1) -- +1 because row_idx return value is 0-based
			end
		--	r.JS_ListView_EnsureVisible(list_wnd, file_idx, false) -- partialOK false
		end
	return
	end
r.defer(Scroll_MX_File_List1)
end


function Scroll_MX_File_List2(options, file_name, list_wnd) -- non-defer version
-- relies on Get_Media_Explorer_Column_Count(), 
-- Traverse_List2() functions
-- and those which precede Scroll_MX_File_List1() above
local file_name = options[3] and file_name or file_name:match('.+[\\/](.+)%.') -- include extension if enabled in 'Show' settings as 'File extension even if file type displayed'
local col_cnt = Get_Media_Explorer_Column_Count()
row_idx = Traverse_List2(list_wnd, col_cnt, file_name) -- isolating file name to the exclusion of its extension because it may be turned off in the 'Show' settings
	if row_idx then
	Scroll_Window(list_wnd, row_idx+1)
	end
--	r.JS_ListView_EnsureVisible(list_wnd, file_idx, false) -- partialOK false
end



function Get_Focused_Item_In_List(list_wnd)
-- may be useful in determining the number of items
-- which need to be hopped over in order to select or scroll to an item with specific index
-- provided there's a programmatic way to select or scroll to it
-- although as far as scrolling is concerned Scroll_Window() function above 
-- is good enough because it always resets the scroll position 
-- to 0 before scrolling to the target

local focused_itm_idx = r.JS_ListView_GetFocusedItem(list_wnd) -- returnns last focused item index even if it's not currently selected or highlighted, hence needs to be additionally validated with the following function, because if none is visibly selected or highlighted the initial index for scrolling or selection loop must be 0
local text, state = r.JS_ListView_GetItem(list_wnd, focused_itm_idx, 0) -- column index is 0, in most lists item is highlighted across all columns therefore column index is immaterial
-- OR
-- local state = r.JS_ListView_GetItemState(list_wnd, focused_itm_idx)
-- the state codes: 0 - neither heighlighted, selected or was last selected, 1 - last selected while none is currently selected, 2 - highlighted, 3 - selected by a click
return state
end


function Insert_String_Into_Field_SWS(parent_wnd, str)
-- window of a field for text input is usually a child of the main window
-- and lacks a title, if the field is filled out the actual text is returned as its name
-- parent_wnd is window returned with Find_Window_SWS() or JS_Window_Find() functions
-- str is string to be inserted into the input field
-- when string is inserted the field is cleared of any current string
-- the function was originally designed to be applied to Region/Marker Manager

	if not parent_wnd then return end

local child = r.BR_Win32_GetWindow(parent_wnd, 5) -- 5 = GW_CHILD, returns 1st child

	if not child then return end

	local function is_input_field(title)
	-- 'Region/Marker Manager' filter field window is nameless unless filled out
	-- the window title list is as of build 7.22,
	-- the list will differ for other parent windows,
	-- the titles of all child windows can be retrieved with Get_Child_Windows_SWS()
		for k, tit in ipairs({'Clear', 'List2', 'Markers',
		'Options', 'Regions', 'Render Matrix...', 'Take markers'}) do
			if title == tit then return end -- if title matches any other child window title return false
		end
	return true
	end


local SendMsg = r.BR_Win32_SendMessage
local i = 1
	repeat
	local ret, txt = r.BR_Win32_GetWindowText(child)
		if ret and is_input_field(txt) then -- 'Region/Marker Manager' filter field window is nameless unless filled out
		--------------- CLEAR ROUTINE  --------------------------------------------
			if #txt > 0 then -- clear filter string, if any

		--	SendMsg(child, 0x0007, 0, 0) -- WM_SETFOCUS 0x0007 -- makes Region/Marker Manager unresponsive to clicks even though does place a cursor in the filter field
		--	https://ecs.syr.edu/faculty/fawcett/Handouts/CoreTechnologies/windowsprogramming/WinUser.h
		-- https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
		-- https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
		-- https://learn.microsoft.com/en-us/windows/win32/inputdev/about-keyboard-input#keystroke-message-flags -- scan codes are listed in a table in 'Scan 1 Make' column in Scan Codes paragraph
		-- https://handmade.network/forums/articles/t/2823-keyboard_inputs_-_scancodes%252C_raw_input%252C_text_input%252C_key_names
		-- 'Home' (extended key) scan code 0xE047 (move cursor to start of the line) or 0x0047, 'Del' (extended key) scan code 15, Backspace scancode 0x000E or 0x0E (14), Forward delete (regular delete) 0xE053 (extended), Left arrow 0xE04B (extended key), Left Shift 0x002A or 0x02A, Right shift 0x0036 or 0x036 // all extended key codes start with 0xE0
		-- BR_Win32_SendMessage only needs the scan code, not the entire composite 32 bit value, not even the extended key flag (24th bit), the repeat count, i.e. bits 0-15, is ignored, no matter the integer the command only runs once
		--[[ -- the calculations of lParam value are correct but useless
			local home = 1 + (0xE047 << 16) + (1 << 24) -- WORKS
			local back = 1 + (14 << 16) --+ (1 << 24)
			local left = 1 + (0xE04B << 16) + (1 << 24) -- WORKS
			local forw_del = 1 + (0xE053 << 16) + (1 << 24) -- WORKS
			local shift = 1 + (0x02A << 16)
		--	SendMsg(child, 0x0100, 0x25, left) -- WORKS
		--	SendMsg(child, 0x0100, 0x24, home) -- WORKS
		--	SendMsg(child, 0x0100, 0x2E, forw_del) -- WORKS
		--	SendMsg(child, 0x0100, 0x08, back) -- DOESN'T WORK
		--	SendMsg(child, 0x0100, 0x10, shift) -- DOESN'T WORK
		--	SendMsg(child, 0x0100, 1, 0x08) -- WM_KEYDOWN 0x0100, WM_KEYUP 0x0101, VK_CLEAR 0x0C, VK_BACK 0x08 BACKSPACE key, VK_HOME 0x24 HOME key, VK_SHIFT 0x10 SHIFT key, VK_LEFT 0x25 LEFT ARROW key, VK_DELETE	0x2E DEL key
		--	SendMsg(child, 0x0303, 0, 0) -- WM_CLEAR 0x0303; WM_CUT 0x0300 // ONLY WORKS IF TEXT IS SELECTED (HIGHLIGHTED), BUT COULD MAKE SHIFT WORK TO HIGHLIGHT IT WITH Left arrow key
		--]]
			-- #txt count works accurately here for Unicode characters as well for some reason

			-- move cursor to start of the line
			SendMsg(child, 0x0100, 0x24, 0xE047) -- 0x0100 WM_KEYDOWN, virtual key code 0x24 VK_HOME HOME key, 0xE047 HOME key scan code
				for i=1,#txt do -- run Delete for each character
				SendMsg(child, 0x0100, 0x2E, 0xE053) -- 0x2E VK_DELETE DEL key, 0xE053 DEL key scan code
				end
			--[[ -- OR
				for i=1,#txt do -- move cursor from line end leftwards character by character deleting them
				SendMsg(child, 0x0100, 0x25, 0xE04B) -- 0x0100 WM_KEYDOWN, LEFT ARROW key virtual key code 0x25, scan code 0xE04B
				SendMsg(child, 0x0100, 0x2E, 0xE053) -- 0x0100 WM_KEYDOWN, VK_DELETE DEL key virtual key code 0x2E, its scan code is 0xE053
				end
			--]]
			--[[ -- OR
			-- https://learn.microsoft.com/en-us/windows/win32/controls/em-setsel
			-- https://learn.microsoft.com/en-us/windows/win32/dataxchg/wm-clear
			r.BR_Win32_SetFocus(child)	-- necessary to make EM_SETSEL work // NOT REQUIRED FOR TEXT DELETION WITH THE ABOVE ALTERNATIVES
			SendMsg(child, 0x00B1, 0, -1) -- EM_SETSEL 0x00B1, wParam start char index, lParam -1 to select all text or end char index
			SendMsg(child, 0x0303, 0, 0) -- WM_CLEAR 0x0303 // OR WM_CUT 0x0300
			--[=[
				r.JS_Window_SetFocus(child_wnd)
				r.JS_WindowMessage_Send(child_wnd, 0x00B1, 0, 0, -1, 0)
				r.JS_WindowMessage_Send(child_wnd, 0x0303, 0, 0, 0, 0)
			]=]
			--]]
			end
		r.CF_SetClipboard(str)
		-- https://learn.microsoft.com/en-us/windows/win32/dataxchg/wm-paste
		SendMsg(child, 0x0302, 0, 0) -- WM_PASTE 0x0302 // gets input from clipboard, undocumented in the SWS API doc
		break
		end
	-- get for the next cycle
	child = r.BR_Win32_GetWindow(child, 2) -- 2 = GW_HWNDNEXT // get next sibling of each next found child window advancing until no child is found or the right one is found above
	i=i+1
	until not child

end


function Mouse_Click(wnd)
local Send = r.BR_Win32_SendMessage
--	https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-lbuttondown
-- https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-lbuttonup
	for k, msg in ipairs({0x0201,0x0202}) do -- WM_LBUTTONDOWN 0x0201, WM_LBUTTONUP 0x0202
	Send(wnd, msg, 0x0001, 1+1<<16) -- MK_LBUTTON 0x0001, x (low order) and y (high order) are 1, in lParam client window refers to the actual target window, x and y coordinates are relative to the client window and have nothing to do with the actual mouse cursor position, 1 px for both is enough to hit the window
	end

--Send(wnd, 0x0201, 0x0001, 1+1<<16) -- WM_LBUTTONDOWN 0x0201, MK_LBUTTON 0x0001, x (low order) and y (high order) are 1, in lParam client window refers to the actual target window, x and y coordinates are relative to the client window and have nothing to do with the actual mouse cursor position, 1 px for both is enough to hit the window
--Send(wnd, 0x0202, 0x0001, 1+1<<16) -- WM_LBUTTONUP 0x0202, MK_LBUTTON 0x0001, x and y are 1
end


-- Enter key press
r.JS_WindowMessage_Post(child_wnd, 'WM_KEYDOWN', 0x0D, 0, 0x001C, 0) -- 0x0100 WM_KEYDOWN, 0x0D is VK_RETURN i.e. Enter key virtual key code, its scan code is 0x001C, on the keypad its 0xE01C
-- SendMessage() doesn't work



function Is_Floating_FX_Window(title)
return title:match('[2ACDJLPSTUVX]+i?:') or title:match(' %[%d+/%d+%]') 
or title:match(' %- Item') or title:match(' %- Track %d+')
or title:match(' %- Master Track') or title:match(' %- Monitoring')
end


function Is_FX_Chain_Window(title)
return title:match('FX: Track') or title:match('FX: Item') 
or title:match('FX: Master') or title:match('FX: Monitoring')
end


function Is_Window_Fully_Minimized(wnd)
-- function to minimize fully
-- r.BR_Win32_ShowWindow(wnd, 2) -- 2 SW_SHOWMINIMIZED, only leaves window title bar			
local retval, lt, t, rt, b = r.BR_Win32_GetWindowRect(wnd)
return rt-lt == 160 and b-t == 24
end


local is_new_value,filename,sectionID,cmdID_orig,mode,resolution,val = r.get_action_context()
function Activate_Context(sectionID) -- MIDI or Arrange
-- for sws relies on Find_Window_SWS() function from above
local sws, js = r.APIExists('BR_Win32_FindWindowEx'), r.APIExists('JS_Window_Find')
	if sws or js then
		if sectionID ~= 32060 then -- not midi when the script is run from the Main section of the Action list, that is sectionID returned by get_action_context() is not 32060
	--	r.JS_Window_SetFocus(r.GetMainHwnd()) -- DOESN'T SET FOCUS TO THE MAIN WINDOW if the open MIDI Editor is docked and attached to the main window because the MIDI Editor ends up being focused instead
		local main_wnd = js and r.JS_Window_Find('trackview', true) or sws and Find_Window_SWS('trackview', true) -- want_main_children true
		local focus = js and r.JS_Window_SetFocus(main_wnd) or sws and r.BR_Win32_SetFocus(main_wnd)
		else -- no additional conditions are required because if midi is true, the script is run from inside an open MIDI Editor window
	--	r.JS_Window_SetFocus(r.MIDIEditor_GetActive()) -- DOESN'T MAKE MIDI EDITOR DOCKED IN A DOCKER ATTACHED TO THE MAIN WINDOW FOCUSED, BUT DOES WORK FOR FLOATING MIDI EDITOR DOCKED OR NOT
		local ME_wnd = js and r.JS_Window_Find('midiview', true) or sws and Find_Window_SWS('midiview')
		local focus = js and r.JS_Window_SetFocus(ME_wnd) or sws and r.BR_Win32_SetFocus(ME_wnd) -- 'midiview' window parent title is 'Edit MIDI' after toggling the MIDI Editor (docked or not) but focusing this parent doesn't work; alternative to 'midiview' is 'midipianoview', when either is focused without toggling the MIDI Editor, the parent is the window titled 'MIDI take: <MIDI take name>'

	--	r.Main_OnCommand(40716,0) r.Main_OnCommand(40716,0) -- View: Toggle show MIDI editor windows // DOES MAKE MIDI EDITOR DOCKED IN A DOCKER ATTACHED TO THE MAIN WINDOW FOCUSED, and works generally in other window states, BUT FLICKERING LOOKS UGLY
		end
	end
end


-- to be used with r.ViewPrefs(int, '')
-- source: cfillion_Open preferences page.lua
-- the numbers are prone to change
local pages = { -- prefpage_lastpage
  ['General'                 ] = { 0x08b  ,
  [  'Paths'                 ] =   0x1da  ,
  [  'Keyboard, Multitouch'  ] =   0x0db },
  ['Project'                 ] = { 0x0d4  ,
  [  'Track, Send Defaults'  ] =   0x0b2  ,
  [  'Media Item Defaults'   ] =   0x1dd },
  ['Audio'                   ] = { 0x09c  ,
  [  'Device'                ] =   (macos   and 0x1d9) or
                                   (windows and 0x076) or
                                                0x242,
  [  'MIDI Devices'          ] =   0x099  ,
  [  'Buffering'             ] =   0x0cb  ,
  [  'Mute, Solo'            ] =   0x248  ,
  [  'Playback'              ] =   0x088  ,
  [  'Seeking'               ] =   0x205  ,
  [  'Recording'             ] =   0x089  ,
  [  'Loop Recording'        ] =   0x206  ,
  [  'Rendering'             ] =   0x1de },
  ['Appearance'              ] = { 0x0d5  ,
  [  'Media'                 ] =   0x0ec  ,
  [  'Peaks, Waveforms'      ] =   0x1cb  ,
  [  'Fades, Crossfades'     ] =   0x20c  ,
  [  'Track Control Panels'  ] =   0x1ca },
  ['Editing Behavior'        ] = { 0x0ac  ,
  [  'Envelope Display'      ] =   0x1bf  ,
  [  'Automation'            ] =   0x207  ,
  [  'Mouse'                 ] =   0x0d7  ,
  [  'Mouse Modifiers'       ] =   0x1d2  ,
  [  'MIDI Editor'           ] =   0x1ea },
  ['Media'                   ] = { 0x08a  ,
  [  'MIDI'                  ] =   0x101  ,
  [  'Video, REX, Misc'      ] =   0x1c1 },
  ['Plug-ins'                ] = { 0x09a  ,
  [  'Compatibility'         ] =   0x1f9  ,
  [  'VST'                   ] =   0x0d2  ,
  [  'LV2'                   ] =   0x251  ,
  [  'ReWire'                ] =   0x0d1  ,
  [  'ReaScript'             ] =   0x203  ,
  [  'ReaMote'               ] =   0x0e3 },
  ['Control, OSC, web'       ] =   0x09d  ,
  ['External Editors'        ] =   0x0a0  ,
}


function Set_Horiz_Zoom_Level(target_val)
-- target_val is px/sec,
-- example: if grid division length in sec * r.GetHZoomLevel() < X px
-- target_value (i.e. px/sec) arg is X / grid division length in sec
local dir = r.GetHZoomLevel() > target_val and -1 or r.GetHZoomLevel() < target_val and 1
	if dir then
	r.PreventUIRefresh(1)
		repeat
		r.adjustZoom(0.1*dir, 0, true, 0) -- forceset 0, doupd true, centermode 0 // HORIZONTAL ZOOM ONLY // amt > 0 zooms in, < 0 zooms out, the greater the value the greater the zoom, amt value smaller than 1 is supported, however the zoom amount produced by the amt value seems to depend on the initial zoom level and as zoom level increases/decreases the delta between previous and next zoom levels gradually increases/decreases in comparison with the delta produced by the initial change, so it's hard to calculate in advance the amt value required for a particular zoom level to be able to set it in one go without the loop even though it's known that the zoom amount changes by a factor 10 time greater than the amt value i.e. 0.001 produces change by 0.0X px/sec, WITHOUT PreventUIRefresh() with values under 1 THE ZOOM CHANGES VERY SLOWLY, adjusting by r.GetHZoomLevel()/1000 changes zoom by 0.3 px/sec; forceset ~= 0 zooms out, if amt value is 1 then zooms out fully, if amt is greater then depends on the amt value but the relationship isn't clear, if bound to mousewheel, amt can be modified by val return value of get_action_context() function to change direction of the zoom, positive IN, negative OUT; doupd (do update) if false, no zoomming; centermode: 0 < or > 1 no center, window horizontally scrolls all the way rightwards (even though as per the API doc -1 for default, presumably as set at Pref -> Appearance -> Zoom/Scroll/Offset -> Horizontal zoom center), 0 or 1 edit cursor is the center, is adjusted so that the edit cursor ends up at the center, to use mouse as the center the action 'View: Move edit cursor to mouse cursor (no snapping)' must be used, then edit cursor pos should be restored
		local zoom = r.GetHZoomLevel()
		until dir < 0 and zoom <= target_val or dir > 0 and zoom >= target_val
	r.PreventUIRefresh(-1)
	end
end



function Re_Store_Zoom(zoom)

	local function round(num, idp) -- idp = number of decimal places, 0 means rounding to integer
	-- http://lua-users.org/wiki/SimpleRound
	-- round to N decimal places
	  local mult = 10^(idp or 0)
	  return math.floor(num * mult + 0.5) / mult
	end

local cur_zoom = r.GetHZoomLevel()
	if not zoom then -- store
	return cur_zoom
	else -- restore
	local cur_zoom, zoom = round(cur_zoom, 12), round(zoom, 12) -- minute difference in floating point results in inequality between numbers otherwise equal down to the 12th decimal place which are displayed in ReaScript console, so round down to 12 decimal places to prevent that // another method of dealing with these see in floats_are_equal()
	local amt = cur_zoom < zoom and 1 or cur_zoom > zoom and -1
		if amt then -- not equal to stored zoom
		r.PreventUIRefresh(1)
			repeat
			r.adjustZoom(amt, 0, true, -1) -- forceset 0, doupd true, centermode 0 // HORIZONTAL ZOOM ONLY // amt > 0 zooms in, < 0 zooms out, the greater the value the greater the zoom, amt value smaller than 1 is supported, however the zoom amount produced by the amt value seems to depend on the initial zoom level and as zoom level increases/decreases the delta between previous and next zoom levels gradually increases/decreases in comparison with the delta produced by the initial change, so it's hard to calculate in advance the amt value required for a particular zoom level to be able to set it in one go without the loop even though it's known that the zoom amount changes by a factor 10 time greater than the amt value i.e. 0.001 produces change by 0.0X px/sec, WITHOUT PreventUIRefresh() with values under 1 THE ZOOM CHANGES VERY SLOWLY, adusting by r.GetHZoomLevel()/1000 changes zoom by 0.3 px/sec; forceset ~= 0 zooms out, if amt value is 1 then zooms out fully, if amt is greater then depends on the amt value but the relationship isn't clear, if bound to mousewheel, amt can be modified by val return value of get_action_context() function to change direction of the zoom, positive IN, negative OUT; doupd (do update) if false, no zoomming; centermode: 0 < or > 1 no center, window horizontally scrolls all the way rightwards (even though as per the API doc -1 for default, presumably as set at Pref -> Appearance -> Zoom/Scroll/Offset -> Horizontal zoom center), 0 or 1 edit cursor is the center, is adjusted so that the edit cursor ends up at the center, to use mouse as the center the action 'View: Move edit cursor to mouse cursor (no snapping)' must be used, then edit cursor pos should be restored
			until amt == 1 and r.GetHZoomLevel() >= zoom or amt == -1 and r.GetHZoomLevel() <= zoom
		r.PreventUIRefresh(-1)
		end
	end
end
-- USE:
-- local zoom = Re_Store_Zoom() -- store
-- Re_Store_Zoom(zoom) -- restore


function get_gfx_scale()
-- https://forum.cockos.com/showthread.php?t=230120
-- ideally should be included in the defer function as well to monitor any changes
-- by the user at runtime or moving the window to a monitor with different scale
-- for retina detection the function must be run twice, before and after gfx.init()
-- to make gfx.ext_retina value update if retina is supported on the user monitor
-- on Mac the retina value must not be applied to gfx window size because there it
-- will update automatically, but must be applied to all other elements;
-- gfx.ext_retina arg must be passed to the 2nd instance of the function

local retval, dpi = r.ThemeLayout_GetLayout('tcp', -3)
--[[
-- the scale unit is 256/100 because 256 is scale 1 and 512 is scale 2 which correspond to values 1 and 2 in Pref -> General -> Advanced UI/system tweaks -> Scale UI elements of .., the minimal step between 1 and 2 is 0.01, so 100 in total, after calculation decimal values are rounded off, e.g. scale 1.01 = 259 (rounded 256+2.56), scale 1.02 = 261 (rounded 256+2.56*2)
local cur_scale = ((dpi+0-256)/100/2.56) -- OR (dpi+0-256)/2.56/100
cur_scale = math.floor(cur_scale*100+0.5)/100 + 1 -- if cur_scale value is < 1, 0.5 is too big and roudning off will produce 0, hence temporarily updscaling the value and then restoring, adding 1 since no scaling equals 1, plus if user scaling value is < 1 cur_scale value will be negative because dpi < 256 and +1 will rectify it into a correct positive one
]]
-- OR much simpler
local cur_scale = dpi/256 -- 256 is scale 1, 512 is 2
	if not gfx.ext_retina then -- initial gfx.ext_retina value is nil, once set to 1 will auto-update to 2 on second function call after gfx.init() to indicate retina support if any otherwise will be set to 0
	gfx.ext_retina = 1
	end
local mult = gfx.ext_retina == 2 and gfx.ext_retina or 1
return cur_scale * mult -- multiplying by retina value which will be set to 2 if retina is supported, otherwise no change in the scale because when no retina mult var will be set to 1
end
--[[ USE:
get_gfx_scale() -- run 1st time to intialize gfx.ext_retina value before gfx.init()
gfx.init() or function based on it
cur_scale = get_gfx_scale() -- run 2nd time after gfx.init() to update gfx.ext_retina if retina is supported and accounr for it in the scale value // this value is fed into gfx.init() or function based on it
]]



function click_pad(scr_cmdID, w, h, cur_scale)
-- the gfx click pad simplifies menu handling, because otherwise
-- one would have to devise a way to keep the script running in defer loop
-- without displaying the menu and display it only on click,
-- to detect click get_action_context() val could have probably been used
-- and the menu display location would have to be decided upon;
-- w 265 and h 30 seem optimal
-- cur_scale arg stems from get_gfx_scale()

-- gfx window to receive mouse clicks for menu opening for instance
local scale = cur_scale or 1
local w, h = w*scale, h*scale
local stored_coord = r.GetExtState(scr_cmdID, 'LAST_GFX_COORDINATES') -- load coordinates stored last during session with store_or_update_coordinates_after_quitting() function below
local x, y = stored_coord:match('(%d+),(%d+)')
local mouse_x, mouse_y = r.GetMousePosition()
x, y = table.unpack(x and {x,y} or {mouse_x-w/2, mouse_y-23-h/2}) -- when opening for the first time during session open so that the box center is at mouse, 23 is the height of the box top bar not included in its height value, then during session open at the last position, stored in close_gfx_wnd_and_store_coordinates() // mouse_x-w to place the window's upper right hand corner at the mouse
gfx.init('TITLE', w, h, 0, x, y) -- height value doesn't include the top bar whose height is 23 px
gfx.setfont(1,"Arial Black", 16*scale)
-- both following alternatives work, the first may be preferable for handling manual window resize
--[-[
--local char_w, char_h = gfx.measurechar('C')
local str = ('CLICK'):gsub('.','%0'..(' '):rep(8))..'K'
local str_w, str_h = gfx.measurestr(str)
gfx.x, gfx.y = (w-str_w)/2, (h-str_h)/2
gfx.drawstr(str)
--]]
--[[
gfx.x, gfx.y = 50*scale, 7*scale
gfx.drawstr(('CLICK'):gsub('.','%0'..(' '):rep(8)))
--]]
end



function keep_click_pad_size(w, h, cur_scale)
local scale = cur_scale or 1
local w, h = w*scale, h*scale
	if gfx.w ~= w or gfx.h ~= h then
	gfx.init('', w, h)
	end
-- the crucial part is the empty window name
-- Thanks to Justin & amagalma
-- https://www.askjf.com/?q=5895s
-- https://forum.cockos.com/showpost.php?p=2493416&postcount=40

-- this must always run because when the window is resized the text disappears,
-- can't be restored fast enough in the block above probably needs more time
-- both alternatives work, the first may be preferable for handling manual window resize
--[-[
local str = ('CLIC'):gsub('.','%0'..(' '):rep(8))..'K'
local str_w, str_h = gfx.measurestr(str)
gfx.x, gfx.y = (w-str_w)/2, (h-str_h)/2
gfx.drawstr(str)
--]]
--[[
gfx.x, gfx.y = 50*scale, 7*scale
gfx.drawstr(('CLICK'):gsub('.','%0'..(' '):rep(8)))
--]]
end


function gfx_mouse_click()
-- detects mouse click within the gfx window
gfx.x, gfx.y = 0, 0 -- reset for mouse capture
--local left, bott = gfx.x + gfx.w, gfx.y + gfx.h
return gfx.mouse_cap&1 == 1 and gfx.mouse_x > gfx.x and gfx.mouse_x < gfx.w
and gfx.mouse_y > gfx.y and gfx.mouse_y < gfx.h
end


function store_or_update_coordinates_after_quitting1(scr_cmdID)
-- must run inside main defer function
-- THE STORAGE ROUTINE IN THIS FUNCTION ENSURES THAT
-- the window is always re-opened at the same location
-- regardless of whether it was closed by clicking its
-- close button or with Esc and regardless of the current
-- mouse cursor position

-- when gfx window has been closed by mouse click or with a key press
-- gfx.clienttoscreen(0,0) will only return zeros because there's no window any longer
-- however fetching coordinates relative to the mouse cursor
-- allows calculating the window more or less exact original location on the screen;
-- when closing with the click on the close button located in the upper right hand corner:
-- x = mouse_x-gfx.w+5 (or 10), accounting for gfx window width because the close button
-- is located opposite to the X axis start but short of the window's right edge
-- y = mouse_y-10, accounting for mouse location which is below the gfx window top edge
-- by about 10 px;
-- otherwise the coordinates need to be updated constantly while the script runs
-- this however isn't suitable for closing with key press because mouse cursor can be anywhere

-- https://forums.cockos.com/showthread.php?p=2015361
local click, escape = gfx.getchar() == -1, gfx.getchar() == 27

	if click or escape then -- WITH ESCAPE AND LIKELY ANY KEY PRESS THIS REQUIRES LONG PRESS UNTIL IT'S REGISTERED, HOWEVER IN THE MAIN DEFER FUNCTION THIS FUNCTION RUNS INSIDE gfx.getchar() == 27 CAN BE REGISTERED IMMEDIATELY WITH THE FOLLOWING SYNTAX:
	-- 'if gfx.getchar() == 27 or gfx.getchar() == -1 then'
	-- INSIDE THIS FUNCTION HOWEVER EVEN THIS ORDER OF CONDITIONS DOESN'T PRODUCE IMMEDIATE RESPONSE
	-- the code inside the function doesn't need adjustment, just add the same condition outside of it 
	-- in the main defer function
	-- on top of the condition inside it, i.e.:
	--[[ if gfx.getchar() == 27 or gfx.getchar() == -1 then -- gfx.getchar() == 27 doesn't work immediately if preceded by gfx.getchar() == -1
		store_or_update_coordinates_after_quitting(cmdID)
		end
	]]

	local stored_coord = r.GetExtState(scr_cmdID, 'LAST_GFX_COORDINATES') -- load coordinates stored last during session
	local x, y = stored_coord:match('(%d+),(%d+)')
	local cur_x, cur_y = table.unpack(click and {r.GetMousePosition()} or escape and {gfx.clienttoscreen(0,0)} or {})

		if not x or cur_x ~= x+0 or cur_y+0 ~= y then
		x, y = table.unpack(click and {cur_x-gfx.w+5, cur_y-10} or escape and {cur_x, cur_y}) -- if click, subtraction of the window width ensures that when re-opened it's situated more or less at the same spot, otherwise the window will be re-opened at the last click coordinate which is the close button X location thus shifting righwards by its length from the last location // +5 (10 also works) and -10 adjust the coordinates so if the mouse cursor stays put the window will open with the close button presicely under the cursor, because the close button doesn't sit on the window's right edge so gfx.w is greater than cursor's cur_x value at the moment of the click, likewise cursor's cur_y value doesn't match the window y coordinate exactly because the close button sits lower than the window's top edge
		r.SetExtState(scr_cmdID, 'LAST_GFX_COORDINATES', math.floor(x)..','..math.floor(y), false) -- persist false // truncating the trailing decimal zero from integers
	--	gfx.quit() -- only needed if quitting at a key press rathen than by a click on the close button, placed here to allow getting coordinates above while the window is open // REDUNDANT BECAUSE IN THE MAIN DEFER FUNCTION THIS FUNCTION WILL BE FOLLOWED BY A RETURN STATEMENT TO QUIT THE SCRIPT SO THE WINDOW WILL CLOSE ALL THE SAME, gfx.quit() alone won't make the window close on Esc
		end

	end

end


function store_or_update_coordinates_after_quitting2(scr_cmdID)
-- must run inside main defer function
-- THE STORAGE ROUTINE IN THIS FUNCTION ENSURES THAT
-- if the window is closed by clicking its close button
-- the window is re-opened at the last location regardless 
-- of the current mouse cursor position;
-- if closed by Esc, it's opened with the close button being
-- directly under the mouse cursor

-- when gfx window has been closed by mouse click or with a key press
-- gfx.clienttoscreen(0,0) will only return zeros because there's no window any longer
-- however fetching coordinates relative to the mouse cursor
-- allows calculating the window more or less exact original location on the screen;
-- when closing with the click on the close button located in the upper right hand corner:
-- x = mouse_x-gfx.w+5 (or 10), accounting for gfx window width because the close button
-- is located opposite to the X axis start but short of the window's right edge
-- y = mouse_y-10, accounting for mouse location which is below the gfx window top edge
-- by about 10 px;
-- otherwise the coordinates need to be updated constantly while the script runs
-- this however isn't suitable for closing with key press because mouse cursor can be anywhere

local stored_coord = r.GetExtState(scr_cmdID, 'LAST_GFX_COORDINATES') -- load coordinates stored last during session
local x, y = stored_coord:match('(%d+),(%d+)')
local mouse_x, mouse_y = r.GetMousePosition() -- coordinates of the mouse cursor relative when the gfx window close button is clicked

	if not x or mouse_x ~= x+0 or mouse_y+0 ~= y then -- if current coordinates differ from the stored, update or store for the 1st time if absent
	r.SetExtState(scr_cmdID, 'LAST_GFX_COORDINATES', math.floor(mouse_x-gfx.w+5)..','..math.floor(mouse_y-10), false) -- persist false // truncating the trailing decimal zero from integers; subtraction of the window width and y coordinate ensures that when re-opened it's situated more or less at the same spot, otherwise the window will be re-opened at the last click coordinate which is the close button X location thus shifting righwards by its length from the last location // +5 (10 also works) and -10 adjust the coordinates so if the mouse cursor stays put the window will open with the close button presicely under the cursor, because the close button doesn't sit on the window's right edge so gfx.w is greater than cursor's mouse_x value at the moment of the click, likewise cursor's mouse_y value doesn't match the window y coordinate exactly because the close button sits lower than the window's top edge
	end

end



--==================================== W I N D O W S   E N D ====================================


--==================================== T H E M E ====================================

function smandrap_Change_MCP_Width(PIXEL_STEP, PERSIST) -- v7.0 default theme only
-- PIXEL_STEP -- Positive: increase size. Negative: decrease size
-- https://forum.cockos.com/showpost.php?p=2792656&postcount=120
-- OR
-- https://forum.cockos.com/showthread.php?t=291724&page=3#120

	local function clamp(v, min, max)
	return v < min and min or v > max and max or v
	end

	for i = 0, math.huge do
	  local parname, _, val, def, min, max = reaper.ThemeLayout_GetParameter(i)
	  if not parname then break end

	  if parname:match("^Layout[ABC]%-mcpWidth.*$") then
		 val = clamp(val + PIXEL_STEP, min, max)
		 reaper.ThemeLayout_SetParameter(i, val, PERSIST)
	  end
	end

reaper.ThemeLayout_RefreshAll()

end

-- see also 'Option: Show theme color controls' dialogue in the C O L O R section


--================================ T H E M E  E N D =================================


--========================================== F I L E S =========================================

local _, scr_name, sect_ID, cmd_ID, _,_,_ = r.get_action_context()
local scr_name = scr_name:match('([^\\/]+)%.%w+') -- without path and extension
local scr_name = scr_name:match('([^\\/_]+)%.%w+') -- without path & scripter name
local scr_name = scr_name:match('[^\\/]+_(.+)%.%w+') -- without path, scripter name & ext
local scr_name = scr_name:match('.+[\\/].-_(.+)%.%w+') -- without path, scripter name and file ext // due to .+[\\/] WILL ONLY WORK IF THE SCRIPT ISN'T LOCATED IN THE ROOT OF THE /Scripts folder
local scr_name = scr_name:match('.+[\\/](.+)') -- whole script name without path // due to .+[\\/] WILL ONLY WORK IF THE SCRIPT ISN'T LOCATED IN THE ROOT OF THE /Scripts folder
local named_ID = r.ReverseNamedCommandLookup(cmd_ID) -- to ensure more unique extended state section name, diff sections may probably have identical numeric cmd_IDs // script aplhanumeic command IDs in different Action list sections differ in the alphabetic prefix
or scr_name -- if an non-installed script is run via 'ReaScript: Run (last) ReaScript (EEL2 or lua)' actions get_action_context() won't return valid command ID, in which case fall back on the script full path
local path = r.GetResourcePath()
local sep = r.GetResourcePath():match('[\\/]')
local sep = r.GetOS():match('Win') and '\\' or '/'
local sep = package.config:sub(1,1)


function get_script_path() -- same as ({r.get_action_context()})[2]:match('.+[\\/]')
-- https://forum.cockos.com/showthread.php?t=159547
local info = debug.getinfo(1,'S');
local script_path = info.source:match[[^@?(.*[\/])[^\/]-$]]
-- OR
-- local script_path = info.source:match('@(.+[\\/])')
return script_path
end


function get_package_path_for_require()
-- https://forums.cockos.com/showthread.php?p=1668756
-- https://github.com/ReaTeam/ReaScripts-Templates/blob/master/Files/Require%20external%20files%20for%20the%20script.lua
-- https://www.gammon.com.au/scripts/doc.php?lua=package.path
local info = debug.getinfo(1,'S');
local full_script_path = info.source
local script_path = full_script_path:sub(2,-5) -- remove "@" and "file extension" from file name
	if reaper.GetOS() == "Win64" or reaper.GetOS() == "Win32" then
	package.path = package.path .. ";" .. script_path:match("(.*".."\\"..")") .. "..\\Functions\\?.lua"
	else
	package.path = package.path .. ";" .. script_path:match("(.*".."/"..")") .. "../Functions/?.lua"
	end
end
require("X-Raym_Functions - console debug messages")



function Get_Script() -- by name elements, by command ID, by section, from reaper-kb.ini
local sep = r.GetResourcePath():match('[\\/]') -- or package.config:sub(1,1)
local res_path = r.GetResourcePath()..sep -- path with separator
local cont
local f = io.open(res_path..'reaper-kb.ini', 'r')
	if f then -- if file available, just in case
	cont = f:read('*a')
	f:close()
	end
	if cont and cont ~= '' then
		for line in cont:gmatch('[^\n\r]*') do -- parse reaper-kb.ini code
		local sect, comm_ID, scr_path = line:match('SCR %d+ (%d+) (.+) "Custom: .+_Exclusive dummy toggle %d+%.lua" "(.+)"') -- line:match('SCR %d+ '..sect..' '..comm_ID..' "Custom: .+_Exclusive dummy toggle %d+%.lua" "(.+)"')
			if comm_ID then
			-- get subset assignment of a found dummy toggle script
			local f = io.open(res_path..'Scripts'..sep..scr_path, 'r') -- get script code
			local cont = f:read('*a')
			f:close()
			end
		end
	end
end


function set_script_instances_mode(path, sep, cmd_ID, scr_name, Esc)
-- set script mode to 260 to terminate deferred instances without the pop-up dialogue
-- since build 7.03 this can be done from the API with reaper.set_action_options()
local cmd_ID = r.ReverseNamedCommandLookup(cmd_ID)
local cmd_ID = cmd_ID:match('RS.-_') and cmd_ID:sub(8) or cmd_ID:sub(3) -- only look for ID without the prefix and the infix
local cont
local f = io.open(path..sep..'reaper-kb.ini', 'r')
	if f then -- if file available, just in case
	cont = f:read('*a')
	f:close()
	end
	if cont and cont ~= '' then
	local cont_new = cont -- to make sure the var data is updated along with the loop
		for line in cont:gmatch('[^\n\r]*') do
		local line = line:match('SCR 4.+'..cmd_ID..'.+')
			if line	then -- MIDI Editor section script
			local line_new = line:gsub('SCR 4', 'SCR 260')
			local line = Esc(line)
			cont_new = cont_new:gsub(line, line_new)
			end
		end
		if cont_new ~= cont then
		local f = io.open(path..sep..'reaper-kb.ini', 'w')
		f:write(cont_new)
		f:close()
		end
	end

end



function Parse_Script_Name1(scr_name)
-- meant for multi-functional scripts with mutually exclusive functionalities
-- which depend on the script name, e.g.
-- move forward, move backwards, select next, select previous, etc.
-- case agnostic
-- relies on Esc() function
local t = {'top','bottom','all up','all down','next','previous','explode','implode','crop'} -- EXAMPLE, the table can come as an argument from oustside
local t_len = #t -- store here since with nils length will be harder to get
	for k, elm in ipairs(t) do
	t[k] = scr_name:lower():match(Esc(elm:lower())) --or false -- to avoid nils in the table, although still works with the method below
	end
-- return table.unpack(t) -- without nils
return table.unpack(t,1,t_len) -- not sure why this works, not documented anywhere, but does return all values if some of them are nil even without the n value (table length) in the 1st field
-- found mentioned at
-- https://stackoverflow.com/a/1677358/8883033
-- https://stackoverflow.com/questions/1672985/lua-unpack-bug
-- https://uopilot.tati.pro/index.php?title=Unpack_(Lua)
end
-- USAGE EXAMPLE:
-- local top, bottom, up, down, nxt, prev, explode, implode, crop = Get_Script_Name(scr_name)



function Parse_Script_Name2(scr_name, t)
-- meant for multi-functional scripts with mutually exclusive functionalities
-- which depend on the script name, e.g.
-- move forward, move backwards, select next, select previous, etc.
-- t contains strings of key words definding functionality included in the script name
-- case agnostic
-- relies on Esc() function
local t_len = #t -- store here since with nils length will be harder to get
	for k, elm in ipairs(t) do
	t[k] = scr_name:lower():match(Esc(elm:lower())) --or false -- to avoid nils in the table, although still works with the method below
	end
-- return table.unpack(t) -- without nils
return table.unpack(t,1,t_len) -- not sure why this works, not documented anywhere, but does return all values if some of them are nil even without the n value (table length) in the 1st field
-- found mentioned at
-- https://stackoverflow.com/a/1677358/8883033
-- https://stackoverflow.com/questions/1672985/lua-unpack-bug
-- https://uopilot.tati.pro/index.php?title=Unpack_(Lua)
end



function Parse_Script_Name3(scr_name, ...)
-- meant for multi-functional scripts with mutually exclusive functionalities
-- which depend on the script name, e.g.
-- move forward, move backwards, select next, select previous, etc.
-- t contains strings of key words definding functionality included in the script name
-- case agnostic
-- relies on Esc() function
local t = {...}
local t_len = #t -- store here since with nils length will be harder to get
	for k, elm in ipairs(t) do
	t[k] = scr_name:lower():match(Esc(elm:lower())) --or false -- to avoid nils in the table, although still works with the method below
	end
-- return table.unpack(t) -- without nils
return table.unpack(t,1,t_len) -- not sure why this works, not documented anywhere, but does return all values if some of them are nil even without the n value (table length) in the 1st field
-- found mentioned at
-- https://stackoverflow.com/a/1677358/8883033
-- https://stackoverflow.com/questions/1672985/lua-unpack-bug
-- https://uopilot.tati.pro/index.php?title=Unpack_(Lua)
end



function Invalid_Script_Name1(scr_name,...)
-- check if necessary elements are found in script name, case agnostic
-- if more than 1 match is needed run twice or more times with different sets of elements which are supposed to appear in the same name, but elements within each set must not be expected to appear in the same name, that is they must be mutually exclusive
-- if running twice or more times the error message and Rep() function must be used outside of this function after expression 'if no_elm1 or no_elm2 then'

local t = {...}

local found
	for k, elm in ipairs(t) do
		if scr_name:lower():match(Esc(elm:lower())) then found = 1 end
	end

	if #t > 0 and not found then -- no keyword was found in the script name
		local function Rep(n) -- number of repeats, integer
		return (' '):rep(n)
		end
	local br = '\n\n'
	r.MB([[The script name has been changed]]..br..Rep(7)..[[which renders it inoperable.]]..br..
	[[   please restore the original name]]..br..[[  referring to the list in the header,]]..br..
	Rep(9)..[[or reinstall it.]], 'ERROR', 0)
--[[ OR using Error_Tooltip()
	local err = 'The script name has been changed\n\n    which renders it inoperable. \n\n'
..' please restore the original name\n\n\t referring to the names\n\n\t\t in the header,\n\n'
..'\tor reinstall the package.'
	Error_Tooltip('\n\n '..err..' \n\n', 1, 1, -200, 20) -- caps, spaced true, x2 -200, y2 20 // display the value placing the tooltip away from mouse cursor in case the script is run with a click otherwise tooltip blocks next mouse event
	]]
	return true
	end

end
-- USAGE EXAMPLE:
-- Invalid_Script_Name(scr_name, 'right', 'left', 'tracks', 'items')
--[[
-- EXAMPLE when several matches are required:
-- validate script name
local elm1 = Invalid_Script_Name(scr_name,table.unpack(type_t))
local elm2 = Invalid_Script_Name(scr_name,'left','right')
	if not (elm1 or elm2) then
	local br = '\n\n'
	r.MB([[The script name has been changed]]..br..Rep(7)..[[which renders it inoperable.]]..br..
	[[   please restore the original name]]..br..[[  referring to the list in the header,]]..br..
	Rep(9)..[[or reinstall the package.]], 'ERROR', 0)
	return r.defer(function() do return end end) end
]]


function Invalid_Script_Name2(scr_name,...)
-- check if necessary elements are found in script name, case agnostic
-- if more than 1 match is needed, run twice or more times with different sets of elements which are supposed to appear in the same name, but elements within each set must not be expected to appear in the same name, that is they must be mutually exclusive
-- if running twice or more times the error message and Rep() function must be used outside of this function after expression 'if no_elm1 or no_elm2 then'

local t = {...}

	for k, elm in ipairs(t) do
		if scr_name:lower():match(Esc(elm:lower())) then return end -- at least one match was found
	end

	local function Rep(n) -- number of repeats, integer
	return (' '):rep(n)
	end

-- either no keyword was found in the script name or no keyword arguments were supplied
local br = '\n\n'
r.MB([[The script name has been changed]]..br..Rep(7)..[[which renders it inoperable.]]..br..
[[   please restore the original name]]..br..[[  referring to the list in the header,]]..br..
Rep(9)..[[or reinstall it.]], 'ERROR', 0)
return true

end



function Invalid_Script_Name3(scr_name,...)
-- check if necessary elements, case agnostic, are found in script name and return the one found
-- only execute once
local t = {...}

	for k, elm in ipairs(t) do
		if scr_name:lower():match(Esc(elm:lower())) then return elm end -- at least one match was found
	end

	local function Rep(n) -- number of repeats, integer
	return (' '):rep(n)
	end

-- either no keyword was found in the script name or no keyword arguments were supplied
local br = '\n\n'
r.MB([[The script name has been changed]]..br..Rep(7)..[[which renders it inoperable.]]..br..
[[   please restore the original name]]..br..[[  referring to the name in the header,]]..br..
Rep(9)..[[or reinstall it.]], 'ERROR', 0)

end
-- USE:
--[[
local keyword = Invalid_Script_Name3(scr_name, 'right', 'left', 'up', 'down')
	if not keyword then return r.defer(no_undo) end

	if keyword == 'right' then
	-- DO STUFF
	elseif keyword == 'left' then
	-- DO STUFF
	-- ETC.
	end
]]


function Dir_Exists1(path) -- see version 2 below
-- check if directory exists, if not returns nil, if yes and no files - empty string
-- 2nd return value error message, if no match then nil
-- path is a directory path, not file

-- path evaluation can be added

-- fix path lacking closing separator and with leading/trailing spaces
--local sep = r.GetOS():match('Win') and '\\' or '/'
--local path = not path:match('.+[\\/]%s*$') and path:match('^%s*(.-)%s*$')..sep or path:match('^%s*(.+'..sep..')%s*$') -- add last separator if none and remove leading/trailing spaces

local path = path:match('^%s*(.-)%s*$') -- remove leading/trailing spaces
local sep = path:match('[\\/]')
local path = path..(not path:match('.+[\\/]$') and path:match('[\\/]') or '') -- add last separator if none

local path = path:match('.+[\\/]$') and path:sub(1,-2) or path -- if there's separator remove it // not always necessary
local _, mess = io.open(path:sub(1,-2)) -- last separator is removed to return 1 (valid)
local result = #path:gsub('[%c%.]', '') > 0 and mess and (mess:match('Permission denied') and 1 -- or 'and path..sep' // dir exists // this one is enough HOWEVER THIS IS ALSO THE RESULT IF THE path var ONLY INCLUDES DOTS, therefore gsub ensures that besides dots there're other characters
or mess:match('No such file or directory') and 2
or mess:match('Invalid argument') and 3) -- leading and/or trailing spaces in the path or empty string
return result
end


function Dir_Exists2(path) -- short
-- path is a directory path, not file
local path = path:match('^%s*(.-)%s*$') -- remove leading/trailing spaces // OR ('(%S.+)%s*$')
local sep = path:match('[\\/]')
	if not sep then return end -- likely not a string representing a path
local path = path:match('.+[\\/]$') and path:sub(1,-2) or path -- last separator is removed so the path is properly formatted for io.open()
local _, mess = io.open(path)
return #path:gsub('[%c%.]', '') > 0 and mess and mess:match('Permission denied') and path..sep -- dir exists // this one is enough HOWEVER THIS IS ALSO THE RESULT IF THE path var ONLY INCLUDES DOTS, therefore gsub ensures that besides dots there're other characters
end


function File_Exists1(path)
local f, mess = io.open(path, 'r')
	if mess and mess:match('No such file or directory') then return
	else f:close() return true
	end
end


function File_Exists2(path)
local f, mess = io.open(path, 'r')
	if f then f:close()
	elseif mess and mess:match('No such file or directory') then return 
	end
return true
end


function File_Exists3(name, path, ext, sep)
local sep = sep or path:match('[\\/]')
local path = path:match('.+[\\/]$') and path or path..sep -- add trailing separator if not included
return package.searchpath(name, path..'?.'..ext)
end


function file_exists_alt(path) -- a fix for the buggy ReaScript API function
-- file_exists() returns true if passed a file name only and a file with the same name
-- is found in the current working directory, which is a bug https://forum.cockos.com/showthread.php?t=300386
-- so must be additionaly validated
	if not path:match('[\\/]') -- excluding file names without a path, i.e. without separators, due to the bug mentioned above
	or not r.file_exists(path) then
	return
	end
end


function make_file_name_unique(f_path)
-- prevent file name clash
-- relies on any of File_Exists1, File_Exists2 or file_exists_alt functions above
local name, path, ext, sep = f_path:match('.+[\\/](.+)'), f_path:match('(.+)[\\/]'), 
f_path:match('.+(%..+)$'), f_path:match('[\\/]')
	if File_Exists2(name, path, ext, sep) then 
	return f_path:sub(1,-#ext-1)..'_'..(os.time()+0)..ext -- os.date('%H-%M-%S_%d.%m.%y') insted of (os.time()+0)	
	end 
return f_path
end


function file_status(path)
-- based on https://www.tutorialspoint.com/lua/index.htm
-- returned status: readable, writable
-- if readable but not writable then readonly
-- if neither then either the file doesn't exist or the path is invalid
local t = {true}
	for k, v in ipairs({'r','w'}) do
	t[k] = t[1] and io.open(path, v) -- initial true t[1] conditions opening in read mode, then opening in write mode depends on the result of the read mode stored in t[1], because if file doesn't exist, attempt to open it in write mode first will create it, which is not what we need
		if t[k] then t[k]:close() end
	end
return t
end


function move_file_to_another_folder(file_path, folder_path, delete_old)
-- DOES NOT RESOLVE FILE NAME COLLISIONS
-- folder_path is path of the new folder, must not end with a separator
-- delete_old is boolean to delete file at its old location
local sep = folder_path:match('[\\/]')
local f = io.open(file_path,'rb')
local cont = f:read('*a')
f:close()
local file_name = file_path:match('.+[\\/](.+)')
local new_path = folder_path..sep..file_name
local f = io.open(new_path, 'wb') -- open at new location
f:write(cont)
f:close()
-- validate
local f = io.open(new_path, 'rb')
	if f:read('*a') == cont and delete_old then -- if identical to original
	os.remove(file_path) -- remove from old location
	end
f:close()
end


-- Validate path supplied in the user settings
function Validate_Folder_Path(path) -- returns empty string if path is empty and nil if it's not a string
	if type(path) == 'string' then
	local path = path:match('^%s*(.-)%s*$') -- remove leading/trailing spaces // OR ('(%S.+)%s*$')
	-- return not path:match('.+[\\/]$') and path:match('[\\/]') and path..path:match('[\\/]') or path -- add last separator if none
-- more efficient:
	return path..(not path:match('.+[\\/]$') and path:match('[\\/]') or '') -- add last separator if none
	end
end

--[[ EXAMPLE OF USAGE to validate custom path

-- [%s%c] is used if the path setting if the path is formatted as literal string [[ ]]
CUSTOM_FX_CHAIN_DIR = #CUSTOM_FX_CHAIN_DIR:gsub('[%s%c]','') > 0 and CUSTOM_FX_CHAIN_DIR

local fx_chain_dir = CUSTOM_FX_CHAIN_DIR and Dir_Exists(Validate_Folder_Path(CUSTOM_FX_CHAIN_DIR)) or path..sep..'FXChains'..sep

	if CUSTOM_FX_CHAIN_DIR and fx_chain_dir == path..sep..'FXChains'..sep then
	Error_Tooltip('\n\n        custom fx chain \n\n     directory isn\'t valid \n\n opening default directory \n\n')
	end

]]


function print_or_write_to_file(str, PATH_TO_DUMP_FILE, file_name) -- PATH_DO_DUMP_FILE is a directory path; uses 2 additional functions Dir_Exists() and open_dir_in_file_browser() // the routine is used in 'List all linked FX parameters in the project.lua'

	if #str <= 16380 then -- print to ReaConsole
	-- ReaScript console can display maximum of 16,382 (almost 16,384) bytes. Couldn't go any higher. Once this number is exceeded the printed content is cut by 2,052 (a little over 2,048) bytes. And as far as i understand the process is repeated from there on out.
	-- https://forum.cockos.com/showthread.php?t=216979#5
--Msg(str)
	else -- dump to a file because ReaScript Console won't display the whole list
	local dir = Dir_Exists(PATH_TO_DUMP_FILE)
		if not dir then -- if dir is empty or otherwise invalid dump into the REAPER resource directory
		dir = r.GetResourcePath()..r.GetResourcePath():match('[\\/]') end -- or package.config:sub(1,1) to get the separator
	local f = io.open(dir..file_name, 'w')
	f:write(str)
--	local f_exists = io.input(dir..file_name) -- must come before close(); throws generic lua error message on failure hence unsuitable
	f:close()
	local f_exists = r.file_exists(dir..file_name)
		if f_exists then
--Msg(dir:sub(1,-1))
		local path = (dir == PATH_TO_DUMP_FILE or dir:sub(1,-2) == PATH_TO_DUMP_FILE) and 'designated' -- user dir either with or without the last separator
		or 'REAPER resource'
		local space = path == 'designated' and (' '):rep(5) or ''
		local resp = r.MB(' The list has been saved to a file\n\n'..space..'in the '..path..' directory.\n\n       Open the directory now?', 'PROMPT', 4)
			if resp == 6 then open_dir_in_file_browser(dir) end -- if dir is system root with slash, e.g. 'C:/' opens 'My Documents' on Windows, must be either 'C:\\'
		end
	end

end


local path = reaper.GetResourcePath()
function ScanPath1(path)
-- Recursve fetching of directory structure and files // MPL, Lokasenna // https://forum.cockos.com/showthread.php?t=206933 // the path must not end with a separator
    local t = {} -- must be clean otherwise the path will each time be added twice, as a main path and as a subdir
    local subdirindex, fileindex = 0,0
    local path_child
    repeat
        path_child = reaper.EnumerateSubdirectories(path, subdirindex)
        if path_child then
            table.insert(t,path_child)
            local tmp = ScanPath(path .. "/" .. path_child)
            for i = 1, #tmp do
                --table.insert(t, path .. "/" .. path_child .. "/" .. tmp[i])
                table.insert(t, tmp[i])
            end
        end
        subdirindex = subdirindex+1
    until not path_child

    repeat
        fn = reaper.EnumerateFiles( path, fileindex )
        if fn then
            --t[#t+1] = path .. "/" .. fn
            t[#t+1] = fn
        end
        fileindex = fileindex+1
    until not fn

    return t
end

local t = ScanPath(path)


-- My version
function ScanPath2(path)
local path = path:match('^%s*(.-)%s*$') -- trim spaces
local path = #path > 0 and path:match('.+[\\/]$') and path:match('(.+)[\\/]$') or path -- remove last separator if any
local sep = path:match('[\\/]') and path:match('[\\/]') or '' -- extract the separator
    local t = {}
    local subdir_idx, file_idx = 0, 0
    local subdir
    repeat
    local subdir = r.EnumerateSubdirectories(path, subdir_idx)
        if subdir then
		t[#t+1] = path..sep..subdir..sep -- for file scan separator isn't needed as EnumerateFiles() works without it
        local tmp = ScanPath(path..sep..subdir)
	table.sort(tmp, function(a,b) return tonumber(a:match('.+[\\/](.-)$')) < tonumber(b:match('.+[\\/](.-)$')) end) -- sort paths by the last folder name IF IT'S NUMERIC in case the numbers aren't preceded with 0 and 10 appears earlier than 2, alphabetical names are sorted automatically
			for i = 1, #tmp do
            t[#t+1] = tmp[i]
            end
        end
    subdir_idx = subdir_idx + 1
    until not subdir

	repeat
	local fn = r.EnumerateFiles(path, file_idx)
		if fn then
        t[#t+1] = path..sep..fn
        end
	file_idx = file_idx + 1
	until not fn

    return t
end


function scandir(dir) -- not for Mac; REAPER API already has r.EnumerateSubdirectories()
-- https://forum.cockos.com/showthread.php?t=159547
-- A less elegant solution to get a directory list in lua without additional libraries is to use the os.execute and write the lines to a buffer. Works like a charm but you do get a very quick terminal window popping open to execute it. I used it a few times on my File Manager script if you want to see an example. This works on Mac. Instead of os.execute the native r.ExecProcess() could probably be used
local i, t, popen = 0, {}, io.popen
    for filename in popen('dir "'..dir..'" /b'):lines() do
        msg(filename)
        i = i + 1
        t[i] = filename
    end
    return t
end



function Count_Files_In_Folder(path,ext)
--r.EnumerateFiles(path..'..', 0) -- reset EnumerateFiles() cache by accessing a valid dummy dir, e.g. r.EnumerateFiles(r.GetResourcePath(), 0)
--r.EnumerateFiles(path, -1) -- -1 to clear the cache, or pass another directory (invalid one is suppported), since 6.20
-- https://forum.cockos.com/showthread.php?t=203235
-- applies to r.EnumerateSubdirectories() as well
local i = 0
local f_cnt = 0
	repeat
	local file_n = r.EnumerateFiles(path, i)
		if file_n and file_n:match('%.reapeaks') then os.remove(path..file_n) end -- delete .reapeaks files
	i = i + 1
		if file_n and file_n:match(''..ext..'$') then f_cnt = f_cnt+1 end
	until not file_n
return f_cnt
end


function Remove_Peak_Files(path)
local i = 0
	repeat
	local file_n = r.EnumerateFiles(path, i)
		if file_n and file_n:match('%.reapeaks') then os.remove(path..file_n) end -- delete .reapeaks files
	i = i + 1
	until not file_n
end



function get_file_timestamp1(file_name) -- without seconds // Windows only
-- https://superuser.com/questions/1277743/fast-built-in-command-to-get-the-last-modified-date-of-a-file-in-windows
-- https://stackoverflow.com/questions/33296834/how-can-i-get-last-modified-timestamp-in-lua
-- https://stackoverflow.com/questions/2111333/how-to-get-last-modified-date-on-windows-command-line-for-a-set-of-files
-- https://www.windows-commandline.com/dir-command-line-options/
-- https://www.windows-commandline.com/find-files-based-on-modified-time/
-- https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/dir
-- https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/forfiles
-- https://ab57.ru/cmdlist/forfiles.html
-- https://stackoverflow.com/questions/515309/what-does-cmd-c-mean
-- https://forum.cockos.com/showpost.php?p=1867737&postcount=6
local path = r.GetResourcePath()
local file = '"'..path..path:match('[\\/]')..file_name..'"'--'reaper-screensets.ini"'
return r.ExecProcess('cmd.exe /C dir \tw '..file, 0):match('.+\n(.-%d+:%d+)') -- command is a command line string, timeout is number in ms timeout is 0, command will be allowed to run indefinitely (for large amounts of returned output), timeout -1 for no wait/terminate, -2 for no wait and minimize
end


function get_file_timestamp2(file_name, dir) -- both args are strings // dir MUST NOT end with separator, if dir isn't provided file arg must be full path // Windows only // special chars in args must either be escaped or the args inclosed in [[]]
-- https://www.dostips.com/forum/viewtopic.php?t=6063#p38222 which helped to figure out the forfiles syntax
	if not dir then -- time without seconds
	return r.ExecProcess('cmd.exe /C dir \tw "'..file_name..'"', 0):match('.+\n(.-%d+:%d+)')
	else -- time with seconds
	local dir = #dir == 3 and dir or '"'..dir..'"' -- when not root as root doesn't allow quotes
	return r.ExecProcess('forfiles /P '..dir..' /M "'..file_name..'" /C "cmd /c echo @fdate @ftime"', 0):match('.+\n(.+)\n') -- excluding trailing empty line // in command prompt quotes around the dir path are only allowed if it's not root and required when it contains spaces, in file name they are required when it contains spaces; so basically they should be there as a safeguard except when the dir is root // can in fact be the only one syntax BUT dir and file must be splat up
	end
end


-- streamlined
function get_file_timestamp3(file_name, dir) -- both args are strings // dir MUST NOT end with separator, if dir isn't provided file arg must be full path // Windows only // special chars in args must either be escaped or the args inclosed in [[]]
local command
local capt
	if not dir then -- time without seconds
	command, capt = 'cmd.exe /C dir \tw "'..file_name..'"', '.+\n(.-%d+:%d+)'
	return r.ExecProcess('cmd.exe /C dir \tw "'..file_name..'"', 0):match('.+\n(.-%d+:%d+)')
	else -- time with seconds
	local dir = #dir > 3 and dir:match('.+[\\/]$') and dir:match('(.+)[\\/]') or dir -- remove last separator if any in dir other than the root
	local dir = #dir == 3 and dir or '"'..dir..'"' -- when not root as root doesn't allow quotes
	command, capt = 'forfiles /P '..dir..' /M "'..file_name..'" /C "cmd /c echo @fdate @ftime"', '.+\n(.+)\n' -- excluding trailing empty line
	end
return r.ExecProcess(command, 0):match(capt)
end

-- streamlined +
function get_file_timestamp4(full_file_path) -- time with seconds
local dir, file_name = full_file_path:match('(.+)[\\/](.+)') -- makes sure that dir doesn't end with separator
local dir = #dir == 3 and dir or '"'..dir..'"' -- when not root as root doesn't allow quotes
return r.ExecProcess('forfiles /P '..dir..' /M "'..file_name..'" /C "cmd /c echo @fdate @ftime"', 0):match('.+\n(.+)\n') -- excluding trailing empty line
end



function open_dir_in_file_browser(dir)
-- REAPER Profile terminal_CLEAN.lua
local OS = r.GetOS():sub(1,3)
local command = OS == 'Win' and {'explorer'} or (OS == 'OSX' or OS == 'mac') and {'open'} or {'nautilus', 'dolphin', 'gnome-open', 'xdg-open', 'gio open', 'caja', 'browse'}
-- https://askubuntu.com/questions/31069/how-to-open-a-file-manager-of-the-current-directory-in-the-terminal
	for k,v in ipairs(command) do
	local result = r.ExecProcess(v..' '..dir, -1) -- timeoutmsec is -1 = no wait/terminate // -- if dir is system root with slash, e.g. C:/ opens 'My Documents' on Windows, must be either 'C:' or 'C:\\'
		if result then return end
	end
end


function delete_string_from_file(f_path, to_delete) -- to_delete arg is a string
-- f_path = r.GetResourcePath()..r.GetResourcePath():match('[\\/]')..'reaper-extstate.ini -- or package.config:sub(1,1) to get the separator
local f = io.open(f_path', 'r')
local cont = f:read('*a')
f:close()
local cont_new = cont:gsub(to_delete, '')
local f = io.open(f_path, 'w')
f:write(cont_new)
f:close()
end


function Read_Lines(file_path) -- same as io.lines()
local f = io.open(file_path,'r')
return function(f) return f:read('*l') end -- while the Lua function returns nil at the end of file (EOF), this function does not
end
-- to use:
-- for line in Read_Lines(file_path) do
-- STUFF
-- end


function get_ini_file_path(ini_file_name)
	if not ini_file_name or #ini_file_name == 0 then return '' end
local path = r.GetResourcePath()
return path..path:match('[\\/]')..ini_file_name
end


function get_proj_path()
local _, projfn = r.EnumProjects(-1) -- active
return projfn -- empty string for a project with no file, if the proj file was deleted while the project is open will still return its full path
-- OR
--local path = r.GetProjectPath('')
--return path..path:match('[\\/]')..r.GetProjectName(0,'')
end


function get_proj_title(projpath) -- local _, projpath = r.EnumProjects(idx) -- -1 current

	local function get_from_file(projpath)
	local f = io.open(projpath,'r')
	local cont = f:read('*a')
	f:close()
	return cont:match('TITLE "?(.-)"?\n') -- quotation marks only if there're spaces in the title
	end

local proj_title, retval

local i = 0
	repeat
	local ret, projfn = r.EnumProjects(i) -- find if the project is open in a tab
		if projfn == projpath then retval = ret break end
	i = i+1
	until not ret
	if retval then -- the project is open in a tab
		if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.43 then -- or '[%d%.]+'; if can be retrieved via API regardless of being saved to the project file // API for getting title was added in 6.43
		retval, proj_title = r.GetSetProjectInfo_String(retval, 'PROJECT_TITLE', '', false) -- is_set false // retval is a proj pointer, not an index
		else -- retrieve from file which in theory may be different from the latest title in case the project hasn't been saved
		proj_title = get_from_file(projpath)
		end
	else
	proj_title = get_from_file(projpath)
	end

	return proj_title and proj_title:match('[%w]+') and proj_title -- if there're any alphanumeric chars // proj_title can be nil when extracted from .RPP file because without the title there's no TITLE key, if returned by the API function it's an empty string, when getting, retval is useless because it's always true unless the attribute, i.e. 'PROJECT_TITLE', is an empty string or invalid

end


function get_ini_cont()
local f = io.open(r.get_ini_file(), 'r')
local cont = f:read('*a')
f:close()
return cont
end


function Check_reaper_ini(section, key, value)
-- the args must be strings
-- section is the one found in reaper.ini file
-- and needs not to include square brackets
-- if the key isn't subsumed under any section
-- section arg can be nil
-- however to get values of standalone keys
-- reaper.get_config_var_string() is more efficient;
-- value arg is optional, only useful if
-- you expect a certain value to be able
-- to verify if it's set

--[-[-- METHOD 1
local found
	for line in io.lines(r.get_ini_file()) do
		if section and line == '['..section..']' then found = 1
		elseif not section then
		val = line:match(key..'=(.+)')
			if val then return val, val == value end
		elseif found then
		local val = line:match(key..'=(.+)')
			if val then return val, val == value end
		end
	end
--]]

--[[
---- METHOD 2
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
cont = cont..'\n' -- add in case there's no terminating new line so that the capture works on the very last line as well
local patt = '.-\n'..key..'=(.-)\n'
local patt = section and '['..section..']'..patt or patt
local val = cont:match(patt)
--local val = cont:match(key..'=([%.%d]+)') == value -- OR '=(.-)\n'
-- OR SIMPLY: return cont:match(key..'=([%.%d]+)') == value
return val, val == value
--]]
end
-- same as the native
-- retval, buf = reaper.get_config_var_string()
-- BUT ONLY IF key/value aren't subsumed under a separate section


function Extract_reaper_ini_val1(key) -- the arg must be string
-- same as reaper.get_config_var_string(), see below
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
return cont:match(key..'=(.-)\n')
end


function Extract_reaper_ini_val2(key) -- the arg must be string
local ret, val = r.get_config_var_string(key)
return val
end



function Get_File_Cont(f_path)
local f = io.open(f_path,'r')
local cont = f:read('*a')
f:close()
return cont
end


function Get_Or_Create_Dummy_Project_File1()
-- see also Open_Close_Temp_Proj_Tab_Without_Save_Prompt()
-- since when opened, dummy project reference is added to the 'Recent projects' menu
-- provided the preference at 
-- Prefs -> General -> Recent projects list display button -> Add to recent list when loading project is enabled (and it's enabled by default)
-- it's advised that it be stored in a constant path, because each new path
-- is a new entry in the menu
-- project templates path may be used instead but the dummy file will be listed
-- in the project template menu
local _, script_path, sect_ID, cmd_ID, _,_,_ = r.get_action_context()
-- OR
-- local script_path = debug.getinfo(1,'S').source:match('@(.+[\\/])') -- without the name
local section, key = ('DUMMY PROJECT FILE'):reverse(), ('PATH'):reverse()
local dummy_proj = r.GetExtState(section, key)
dummy_proj = r.file_exists(dummy_proj) and dummy_proj
or script_path:match('.+[\\/]')..'BuyOne_dummy project (do not rename).RPP'
	if not r.file_exists(dummy_proj) then -- create a dummy project file next to the script
	r.SetExtState(section, key, dummy_proj, true) -- persist true
	local f = io.open(dummy_proj,'w')
	f:write('<REAPER_PROJECT\nTITLE "THIS FILE IS USED BY SOME SCRIPTS"\n>')
	f:close()
	end
return dummy_proj
end


function Get_Or_Create_Dummy_Project_File2()
-- see also Open_Close_Temp_Proj_Tab_Without_Save_Prompt()
-- since when opened, dummy project reference is added to the 'Recent projects' menu
-- provided the preference at 
-- Prefs -> General -> Recent projects list display button -> Add to recent list when loading project is enabled (and it's enabled by default)
-- it's advised that it be stored in a constant path, because each new path
-- is a new entry in the menu
-- project templates path may be used instead but the dummy file will be listed
-- in the project template menu
local path = os.getenv('TEMP') or os.getenv('TMP') -- path to the system temp folder
	if #path > 0 then
	local sep = path:match('[\\/]')
	-- OR
	-- sep = package.config:match("([^\n]*)\n?")
	-- OR
	-- sep = r.GetResourcePath():match('[\\/]')
	local section, key = ('DUMMY PROJECT FILE'):reverse(), ('PATH'):reverse()
	local dummy_proj = r.GetExtState(section, key)
	dummy_proj = r.file_exists(dummy_proj) and dummy_proj or path..sep..'dummy REAPER project.RPP'
		if not r.file_exists(dummy_proj) then
		r.SetExtState(section, key, dummy_proj, true) -- persist true
		local f = io.open(dummy_proj,'w')
		f:write('<REAPER_PROJECT\nTITLE "THIS FILE IS USED BY SOME SCRIPTS"\n>')
		f:close()
		end
	return dummy_proj
	end
end



function META_Spawn_Scripts(fullpath, scr_name, names_t)
-- fullpath is get_action_context() return value
-- scr_name is META script name
-- names_t is a table containing individual script names
-- if not supplied or empty the names are searched in the script header
-- names in the header must not have trailing spaces

	local function Dir_Exists(path) -- short
	local path = path:match('^%s*(.-)%s*$') -- remove leading/trailing spaces
	local sep = path:match('[\\/]')
	local path = path:match('.+[\\/]$') and path:sub(1,-2) or path -- last separator is removed to return 1 (valid)
	local _, mess = io.open(path)
	return mess:match('Permission denied') and path..sep -- dir exists // this one is enough
	end

	local function Esc(str)
		if not str then return end -- prevents error
	-- isolating the 1st return value so that if vars are initialized in a row outside of the function the next var isn't assigned the 2nd return value
	local str = str:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0')
	return str
	end

	if not fullpath:match(Esc(scr_name)) then return true end -- will allow to continue the script execution outside, since it's not a META script

local names_t, content = names_t

	if not names_t or names_t == 0 then -- if names table isn't supplied search names list in the header
	-- load this script
	local this_script = io.open(fullpath, 'r')
	content = this_script:read('*a')
	this_script:close()
	names_t, found = {}
		for line in content:gmatch('[^\n\r]+') do
			if line and line:match('Provides') then found = 1 end
			if found and line:match('%.lua') then
			names_t[#names_t+1] = line:match('.+[/](.+[%w])') or line:match('BuyOne.+[%w]') -- in case the new script name line includes a subfolder path, the subfolder won't be created, trimming trailing spaces if any because they invalidate file path
			elseif found and #names_t > 0 then
			break -- the list has ended
			end
		end
	end

	if names_t and #names_t > 0 then

	r.MB('              This meta script will spawn '..#names_t
	..'\n\n     individual scripts included in the package'
	..'\n\n     after you supply a path to the directory\n\n\t    they will be placed in'
	..'\n\n\twhich can be temporary.\n\n           After that the spawned scripts'
	..'\n\n will have to be imported into the Action list.','META',0)

	local ret, output -- to be able to autofill the dialogue with last entry on RELOAD

	::RETRY::
	ret, output = r.GetUserInputs('Scripts destination folder', 1,
	'Full path to the dest. folder, extrawidth=200', output or '')

		if not ret or #output:gsub('[%s%c]','') == 0 then return end -- must be aborted outside of the function

	local user_path = Dir_Exists(output) -- validate user supplied path
		if not user_path then Error_Tooltip('\n\n invalid path \n\n', 1, 1) -- caps, spaced true
		goto RETRY end

		-- load this script if wasn't loaded above to parse the header for file names list
		if not content then
		local this_script = io.open(fullpath, 'r')
		content = this_script:read('*a')
		this_script:close()
		end

		local prefix, insert = 'BuyOne_', 'selected automation item' -- script specific
		-- spawn scripts
		for k, scr_name in ipairs(names_t) do
		--[[ --- script specific
			if scr_name:match('edge') then
			scr_name = scr_name:gsub('edge', '%0 of '..insert)
			elseif scr_name:match('Move contents') then
			scr_name = scr_name:gsub('Move contents', '%0 of '..insert)
			elseif scr_name:match('Move') then
			scr_name = scr_name:gsub('Move', '%0 '..insert)
			end
		scr_name = prefix..scr_name..'.lua'
		content = content:gsub('ReaScript name:.-\n', 'ReaScript name: '..scr_name..'\n', 1) -- replace script name in the About tag
		]]
		local new_script = io.open(user_path..scr_name, 'w') -- create new file
		content = content:gsub('ReaScript name:.-\n', 'ReaScript name: '..scr_name..'\n', 1) -- replace script name in the About tag
		new_script:write(content)
		new_script:close()
		end
	end

end
--[[
USE:
	-- doesn't run in non-META scripts
	if not META_Spawn_Scripts(fullpath, FULL_META_SCRIPT_NAME, names_t) -- fullpath stems from get_action_context()
	then return r.defer(no_undo) end -- abort if META script but continue if not
]]



function GetActionCommandIDByFilename(filename)
-- https://github.com/ReaTeam/ReaScripts/pull/1301/files#diff-fcda7b077c9cd946c72884da52892a3e7a9eef2277562fd92630388cd55fd2a2
-- OR
-- https://github.com/mattia-marini/ReaScripts/blob/ce965acc9b26768dd46fe3d8f2b280e47030fdc4/FX/ReaLink/Marini_ReaLink_Background.lua#L4

	for k in io.lines(r.GetResourcePath() .. "/reaper-kb.ini") do
		if k:match("SCR") and k:match(filename) then
		  return "_" .. k:match("SCR %d+ %d+ (%S*) ")
		end
	end
end



function Get_CommID_By_Script_Name(scriptName)
-- https://raw.githubusercontent.com/NablaTools/Nabla/main/Looper%20A/Nabla%20Looper%20A%20-%20Settings.lua
	
	if type(scriptName)~="string" then
	error("expects a 'string', got "..type(scriptName),2)
	end;

local file = io.open(reaper.GetResourcePath()..'/reaper-kb.ini','r');

	if not file then
	return -1
	end;

local scrName = string.gsub(string.gsub(scriptName, 'Script:%s+',''), "[%%%[%]%(%)%*%+%-%.%?%^%$]",function(s)return"%"..s;end);

	for var in file:lines() do;
		if match(var, scrName) then
		id = "_"..gsub(gsub(match(var, ".-%s+.-%s+.-%s+(.-)%s"),'"',""), "'","")
		return id
		else
		--
		end
	end;

return -1;

end




function Get_Set_Script_Cont(scr_path, new_cont)
-- either retrieve script content or update it if new_cont arg is valid
local mode = new_cont and 'w' or 'r' -- write or read
local f = io.open(scr_path, mode)
local cont = not new_cont and f:read('*a')
	if new_cont then f:write(new_cont) end
f:close()
return not new_cont and cont
end


function Get_File_Size1(path)
-- https://www.lua.org/pil/21.3.html
local f = io.open(path,'rb')
	if f then
	local curr = f:seek() -- get current position
	local size, err = f:seek('end') -- get file size
	f:seek('set', curr) -- restore position
	f:close()
	return size, size/1024, size/(1024^2) -- return bytes, kbytes and mbytes
	end
end


function Get_File_Size2(file_handle)
-- https://stackoverflow.com/questions/10712622/how-to-get-the-file-size-and-delete-file-in-lua
file_handle:seek('set',0) -- reset to start
local size, err = file_handle:seek('end')
return size, size/1024, size/(1024^2) -- return bytes, kbytes and mbytes
end


function Get_File_Size3(filename)
-- https://stackoverflow.com/a/36766381/8883033
-- returns file size (or nil if the file doesn't exist or unable to open)
local command = 'cmd /d/c for %f in ("'..filename..'") do @echo(%~zf'
return tonumber(io.popen(command):read('*a')) -- OR r.ExecProcess(command, 0) -- timeoutmsec 0 -- no limit
end


function Get_File_Size4(file_path, mode) -- used inside remove_duplicates_from_other_folders()
-- mode is either 'r' for strings and 'rb' for binaries
local f = io.open(file_path, mode)
	if f then
	local cont = f:read('*a')
	f:close()
	return #cont
	end
end



-- if run via dofile() from another script in which case get_action_context()
-- returns host script properties
-- local fullpath = debug.getinfo(1,'S').source:match('^@?(.+)')
function Script_Is_Installed(fullpath)
-- evaluate by the script full path being found in reaper-kb.ini
local sep = r.GetResourcePath():match('[\\/]')
	for line in io.lines(r.GetResourcePath()..sep..'reaper-kb.ini') do
	local path = line and line:match('.-%.lua["%s]*(.-)"?')
		if path and #path > 0 and fullpath:match(Esc(path)) then -- installed
		return true end
	end
end

-- if run via dofile() from another script in which case get_action_context()
-- returns host script properties hence the script name evaluation will be false
-- and will only be true if the script is run directly,
-- that's unless the host and the target script names are identical which is extremely unlikely
-- local is_new_value, fullpath_init, sect_ID, cmd_ID, mode, resol, val = r.get_action_context()
function Script_Is_Run_Via_dofile(fullpath_init, scr_name)
return fullpath_init:match('.+[\\/](.+)') == scr_name
end


-- 'loadfile' syntax
-- execute external file placing its global variables in a separate table
-- from which the loaded file will retrieve them
-- so they don't accidentally overwrite global variables of the host file
-- if they occupy identical name space in the global table
-- https://old.reddit.com/r/lua/comments/1az44mv/quick_question_about_dofile_and_namesake_functions/
-- some background https://www.lua.org/pil/14.3.html
-- https://stackoverflow.com/questions/9744693/how-can-i-pass-parameters-to-a-lua-file-when-loading-it-from-another-lua-file
-- http://web.archive.org/web/20240105055546/http://lua-users.org/wiki/SandBoxes
-- https://www.gammon.com.au/scripts/doc.php?lua=setfenv
-- https://www.lua.org/manual/5.4/manual.html#pdf-load
local func = assert( loadfile( path, 't', setmetatable({}, { __index = _G } ) ) )(...) -- load and create a function // the appended parentheses with vararg can be ommitted if no arguments need passing to the loaded file (THAT'S PROBABLY NOT TRUE AND THE PARENTHESIS MUST STAY WITH OR WITHOUT VARARG)
func() -- execute
--[[ OR, which isn't supported by ReaScript or the latest Lua version
local func = assert(loadfile(path)) -- load and create a function
local env = {} -- declare new table
setfenv(func,env) -- set loaded function environment to this custom table
func() -- execute
]]


-- 'require' syntax for loading module from the same path
-- as the host script
local is_new_value, scr_name, sect_ID, cmdID_init, mode, resol, val, contextstr = reaper.get_action_context()
package.path = scr_name:match('.+[\\/]') .. '?.lua'
local t = require('my module') -- OR require 'my module'



function load_functions_from_file(file_path)
-- allows placing all functions at the end of the script
-- and calling them at the beginning of the script
-- as a table
-- the functions must be initialized within a function
-- which is returned from the script and which itself
-- returns a table containing them, the syntax is:
--[[
-- MAIN CODE
return function()
	local func1()
	end
	local func2()
	end
	local func3()
	end
local t = {}
 -- CODE which results in table being {func1, func2, func3, ...}
return t
end
]]
-- if the loaded functions need to use local upvalues 
-- from the main code which are not passed as arguments
-- to individual functions these must be additonally included 
-- inside the returned function
-- otherwise only global variables from the main code
-- are accessible to the loaded functions;
-- alternatively, the upvalues should be passed as arguments
-- to the returned function, e.g.
--[[
return function(upvalue1, upvalue2, upvalue3)
local t = {}
	local func1(upvalue1)
	end
	local func2(upvalue2)
	end
	local func3(upvalue3)
	end
 -- CODE which results in table being {func1, func2, func3, ...}
return t
end
]]
-- and passed to pcall() function below as 2nd, 3d etc. arguments
-- in order for function call evaluation to succeed

local func = ''
	for line in io.lines(file_path) do
		if line then
			if line:match('return function') or #func > 0 then -- the main code must not feature another 'return function' line so that the function capture doesn't begin ahead of time and include irrelevant content, see another way to ensure this in the comment below
			func = func..(#func > 0 and '\n' or '')..line
			end
		--[[ OR
		-- the function may be marked by text signifying its start and end so the loop doesn't accidentally
		-- capture unrelated content
		-- the use of lines 'RETURN THIS FUNCTION START/END' typed out in reverse in this loop 
		-- ensures that the code capture doesn't start at this exact loop as would likely be the case
		-- had the lines been typed out normally
			if line:match(('TRATS NOITCNUF SIHT NRUTER'):reverse()) or #func > 0 then
			func = func..(#func > 0 and '\n' or '')..line -- collect target function content
			elseif line:match(('DNE NOITCNUF SIHT NRUTER'):reverse()) then break
			end
			]]
		end
	end

func = func:match('.+(return function.+end)') -- exclude any trailing and preceding content, only the last 'return function' is included in case it occurs elsewhere in the script, it should not feature in the nested functions

	if func then
	-- https://stackoverflow.com/questions/48629129/what-does-load-do-in-lua
	-- https://forum.luanti.org/viewtopic.php?t=27810
	local func, err = load(func)() -- closing double brackets are a must even though they're not mentioned in Lua documentation, they turn the namespace into an executable function // in Lua versions 5.1 and older loadstring may also work but wasn't tested
		if err then return err
		else
		-- https://www.gammon.com.au/scripts/doc.php?lua=pcall
		-- http://lua-users.org/lists/lua-l/2009-11/msg00269.html
		local ok, t = pcall(func) -- t is a table returned by the function func // if the called function has arguments, they all or their substitues must follow as pcall arguments, i.e. pcall(func, arg1, arg2, arg3), in order for evaluation to succeed (this will be the case if the returned function loaded with load() has arguments), if there're multiple return values, the are all returned after ok return value
			if ok then return t
			else
			r.MB('The function is frought with errors', 'ERROR', 0)
			end
		end
	end
end
-- USE:
-- local is_new_value, scr_name, sect_ID, cmdID_init, mode, resol, val, contextstr = r.get_action_context()
-- local t = get_function_from_file(scr_name)



function Parse_ReaBank_File(file_name)
-- file_name is a .reabank file name with or without the extension
-- the expected file location is /Data folder in the REAPER resource directory
	if file_name then
	local file_name = file_name:match('[%p%w].+[%p%w]') -- strip leading and trailing spaces
	file_name = file_name:lower():match('%.reabank') and file_name
	or file_name..'.reabank'
	local sep = r.GetResourcePath():match('[\\/]')
	local path = r.GetResourcePath()..sep..'Data'..sep..file_name
		if not r.file_exists(path) then
		Error_Tooltip('\n\n the .reabank file wasn\'t \n\n found in the /data folder \n\n', 1, 1) -- caps, spaced true
		return end
	local t, bank_MSB_init, bank_LSB_init = {}
		for line in io.lines(path) do
			if line:lower():match('^%s*bank') then -- this cond also ignores commented out lines
			-- if bank header is malformed in the file the bank won't be listed in ReaControlMIDI
			-- extra spaces are ignored
			-- the order of bank numbers in the .reabank file is immaterial for ReaControlMIDI
			local bank_MSB, bank_LSB, bank_name = line:match('[BbAaNnKk]+[%s\t]*(%d+)[%s\t]*(%d+)[%s\t]*(.*)')
				if bank_MSB and bank_LSB then -- collect bank numbers
					if bank_MSB ~= bank_MSB_init then -- new bank MSB number
					t[bank_MSB+0] = {[bank_LSB+0] = {name = #bank_name > 0 and bank_name or 'no bank name'}}
					else -- same bank MSB number, add new LSB table
					t[bank_MSB_init+0][bank_LSB+0] = {}
					t[bank_MSB_init+0][bank_LSB+0].name = #bank_name > 0 and bank_name or 'no bank name'
					end
				bank_MSB_init, bank_LSB_init = bank_MSB, bank_LSB -- store/update
				end
			-- order of the program numbers in the .reabank file doesn't affect their order
			-- in ReaControlMIDI, the numbering doesn't have to be sequential
			elseif bank_MSB_init and #line > 0 and not line:match('^[%s\t]*//') then -- OR match('^[%s\t]*%d+'), collect programs props, ignoring empty and commented out lines
			local prog_No, prog_name = line:match('^[%s\t]*(%d+)[%s\t]*(.*)')
				if prog_No then
				t[bank_MSB_init+0][bank_LSB_init+0][prog_No+0] = #prog_name > 0 and prog_name or 'no prog name'
				end
			end
		end
	return next(t) and t -- return if table is likely populated, only evaluates bank MSB field hence not failproof
	end
end




function GetUserFileNameForRead_Alt(cmd_ID)
-- cmd_ID is integer stemming from get_action_context()
local named_ID = r.ReverseNamedCommandLookup(cmd_ID) -- convert to named
local last_path = r.GetExtState(named_ID,'LAST_PATH')
local retval, file = r.GetUserFileNameForRead(last_path, 'OPEN SRT FILE', '')
r.SetExtState(named_ID,'LAST_PATH',file:match('.+[\\/]'), false) -- persist false
	if not retval then return r.defer(no_undo) end -- user cancelled the dialogue
local file = io.open(file, 'r')
local cont = file:read('*a')
file:close()
return cont
end


function sanitize_file_name1(name)
-- the name must exclude extension
-- https://stackoverflow.com/questions/1976007/what-characters-are-forbidden-in-windows-and-linux-directory-names
-- relies on Error_Tooltip() function

local orig_len = #name
local OS = r.GetAppVersion()
local lin, mac = OS:match('lin'), OS:match('OS')
local win = not lin and not mac
local t = win and {'<','>',':','"','/','\\','|','?','*'}
or lin and {'/','\0'} or mac and {'/',':'}

	for k, char in ipairs(t) do
	name = name:gsub(char, '')
	end
	
	if #name:gsub(' ','') == 0 then 
	Error_Tooltip('\n\n the file name does not \n\n include valid characters. \n\n', 1, 1) -- caps, spaced true
	return end
	
local win_illegal = 'CON,PRN,AUX,NUL,COM1,COM2,COM3,COM4,COM5,COM6,COM7,COM8,COM9,LPT1,LPT2,LPT3,LPT4,LPT5,LPT6,LPT7,LPT8,LPT9'
	if win then
		for ill_name in win_illegal:gmatch('[^,]+') do
			if name:match('^%s*'..ill_name..'%s*$') or name:match('^%s*'..ill_name:lower()..'%s*$')
			then name = '' break end -- illegal names padded with spaces aren't allowed either
		end
	end
	
	if #name > 0 then -- if after the sanitation there're characters left
	local shorter = #name < orig_len 
		if shorter then
		Error_Tooltip('\n\n\t the file name has been \n\n stripped of illegal characters. '
		..'\n\n\t      please review it \n\n', 1, 1, -100, -280) -- caps, spaced
		end
	return name, shorter
	end
	
end


function sanitize_file_name2(filename)
-- https://github.com/ReaTeam/ReaScripts/blob/04c8142b91a09ba84f0dcd766fdbacc744a3d7c8/Tracks/Tylereddington_Smart_Track_Manager_Package.lua
return filename:gsub('[\\/:*?\"<>|]', '_') -- colon may be supported on MacOS
end



function sanitize_file_path(f_path)
-- the limit is 256 characters
-- truncating the file name if needed
-- relies on Error_Tooltip() function

-- make the stock function count characters rather than bytes
-- the change applies to the entire environment scope
-- doesn't affect # operator
--[[
string.len = 	function(self)
					return #self:gsub('[\128-\191]','')
					end
]]
-- OR
function string.len(self)
return #self:gsub('[\128-\191]','') -- discard the continuation bytes, if any
end

-- make the stock function reverse non-ANSI strings as well
-- the change applies to the entire environment scope
function string.reverse(self)
local str_reversed = ''
	for char in self:gmatch('[\192-\255]*.[\128-\191]*') do
	str_reversed = char..str_reversed
	end
return str_reversed
end

local path, name, ext = f_path:match('(.+[\\/])(.+)(%.%w+)')

local OS = r.GetAppVersion()
local lin, mac = OS:match('lin'), OS:match('OS')
local win = not lin and not mac
local t = win and {'<','>',':','"','/','|','%?','%*'} -- escaping magic characters
or lin and {'\0'} or mac and {':', '/.'} -- OSX doesn't recognize file/folder names starting with a dot
-- https://care.acronis.com/s/article/Illegal-Characters-on-Various-Operating-Systems?language=en_US
-- https://superuser.com/questions/1499950/what-are-invalid-names-for-a-directory-under-linux

	for k, char in ipairs(t) do
		if path:match('^%s*%u:.-'..char) then -- this message is only possible if path was insered manually
		Error_Tooltip('\n\n the file path contains \n\n    illegal characters \n\n', 1, 1, -65, -275)
		return nil, f_path end -- f_path is parallel to mess return value below
	end

local diff = 256 - (path:len()+ext:len())
-- local mess = ''
local mess

	if diff <= 0 then
	local excess = diff < 0 and '\n\n   by '..math.abs(diff)..' characters.' or ''
	Error_Tooltip('\n\n the file path length \n\n   exceeds the limit '..excess..' \n\n', 1, 1) -- caps, spaced true
	mess = name
	elseif diff < name:len() then -- truncate file name
	name = name:sub(1, diff)
	--[[ OR in a more convoluted way
	local diff = diff-name:len() -- subtracting smaller from greater to obtain negative value
	name = name:sub(1, diff-1) -- additional -1 because the end argument includes the last character, i.e. 1 greater than the actual difference
	--]]
	-- after truncation the file name may happen to match an existing file
	-- if so reverse the name, not 100% failproof but the odds that the reversed file name will still clash are fairly low
	local reversed = ''
		if r.file_exists(path..name..ext) then
		name = name:reverse()
		reversed = '\n\n\tand reversed to prevent \n\n     clash with an existing file'
		end
	Error_Tooltip('\n\n the file name has been truncated \n\n    due to excessive path length. '..reversed..'\n\n', 1, 1) -- caps, spaced true
--	Error_Tooltip('\n\n the file name has been truncated \n\n    due to excessive path length. '..reversed..'\n\n\t\tplease review it. \n\n', 1, 1) -- caps, spaced true
	-- mess = 'The file name has been truncated '..reversed
	mess = name
	end

return path..name..ext, mess, (path..name..ext):len() < f_path:len(), name:len() -- mess return value is supposed to trigger reload of a dialogue/menu, 3d value to indicate whether the name was truncated, 4th value the length of the new name
-- return path..name..ext, mess

end



function Copy_Or_Move_File(cur_file_path, new_file_path, want_move)
-- cur_file_path includes file name
-- new_file_path excludes file name
local f = io.open(cur_file_path,'rb')
local cont = f:read('*a')
	if want_move then -- remove from old location
	os.remove(cur_file_path)
	end
local sep = new_file_path:match('[\\/]')
local path = new_file_path..(new_file_path:sub(-1) == sep and '' or sep)..cur_file_path:match('[^\\/]+') -- concatenate full path of the file at the new location
f = io.open(path,'wb')
f:write(cont)
f:close()
return r.file_exists(path) and path
end



function Get_Last_Accessed_Dir()
-- last directory accessed by REAPER in various contexts

-- the following are not supported:
-- lastdir= under sections [reasamplomatic], [reaper_explorer], [reaverb]
-- recent01= under [Recent] section, recently opened project files, format recent00
-- notenamedir=, notenamerecent_1= , at least 6 of notenamerecent_X under [midiedit] section
-- should be retrieved with Check_reaper_ini()

local t = {'vstpath64', 'lv2path_win64', 'clap_path_win64', 'altpeakspath', 'convertaddpath', 'lastrenderpath2', 'bounce_path', 'importpath', 'reascale_fn', 'lastbankdir', 'lastcwd', -- cwd = current working directory
'lastthemefn5', 'lastprojuiref', 'lastscript', 'lastmenusetdir', 'convertfolder', 'autosavedir', 'autosavedir_unsaved'}
	for idx, key in ipairs(t) do
	local retval, path = r.get_config_var_string(key)
	t[idx] = path
	end
return t
end


function get_cwd() -- current working directory
-- https://stackoverflow.com/a/73139370/8883033
return io.popen("cd"):read()
end



function Get_Desktop_Path()
local Win = r.GetOS():match('Win')
local path = os.getenv(Win and 'USERPROFILE' or 'HOME')
return path..path:match('[\\/]')..'Desktop'
end



--=================================== F I L E S   E N D =========================================


--============  M E A S U R E M E N T S / C A L C U L A T I O N S  =================

--[[
HOW FUNCTION GetSet_ArrangeView2() works

start_time, end_time = reaper.GetSet_ArrangeView2(proj, isSet, screen_x_start, screen_x_end, start_time, end_time)

https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and stop_time should be on the screen when non-zero when isSet is true

When setting Arrange with screen_x_start and screen_x_end being 0, the start will be set to start_time and end to end_time, the zoom level will adjust automatically.

When setting with screen_x_end val greater than 0, the screen_x_end val is divided by the diff between end_time and start_time values which sets zoom level, being equal to the value returned by GetHZoomLevel(). The resulting start and end times change

When setting screen_x_start value is ignored

]]


function Get_Vis_Arrange_Len_In_Pixels()
local start_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false, screen_x_start & screen_x_end both 0 = GET // https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and stop_time should be on the screen when non-zero when isSet is true
local len = (end_time-start_time)*r.GetHZoomLevel()-17 -- GetHZoomLevel() returns px/sec // 17 is the vertical scrollbar which is included in the Arrange length in sec but is outside of the visible time line
return math.floor(len+0.5) -- return rounded since fractional pixel values are invalid
-- OR
-- return len -- if rounding will be done outside of the function after additional calculations
end



function Get_Arrange_Dims()
-- requires SWS or js_ReaScriptAPI extensions
local sws, js = r.BR_Win32_FindWindowEx, r.JS_Window_Find
-- OR
-- local sws, js = r.APIExists('BR_Win32_FindWindowEx'), r.APIExists('JS_Window_Find')

	if sws or js then -- if SWS/js_ReaScriptAPI ext is installed
	-- thanks to Mespotine https://github.com/Ultraschall/ultraschall-lua-api-for-reaper/blob/master/ultraschall_api/misc/misc_docs/Reaper-Windows-ChildIDs.txt
	local main_wnd = r.GetMainHwnd()
	-- trackview wnd height includes bottom scroll bar, which is equal to track 100% max height + 17 px, also changes depending on the header height and presence of the bottom docker
	local arrange_wnd = sws and r.BR_Win32_FindWindowEx(r.BR_Win32_HwndToString(main_wnd), 0, '', 'trackview', false, true) -- search by window name // OR r.BR_Win32_FindWindowEx(r.BR_Win32_HwndToString(main_wnd), 0, 'REAPERTrackListWindow', '', true, false) -- search by window class name
	or js and r.JS_Window_Find('trackview', true) -- exact true // OR r.JS_Window_FindChildByID(r.GetMainHwnd(), 1000) -- 1000 is 'trackview' window ID
	local retval, lt1, top1, rt1, bot1 = table.unpack(sws and {r.BR_Win32_GetWindowRect(arrange_wnd)}
	or js and {r.JS_Window_GetRect(arrange_wnd)})
	local retval, lt2, top2, rt2, bot2 = table.unpack(sws and {r.BR_Win32_GetWindowRect(main_wnd)} or js and {r.JS_Window_GetRect(main_wnd)})
	local top2 = top2 == -4 and 0 or top2 -- top2 can be negative (-4) if window is maximized
	local arrange_h, header_h, wnd_h_offset = bot1-top1-17, top1-top2, top2 -- arrange_h tends to be 1 px smaller than the one obtained via calculations following 'View: Toggle track zoom to maximum height' when extensions aren't installed, using 16 px instead of 17 fixes the discrepancy; header_h is distance between arrange and program window top; wnd_h_offset is a coordinate of the program window top which is equal to its distance from the screen top (Y coordinate 0) when shrunk // !!!! MAY NOT WORK ON MAC since there Y axis starts at the bottom
	return arrange_h, header_h, wnd_h_offset
	end
end



function GetSet_Track_Zoom_100_Perc(targ_tr)
-- track 100 zoom is the same as current Arrange height
-- 100% zoom depends on the bottom docker being open
-- which limits Arrange height;
-- targ_tr is optional, only used if there's a track
-- which must be set to 100% hight after the height value in pixels has been retrieved
-- it's also the one which will be scrolled to;
-- pinned tracks are taken into account as they're
-- not included in the Arrange height

--[[INEFFICIENT
-- get 'Maximum vertical zoom' set at Preferences -> Editing behavior, which affects max track height set with 'View: Toggle track zoom to maximum height', introduced in build 6.76
local cont
	if tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.76 then
	local f = io.open(r.get_ini_file(),'r')
	cont = f:read('*a')
	f:close()
	end

local max_zoom = cont and cont:match('maxvzoom=([%.%d]+)\n') -- min value is 0.125 (13%) which is roughly 1/8th, max is 8 (800%)
local max_zoom = not max_zoom and 100 or math.floor(max_zoom*100+0.5) -- ignore in builds prior to 6.76 by assigning 100 so that when track height is divided by 100 and multiplied by 100% nothing changes, otherwise convert to conventional percentage value; if 100 can be divided by the percentage (max_zoom) value without remainder (such as 50, 25, 20) the resulting value is accurate, otherwise there's ±1 px diviation, because the actual track height in pixels isn't fractional like the one obtained through calculation therefore some part is lost
]]

local act = r.Main_OnCommand
local GetTrackVal = r.GetMediaTrackInfo_Value

local scroll_to_tr = r.GetTrack(0,0) -- track (any) to scroll back to in order to restore scroll state after track heights restoration
local scroll_to_tr_y = GetTrackVal(scroll_to_tr, 'I_TCPY')

-- Store track heights and get reference track
-- to scroll back to in order to restore scroll state after track heights restoration
-- since ref_tr is also used to get Arrange height, look for one with fixed lanes disabled (in v7)
-- because in these 100% height is allocated to just one lane
-- rather than to the entire TCP, so if there're more than one,
-- the I_TCPH value will be equal 100 * lane count
local v7 = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 7
local t, ref_tr = {} -- ref_tr is used to get Arrange height
	for i=0, r.CountTracks(0)-1 do
	local tr = r.GetTrack(0,i)
	local TCP_H = GetTrackVal(tr, 'I_TCPH')
	t[#t+1] = TCP_H
		-- in version 7 look for track with multi-lanes disabled or collapsed
		if v7 and ( GetTrackVal(tr,'I_NUMFIXEDLANES') == 1
		or GetTrackVal(tr,'C_LANESCOLLAPSED') == 1 )
		or not v7 then
		ref_tr = ref_tr or tr -- once found keep the value
		end
	end

local temp_tr
	if not ref_tr then -- possible in version 7 if all tracks have fixed lanes enabled, may be false if optional targ_t doesn't have fixed lanes enabled
	-- insert new track
	r.InsertTrackAtIndex(r.GetNumTracks(), false) -- wantDefault false
	ref_tr = r.GetTrack(0,r.GetNumTracks()-1)
	temp_tr = ref_tr
	end

-- Get the data
-- When the actions are applied the UI jolts, but PreventUIRefresh() is not suitable because it blocks the function GetMediaTrackInfo_Value() from getting the return value
-- toggle to minimum and to maximum height are mutually exclusive // selection isn't needed, all are toggled;
-- in v7 action 'View: Toggle track zoom to maximum height (limit to 100% of arrange view)' was introduced
-- which works like 40113 worked before the change and its use would obviate all the calculations below 
-- but it obviously doesn't cover the interim builds, so leaving the current code;
-- since build 7.48 the following toggle zoom actions affect pinned tracks as well,
-- introduced in build 7.46, but since their height is being taken into account
-- the calculation must still be accurate
act(40110, 0) -- View: Toggle track zoom to minimum height
act(40113, 0) -- View: Toggle track zoom to maximum height [in later builds comment '(limit to 100% of arrange view) has been added' and another action introduced to zoom to maxvzoom value]
------------------------------------
-- The following is only relevant for a few builds starting from 6.76
-- in which action 40113 was zooming in to maxvzoom value rather than 100%
local retval, max_zoom = r.get_config_var_string('maxvzoom')-- min value is 0.125 (13%) which is roughly 1/8th, max is 8 (800%)
max_zoom = retval and max_zoom*100 or 100 -- ignore in builds prior to 6.76 by assigning 100 so that when track height is divided by 100 and multiplied by 100% nothing changes, otherwise convert to conventional percentage value
local tr_h = GetTrackVal(ref_tr, 'I_TCPH')/max_zoom*100 -- not including envelopes, action 40113 doesn't take envs into account; calculating track height as if it were zoomed out to the entire Arrange height by taking into account 'Maximum vertical zoom' setting at Preferences -> Editing behavior

-- if there're visible pinned tracks at the top (introduced in build 7.46), calculate their height because
-- their presence affects max track height obtained above
local pin_tracks_h = 0
	if r.GetToggleCommandState(43573) == 0 then -- Track: Override/unpin all pinned tracks in TCP 
		for i=0, r.GetNumTracks()-1 do
		local tr = r.GetTrack(0,i)
			if r.IsTrackVisible(tr, false) -- mixer false
			and GetTrackVal(tr, 'B_TCPPIN') == 1 				
			then
			pin_tracks_h = pin_tracks_h + GetTrackVal(tr, 'I_WNDH') -- incl. envelopes
			end
		end
	end

pin_tracks_h = pin_tracks_h > 0 and pin_tracks_h+10 or pin_tracks_h -- 10 px is pinned track area separator width	
local tr_h = math.floor(tr_h + pin_tracks_h + 0.5) -- round; if 100 can be divided by the percentage (max_zoom) value without remainder (such as 50, 25, 20) the resulting value is integer, otherwise the calculated Arrange height is fractional because the actual track height in pixels is integer which is not what it looks like after calculation based on percentage (max_zoom) value, which means the value is rounded in REAPER internally because pixels cannot be fractional and the result is ±1 px diviation compared to the Arrange height calculated at percentages by which 100 can be divided without remainder
local del = temp_tr and r.DeleteTrack(temp_tr) -- delete temp track if one was inserted
------------------------------------

-- Restore track heights
	for k, height in ipairs(t) do
	local tr = r.GetTrack(0,k-1)
	r.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', height)
	end

	if targ_tr then -- set to 100% height
	r.SetMediaTrackInfo_Value(targ_tr, 'I_HEIGHTOVERRIDE', tr_h)
	r.SetOnlyTrackSelected(targ_tr)
	act(40913,0) -- Track: Vertical scroll selected tracks into view
	scroll_to_tr = targ_tr -- set scroll_to_tr to target track so that it's the one to scroll to
	scroll_to_tr_y = 0 -- to scroll the targ_tr to the top, where Y is 0
	end

r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275

-- Restore scroll position or scroll the zoomed-in targ_tr to top
r.PreventUIRefresh(1)
r.CSurf_OnScroll(0, -1000) -- scroll all the way up as a preliminary measure to simplify scroll pos restoration because in this case you only have to scroll in one direction so no need for extra conditions
local Y_init = 0
	repeat -- restore track scroll
	r.CSurf_OnScroll(0, 1) -- 1 vert scroll unit is 8 px
	local Y = GetTrackVal(scroll_to_tr, 'I_TCPY')
		if Y ~= Y_init then Y_init = Y else break end -- when the track list is scrolled all the way down and the script scrolls up the loop tends to become endless because for some reason the 1st track whose Y coord is used as a reference can't reach its original pos, this happens regardless of the preliminary scroll direction above, therefore exit loop if it's got stuck, i.e. Y value hasn't changed in the next cycle; this doesn't affect the actual scrolling result, tracks end up where they should // unlike track size value, track Y coordinate accessibility for monitoring isn't affected by PreventUIRefresh()
	until Y <= scroll_to_tr_y
r.PreventUIRefresh(-1)

return tr_h

end



function Get_Proj_Len_In_Px()
local proj_len = r.GetProjectLength(0)
return math.floor(proj_len*r.GetHZoomLevel()+0.5)
end


function Beat_To_Pixels()
return math.floor(60/r.Master_GetTempo()*r.GetHZoomLevel()+0.5) -- GetHZoomLevel() returns px/sec; return rounded since fractional pixel values are invalid
end


function Grid_Div_Dur_In_Sec() -- in sec
-- grid division (div) is the one set in the Snap/Grid settings
local retval, div, swingmode, swingamt = r.GetSetProjectGrid(0, false, 0, 0, 0) -- proj is 0, set is false, division, swingmode & swingamt are 0 (disabled for the purpose of fetching the data)
--local convers_t = {[0.015625] = 0.0625, [0.03125] = 0.125, [0.0625] = 0.25, [0.125] = 0.5, [0.25] = 1, [0.5] = 2, [1] = 4} -- number of quarter notes in grid division; conversion from div value
--return grid_div_time = 60/r.Master_GetTempo()*convers_t[div] -- duration of 1 grid division in sec
-- OR
--local grid_div_time = 60/r.Master_GetTempo()*div/0.25 -- duration of 1 grid division in sec; 0.25 corresponds to a quarter note as per GetSetProjectGrid()
--return grid_div_time
-- OR
return r.GetToggleCommandStateEx(0, 41885) == 0 -- Grid: Toggle framerate grid
and 60/r.Master_GetTempo()*div/0.25 -- duration of 1 grid division in sec; 0.25 corresponds to a quarter note as per GetSetProjectGrid()
or 1/r.TimeMap_curFrameRate(0) -- frame duration doesn't depend on the tempo, 1 because the rate is per second
end



function Get_Visible_Grid_Div_Length(grid_div_len)
-- grid_div_len is value in sec, 
-- stems from Grid_Div_Dur_In_Sec()
-- returns length of visible grid division in sec

-- THE FUNCTION IS INCOMPATIBLE WITH MIDI EDITOR VISIBLE GRID 
-- PRODUCING INACCURATE RESULT BECASUE MIDI EDITOR GRID WHEN FOLDED 
-- DOESN'T RESPECT MIMIMUM LINE SPACING VALUE SET IN THE GRID SETTINGS 
-- (never respected before build 7.37 and only partially respects since) 
-- AND INSTEAD CREATES GREATER LINE SPACING WHICH IS IMPOSSIBLE TO CALCULATE 
-- WITH THE FUNCTION BECAUSE THE FUNCTION LOOKS FOR TIME VALUE IN SEC 
-- CORRESPONDING TO MIMIMUM LINE SPACING VALUE IN PIXELS AND CANNOT GUESS 
-- BY HOW MUCH ACTUAL LINE SPACING OF THE VISIBLE MIDI EDITOR GRID IS GREATER 
-- THAN THE MINIMUM VALUE
-- THAT SAID IT IS ABLE TO GIVE AN INDICATION WHEN THE MIDI EDITOR VISIBLE GRID
-- DOESN'T MATCH THE GRID SETTING IN BUILDS 7.37+

local retval, min_spacing = r.get_config_var_string('projgridmin') -- minimum visible grid resolution // setting in Snap/Grid Settings dialogue 'Show grid, line spacing: ... minimum: ... pixels'
	if min_spacing+0 > 0 then
	local zoom = r.GetHZoomLevel() -- pix/sec
	local pix_per_grid_div = zoom*grid_div_len
		if pix_per_grid_div < min_spacing+0 then
			-- increment until equal or greater than the minimum
			while pix_per_grid_div < min_spacing+0 do
			grid_div_len = grid_div_len+grid_div_len
			pix_per_grid_div = zoom*grid_div_len
			end
		return grid_div_len
		end	
	end
return grid_div_len
end



function Get_Time_Of_Closest_Grid_Div(time)
return r.SnapToGrid(0, time)
end



function Music_Div_To_Sec(val)
-- returns length of 1 bar in sec
-- val is either integer (whole bars/notes) or quotient of a fraction x/x, i.e. 1/2, 1/3, 1/4, 2/6 etc
	if not val or val == 0 then return end
return 60/r.Master_GetTempo()*4*val -- multiply crotchet's length by 4 to get full bar length and then multiply the result by the note division
end


function Music_Div_To_Pixels(val)
-- returns length of 1 bar in whole pixels
-- val is either integer (whole bars/notes) or quotient of a fraction x/x, i.e. 1/2, 1/3, 1/4, 2/6 etc
	if not val or val == 0 then return end
return math.floor(60/r.Master_GetTempo()*4*val*r.GetHZoomLevel()+0.5) -- multiply crotchet's length by 4 to get full bar length and then multiply the result by the note division
end


function Scale_Time_By_Horiz_Zoom_Level(val, base_zoom)
-- mainly for scaling distance of mouse cursor from object
-- val is distance in sec/ms, base_zoom is pixels per sec at which the value isn't scaled
-- e.g. if base_zoom is 100 the value isn't scaled at 100 px/sec (or rather in the neighbourhood since zoom value is never this exact) because 100/100 is 1, if the zoom decreases (goes below the base_zoom, zoom out) the value will be increased, if increases (goes above the base_zoom, zoom in) it will be decreased, because the greater the zoom the more precisely can the target value be hit thanks to greater resolution and smaller distance from the target is permissible
-- the base_zoom value could be precise if extracted directly from GetHZoomLevel() at a specific zoom level beforehand
return val/(r.GetHZoomLevel()/base_zoom)
end


function frames2ms(frames_num) -- depends on round() function
local fps, isdropFrame = r.TimeMap_curFrameRate(0)
local ms_per_frame = 1000/fps
--return round(f*ms_per_frame)
--return math.floor(frames_num*ms_per_frame+0.5)
return frames_num*ms_per_frame
end


function frames2sec(frames_num)
local frame_rate, isdropFrame = r.TimeMap_curFrameRate(0)
return frames_num/frame_rate
--[[ OR
local sec_per_frame = 1/frame_rate
return frames_num*sec_per_frame
]]
end


function time_pos_to_pixels(posInSec) -- posInSec is an absolute value in project; without SWS extension only accurate when the program window is fully open

--[[ NOT NEEDED WHEN TCP_width var is not in use
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
--]]

--local rt, top, lt, bot = r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true) -- true - work area, false - the entire screen
local sws = r.APIExists('BR_Win32_GetWindowRect')
local dimens_t = sws and {r.BR_Win32_GetWindowRect(r.GetMainHwnd())}
or {r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true)} -- true - work area, false - the entire screen // https://forum.cockos.com/showthread.php?t=195629#4
	if #dimens_t == 5 then table.remove(dimens_t, 1) end -- remove retval value if BR's function
local lt, top, rt, bot = table.unpack(dimens_t)
local start_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false, screen_x_start & screen_x_end both 0 = GET // https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and stop_time should be on the screen when non-zero when isSet is true
--local TCP_width = tonumber(cont:match('leftpanewid=(.-)\n')) -- only changes in reaper.ini when dragged
local Top_area_h = sws and top + 65 or tonumber(cont:match('toppane=(.-)\n')) or 65 -- 'toppane' only changes in reaper.ini when dragged so not reliable // Y coordinate, OPTIONAL, can be changed on a case by case basis
-- https://forums.cockos.com/showpost.php?p=1991096&postcount=11 thanks to mespotine
--local arrange_w_px = rt - TCP_width -- accurate
--local sec_in_arrange = arrange_w/r.GetHZoomLevel() -- accurate
local arrange_w_px = (end_time - start_time)*r.GetHZoomLevel() -- get width of Arrange in pixels; GetHZoomLevel() returns pixels per second
local TCP_w_dockheight_l = rt - arrange_w_px -- seems more accurate than TCP_width (leftpanewid) by about 10 px upward when left docker is closed; otherwise accounts for open docker as well; plus TCP_width value is not reliable as it only changes when TCP edge is dragged
local pos_in_arrange_sec = posInSec - start_time -- WASN'T TESTED WITH PROJECT START OFFSET
local pos_in_arrange_px = pos_in_arrange_sec*r.GetHZoomLevel() + TCP_w_dockheight_l -- + TCP_width // X coordinate
return math.ceil(pos_in_arrange_px) - pos_in_arrange_px <= pos_in_arrange_px - math.floor(pos_in_arrange_px) and math.ceil(pos_in_arrange_px) or math.floor(pos_in_arrange_px), -- round up or down
Top_area_h -- OPTIONAL, can be changed on a case by case basis, see above

end


function pixel_to_sec(val) -- converts interval in pixels to interval in seconds, val can be either integer or decimal number
return val/r.GetHZoomLevel()
end


function Horiz_Scroll_Distance(SEC, VALUE) -- SEC is boolean to use seconds as scroll unit when VALUE is in seconds; otherwise musical division
-- relies on Music_Div_To_Sec() function
local px_per_sec = r.GetHZoomLevel()
return SEC and VALUE and px_per_sec*VALUE or -- seconds
VALUE and px_per_sec*Music_Div_To_Sec(VALUE) or -- musical interval
px_per_sec*Music_Div_To_Sec(1/4) -- empty, 0 or non-numeric input so it defaults to 1 beat
end


function Get_Screen_Dims()
local f = io.open(reaper.get_ini_file(), 'r') -- load reaper.ini for parsing
local f_cont = f:read('*a') -- read the entire content
f:close()
--local wnd_w = f_cont:match('(wnd_w=%d*)');
--local wnd_w = tonumber(wnd_w:match('=(%d*)'))
-- OR local wnd_w = tonumber(f_cont:match('wnd_w=(%d*)'))
--local wnd_h = f_cont:match('(wnd_h=%d*)');
--local wnd_h = tonumber(wnd_h:match('=(%d*)'))
-- OR wnd_h = tonumber(f_cont:match('wnd_h=(%d*)'))
-- https://forums.cockos.com/showthread.php?t=203785
return tonumber(f_cont:match('wnd_w=(%d*)')), tonumber(f_cont:match('wnd_h=(%d*)')) -- width and height
end
-- OR
local dimens_t = {r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true)} -- wantWorkArea true // 1 - L, 2 - T, 3 - R, 4 - B // https://forum.cockos.com/showthread.php?t=195629#4



-- val and dB conversion forumula from SPK77
-- http://forum.cockos.com/showpost.php?p=1608719&postcount=6
-- OR https://forum.cockos.com/showthread.php?p=1608719
-- spotted in 'Thonex_Adjust selected items vol by greatest peak overage'
-- https://forums.cockos.com/showthread.php?t=210811
-- https://forum.cockos.com/showthread.php?t=170003
local Track_Vol_dB = 20*math.log(val, 10) -- same as 20*math.log10(val) but math.log10 isn't supported in REAPER
local Track_Vol_val = 10^(dB_val/20)


function Calc_New_Vol_Value(old_val, add_val) -- add_val is positive or negative in dB
local old_val_dB = 20*math.log(old_val, 10)
local new_val_dB = old_val_dB + add_val
return 10^(new_val_dB/20)
end

-- Converting volume envelope values
-- https://forum.cockos.com/showthread.php?t=253381 jkooks
-- https://github.com/majek/wdl/blob/master/WDL/db2val.h
-- returns a dB value as the envelope/item volume value equivalent
-- LESS PRECISE THAN Calc_New_Vol_Value(), see https://github.com/reaper-oss/sws/pull/1980
-- REVERSE CONVERSION DOESN'T PRODUCE EXACTLY THE ORIGINAL VALUE
function DbToVal(db)
	local LN10_OVER_TWENTY = 0.11512925464970228420089957273422
	return math.exp(db*LN10_OVER_TWENTY)
end
--returns an envelope/item volume value as the dB equivalent
function ValToDb(val)
	if val < 0.0000000298023223876953125 then
		return -150
	else
		return math.max(-150, math.log(val)*8.6858896380650365530225783783321)
	end
end

-- https://github.com/ReaTeam/ReaScripts-Templates/blob/master/Values/X-Raym_Val%20to%20dB%20-%20dB%20to%20Val.lua
function dBFromVal(val)
return 20*math.log(val, 10)
end

function ValFromdB(dB_val)
return 10^(dB_val/20)
end

-- spotted in MPL's script // https://forum.cockos.com/showthread.php?t=217951
-- https://forum.cockos.com/showthread.php?t=263792#6
-- LESS PRECISE THAN THE ABOVE METHOD, see https://github.com/reaper-oss/sws/pull/1980
-- REVERSE CONVERSION DOESN'T PRODUCE EXACTLY THE ORIGINAL VALUE
function WDL_DB2VAL(x) return math.exp((x)*0.11512925464970228420089957273422) end  -- https://github.com/majek/wdl/blob/master/WDL/db2val.h

function WDL_VAL2DB(x, reduce) -- https://github.com/majek/wdl/blob/master/WDL/db2val.h
	if not x or x < 0.0000000298023223876953125 then return -150.0 end
local v = math.log(x)*8.6858896380650365530225783783321
	if v < -150.0 then return -150.0
	else
		if reduce then return string.format('%.2f', v)
		else return v
		end
	end
end



function Adjust_Velocity_By_dB(vel, dB)
-- only relevant for plugins using normalized scale (0..1) for gain interpolation
-- first or all ReaPlugs (RS5k, ReaSynth)
-- https://dobrian.github.io/cmp/topics/linear-mapping-and-interpolation/1.IntroductionToLinearInterpolation&LinearMapping.html
-- Thanks to Justin
-- https://www.askjf.com/index.php?q=6883s
-- ReaPlugs velocity to amplitude
-- Linear interpolation of gain (so if mapping 0..127 to -inf .. +0dB, 63 would be around -6dB (0.5), 32 would be around -12dB (0.25) etc.
-- https://www.askjf.com/index.php?q=6925s
-- the code snippet converts velocity units to dB units
--[[ -- sc stands for scale
max_sc = 1; // +0 dB, aka 10^(0/20)
min_sc = 0; // -inf dB
max_v = 127;
min_v = 1;
sc = min_sc + (noteval - min_v) / (max_v - min_v) * (max_sc - min_sc);
gain_db = log10(sc)*20; // convert scale to dB
]]
-- vel is current velocity
-- dB is negative or positive value to increase/reduce the current value by
-- thus the entire velocity range only covers dynamic range of 42 dB from -42 to 0 dB (7 velocity ranges 6 dB each)
-- the accuracy confirmed with ReaSynth and RS5k against 'Loudness Meter' JSFX output

local vel_to_dB = math.log(vel/127,10)*20 -- vel/127 calculates the scale or the percentage of the full scale taken up by the current value or their ratio, which is the same as (vel - min val) / (max val - min val), formula for calculation of linear interpolation, (vel - 0) / (127 - 0)
local new_dB_val = vel_to_dB + dB
local dB_to_vel = 10^(new_dB_val/20)*127
local target_vel = math.floor(dB_to_vel+0.5) -- round since velocity cannot be fractional
-- return accounting for NaN (not a number) and infinity, resulting from division by 0
-- which can be represented as -1.#IND and +/-1.#INF and is not equal to itself,
-- so as long as a value is equal to itself it's valid
-- https://stackoverflow.com/questions/19107302/in-lua-what-is-inf-and-ind
-- https://stackoverflow.com/questions/37753694/lua-check-if-a-number-value-is-nan
return target_vel == target_vel and target_vel or 0
end


function Measure_Note_In_Ms(take, start, fin, val1, val2)
local st_sec = r.MIDI_GetProjTimeFromPPQPos(take, start)
local end_sec = r.MIDI_GetProjTimeFromPPQPos(take, fin)
local len_sec =  math.floor((end_sec-st_sec)*1000+0.5)/1000 -- simple subtraction for some reason results in a value with 19 decimal places which is smaller than the expected value by a minute amount unless rounded up and throws the equality evaluation off even though the parts of the subtraction don't seem to be affected by this tiny deviation, so rounding down to 3 (1000) decimal places which is as many as needed for milliseconds; relevant for notes which aren't snapped to grid
return len_sec >= val1 and len_sec <= val2
end



function Offset_Shift_Value_To_Land_On_Natural_Keys1(curr_val, shift_by_val, normalized)
-- returns actual MIDI note number, not the one used by RS5k 'Note range start/end' parameters
-- shift_by_val is treated as white (natural) keys count
-- normalized is boolean to condition processing curr_val as RS5k internal pitch values in the range of 0-1
-- identifyng normalized values by their format alone isn't a completelly reliable method
-- because values 0 and 1 are part of the range as they're part of 0-127 range
-- even though the likelihood of reaching the range limits in the settings isn't very high
-- the Offset in the name doesn't apply to this version of the function

local unit = 1/127 -- normalized value used by Note range start/end parameters in the range of 0-1
local curr_val = normalized and math.floor(curr_val/unit + 0.5) or curr_val -- convert to conventional 0-based note number to be able to use modulo below
local sign = shift_by_val < 0 and -1 or shift_by_val > 0 and 1 or 0
local natural_keys_cnt = 0
	for i = 1, 127 do -- shift original note number counting how many natural (white) keys have been passed along the way
	dest_val = curr_val+i*sign
		if dest_val == 0 or dest_val%12 == 0 or dest_val == 2 or dest_val%12 == 2 -- C or D
		or dest_val == 4 or dest_val%12 == 4 or dest_val == 5 or dest_val%12 == 5 -- E or F
		or dest_val == 7 or dest_val%12 == 7 or dest_val == 9 or dest_val%12 == 9 -- G or A
		or dest_val == 11 or dest_val%12 == 11 then -- B
		natural_keys_cnt = natural_keys_cnt+1*sign
		end
		if natural_keys_cnt == shift_by_val then return dest_val end -- return as soon as the number of counted white keys equals shift_by_val
	end
end


function Offset_Shift_Value_To_Land_On_Natural_Keys2(curr_val, shift_by_val, prev_note, normalized)
-- returns actual MIDI note number, not the one used by RS5k 'Note range start/end' parameters
-- shift_by_val is treated as chromatic notes count
-- normalized is boolean to condition processing curr_val as RS5k internal pitch values in the range of 0-1
-- identifyng normalized values by their format alone isn't a completelly reliable method
-- because values 0 and 1 are part of the range as they're part of 0-127 range
-- even though the likelihood of reaching the range limits in the settings isn't very high

local unit = 1/127 -- normalized value used by Note range start/end parameters in the range of 0-1
local dest_val = (normalized and math.floor(curr_val/unit + 0.5) or curr_val) + shift_by_val -- convert to conventional 0-based note number to be able to use modulo below
--Msg(dest_val)
-- offset in case the note ends up being an accidental rather than a natural (white) key
local offset_val = shift_by_val < 0 and -1 or shift_by_val > 0 and 1 or 0
local dest_val = (dest_val == 1 or dest_val%12 == 1 or dest_val == 3 or dest_val%12 == 3
or dest_val == 6 or dest_val%12 == 6 or dest_val == 8 or dest_val%12 == 8
or dest_val == 10 or dest_val%12 == 10) -- accidentals (black keys) relative to C key
and dest_val+offset_val or dest_val
-- offset in case note clashes with the previous one which may happen due to adjustment of notes which end up as accidentals after initial shifting above
local offset_val = shift_by_val < 0 and -2 or shift_by_val > 0 and 2 or 0
local dest_val = prev_note and dest_val == prev_note and dest_val+offset_val or dest_val
return dest_val

end


function get_time_sel_or_loop_len(want_loop)
local want_loop = want_loop or false
local st, fin = r.GetSet_LoopTimeRange(false, want_loop, 0, 0, false) -- isSet, allowautoseek false
return fin-st
end



--========== M E A S U R E M E N T S / C A L C U L A T I O N S   E N D ===============


--====================================== U T I L I T Y =========================================


local r = reaper


for key in pairs(reaper) do _G[key] = reaper[key] end  -- MPL: get rid of 'reaper.' table key in functions

-- ReaScript TASK CONTROL
-- prevent ReaScript task control dialogue when the running script is clicked again so it's re-launched automatically,
-- supported since build 7.03
-- script flag for auto-relaunching after termination in reaper-kb.ini is 516, e.g. SCR 516, but if changed
-- directly while REAPER is running the change doesn't take effect, so in builds older than 7.03 user input is required
-- to enable setting in the ReaScript task control dialogue
if r.set_action_options then r.set_action_options(1|2) end
-- prevent ReaScript task control dialogue when the running script is clicked again to be terminated,
-- supported since build 7.03
-- script flag for auto-relaunching after termination in reaper-kb.ini is 4, e.g. SCR 4, but if changed
-- directly while REAPER is running the change doesn't take effect, so in builds older than 7.03 user input is required
if r.set_action_options then r.set_action_options(1) end	


function Msg(param) -- X-Raym's
reaper.ShowConsoleMsg(tostring(param).."\n")
end

-- this is probably the origin of the debug version
-- https://forum.cockos.com/showthread.php?p=1799680
local Debug = ""
-- OR
-- local Debug = not select(2, r.get_action_context()):match('.+[\\/]BuyOne_') and "" -- in public scripts audomatically disabled
function Msg(param, cap) -- caption second or none
local cap = cap and type(cap) == 'string' and #cap > 0 and cap..' = ' or ''
	if #Debug:gsub(' ','') > 0 then -- declared outside of the function, allows to only didplay output when true without the need to comment the function out when not needed, borrowed from spk77
	reaper.ShowConsoleMsg(cap..tostring(param)..'\n')
	end
end


local Debug = ""
function Msg(cap, param) -- caption always, if not needed can be empty string
local cap = cap and type(cap) == 'string' and #cap > 0 and cap..' = ' or ''
	if #Debug:gsub(' ','') > 0 then -- declared outside of the function, allows to only didplay output when true without the need to comment the function out when not needed, borrowed from spk77
	reaper.ShowConsoleMsg(cap..tostring(param)..'\n')
	end
end


local Debug = ""
function Msg(...) -- caption first (must be string otherwise ignored) or none, accepts functions with only one return value	
	if #Debug:gsub(' ','') > 0 then -- declared outside of the function, allows to only display output when true without the need to comment the function out when not needed, borrowed from spk77
	local t = {...}
		if #t > 1 then
		local cap, param = table.unpack(t) -- assign arguments to vars
		local cap = cap and type(cap) == 'string' and #cap > 0 and cap..' = ' or ''
		displ = cap..tostring(param)..'\n'
		elseif #t == 1 then
		displ = tostring(...)..'\n'
		r.ShowConsoleMsg(displ)
		end	
	end
end



local Debug = ""
function Msg(...) 
-- accepts either a single arg, or multiple pairs of value and caption
-- caption must follow value because if value is nil
-- and the vararg ends with it, it will be ignored
-- because nil isn't a valid table value, and won't be displayed
-- so vararg must not be allowed to end with nil when multiple
-- arguments are passed, i.e. always end with a caption
	if #Debug:gsub(' ','') > 0 then -- declared outside of the function, allows to only display output when true without the need to comment the function out when not needed, borrowed from spk77
	local t = {...} -- constucting table this way, i.e. by packing, allows getting table length even if it contains nils
--	local str = #t == 1 and tostring(t[1])..'\n' or not t[1] and 'nil\n' or ''
	local str = #t < 2 and tostring(t[1])..'\n' or '' -- covers cases when table only contains a single nil entry in which case its length is 0 or a single valid entry in which case its length is 1
		if #t > 1 then -- OR if #str == 0
			for i=1,#t,2 do
				if i > #t then break end
			local val, cap = t[i], t[i+1]
			str = str..tostring(cap)..' = '..tostring(val)..'\n'
			end
		end
	reaper.ShowConsoleMsg(str)
	end
end



function Msg2(f, ...)
-- same as Msg(...) above but with argument f which is integer
-- to modify floating point numbers precision;
-- accepts either a single arg, or multiple pairs of value and caption
-- caption must follow value because if value is nil
-- and the vararg ends with it, it will be ignored
-- because nil isn't a valid table value, and won't be displayed
-- so vararg must not be allowed to end with nil when multiple
-- arguments are passed, i.e. always end with a caption

-- https://stackoverflow.com/questions/1133639/how-can-i-print-a-huge-number-in-lua-without-using-scientific-notation
local function form(f, s)
return string.format(tonumber(s) and f and '%.'..f..'f' or '%s', s)
end

	if #Debug:gsub(' ','') > 0 then -- declared outside of the function, allows to only didplay output when true without the need to comment the function out when not needed, borrowed from spk77
	local t = {...} -- constucting table this way, i.e. by packing, allows getting table length even if it contains nils
--	local str = #t == 1 and form(f, t[1])..'\n' or not t[1] and 'nil\n' or ''
	local str = #t < 2 and tostring(t[1])..'\n' -- covers cases when table only contains a single nil entry in which case its length is 0 or a single valid entry in which case its length is 1
		if #t > 1 then -- OR if #str == 0
			for i=1,#t,2 do
				if i > #t then break end
			local val, cap = t[i], t[i+1]		
			str = str..form(f, cap)..' = '..form(f, val)..'\n'
			end
		end
	reaper.ShowConsoleMsg(str)
	end
end



local function printf(...) -- cfillion's from cfillion_Step sequencing (replace mode).lua
	if debug then
	reaper.ShowConsoleMsg(string.format(...))
	end
end
-- e.g. printf(">\tnote %d\tchan=%s vel=%s\n", note.pitch, note.chan, note.vel)


-- Debugging function
-- https://forums.cockos.com/showthread.php?t=189118
-- You put first on top of your script the function os.remove("C:\\ReascriptLog.txt")
-- and then the Msg() function. Whenever you want to find out in your script what some
-- variable is doing you simply write: Msg(' ') and put your variable inside ' '.
-- It will create a log txt file with the name and path you have specified.
-- If you change the path do not forget to change it in the os.remove function too.
-- If you add in the end of your script the function
-- os.execute('start "" '..'"C:\\ReascriptLog.txt"'),
-- the log file will open automatically
os.remove("C:\\ReascriptLog.txt")
function DebugMsg(name)
-- usage: Msg('  ') // put inside the '' what you want to get
local value = _G[name]
	for i=1,math.huge do
	 local localname, localvalue = debug.getlocal(2,i,1)
		if not localname then
		break -- no more locals to check
		elseif localname == name then
		value = localvalue
		end
	end
	if value then
	message = (string.format("%s = %s", name, tostring(value)).."\n")
	else
	message = (string.format("No variable named '%s' found.", name).."\n")
	end
file = io.open("C:\\ReascriptLog.txt", "a")
file:write(message)
file:close()
end
os.execute('start "" '..'"C:\\ReascriptLog.txt"')


-- https://github.com/ReaTeam/ReaScripts/blob/master/Items%20Editing/amagalma_Smart%20Crossfade.lua
local Debug = false
	if Debug then reaper.ClearConsole() end
local function Msg(...)
  if Debug then 
    local args = {...}
    for i = 1, #args do
      args[i] = tostring(args[i])
    end
    reaper.ShowConsoleMsg(table.concat(args,"\t").."\n")
  end
end



local date = os.date('%H-%M-%S_%d.%m.%y') -- a convenient way to make file names unique and prevent clashes


function execute_function_from_table(func) 
-- a way to execute a function stored in a table 
-- with global arguments already passed, where func is t[n],
-- i.e. t = {my_function(arg1, arg2, arg3)}
-- local arguments will produce error
return action
end


function Is_Project_Start() -- for use with time selection / loop / edit cursor / item pos values to prevent them getting aligned with the project start and ruining their position relative to the grid when moving leftwards (the concept is used in scripts 'Move edit cursor left by one grid unit' and 'Scroll horizontally and;or move loop and;or time selection by user defined interval')
-- proj end cannot be reached by the cursor hence alignment with it isn't a problem
local start_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false // https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and stop_time should be on the screen when non-zero when isSet is true
--local TCP_width = tonumber(cont:match('leftpanewid=(.-)\n')) -- only changes in reaper.ini when dragged
local proj_time_offset = r.GetProjectTimeOffset(0, false) -- rndframe false
return start_time == proj_time_offset
end



function ProjExtStates_2_Table(sect_name)
-- project extended state keys are iterated over
-- in the alphabetic order
-- so if the order in which data was stored
-- is important, the keys should preferably
-- be numeric or the data must be collected
-- into a table and the table must be sorted
-- based on certain criteria, such as coordinates
-- timestamp etc.
local i, t = 0, {}
	repeat
	local retval, key, val = r.EnumProjExtState(0, sect_name, i)
		if retval then
		t[#t+1] = {key=key,val=val}
		end
	i=i+1
	until not retval
table.sort(t, function(a,b) return a.val:match('%d+') < b.val:match('%d+') end) -- task specific
return t
end



---- VALIDATE VARIABLES


function Validate_Positive_Integer(str, type) -- str is a numeric string, type is a string, script specific to distinguish between 2 modes
local default = type and (type:lower() == 'bend' and 12 or type:lower() == 'offset' and 80)
	if not default then return end
local str = str:gsub(' ','') -- remove all spaces
local str = #str == 0 and default or tonumber(str)
return str and math.abs(str) > default and default or str and math.floor(str)
end


-- removes spaces for settings evaluation
function is_set(sett, is_literal)
-- sett is a string
-- is_literal is boolean to determine the gsub pattern
-- in case a long string is used as sett, i.e. the one inside [[ ]]

-- if literal string is used as sett it may happen to contain
-- implicit new lines which should be accounted for in evaluation
local pattern = is_literal and '[%s%c]' or ' '
return #sett:gsub(pattern,'') > 0
end


function validate_sett(sett, is_literal)
-- validate setting, can be either a non-empty string or any number
-- is_literal is boolean to determine the gsub pattern
-- in case a long literal string is used as sett, i.e. the one inside [[ ]]

-- if a long literal string is used for a setting it may happen to contain
-- implicit new lines which should be accounted for in evaluation
local pattern = is_literal and '[%s%c]' or ' '
return type(sett) == 'string' and #sett:gsub(pattern,'') > 0 or type(sett) == 'number' -- OR sett:match('[^%s%c]+') OR sett:match('%S') instead of #sett:gsub(pattern,'') > 0
end


function validate_multi_line_sett(sett)
-- add trailing line break in case the setting closing square brackets have been moved
-- to the last line, otherwise the last line won't be captured with the pattern
-- in the gmatch loop below
sett = not sett:match('.+\n%s*$') and sett..'\n' or sett
return #sett:gsub('[%s%c]','') > 0 and sett -- OR sett:match('[^%s%c]+') and sett
end


function validate_settings1(is_literal, ...) -- if actual setting value is immaterial
-- if a long literal string is used for all settings, i.e. the one inside [[ ]]
-- they may happen to contain implicit new lines
-- which should be accounted for in evaluation
local pattern = is_literal and '[%s%c]' or ' '
local t = {...}
	for k, sett in ipairs(t) do
		if type(sett) == 'string' and #sett:gsub('[%s%c]','') > 0 -- OR sett:match('[^%s%c]+')
		or type(sett) == 'number' then t[k] = true
		else t[k] = false
		end
	end
return table.unpack(t)
end
-- USE:
-- local sett1, sett2, sett3 =  validate_settings(sett1, sett2, sett3)


function validate_settings2(...) -- if numeric values matter
local t = {...}
	for k, sett in ipairs(t) do
		if type(sett) == 'string' and not tonumber(sett)
		or not type(sett) == 'number' then t[k] = false
		end
	end
return table.unpack(t)
end


function validate_settings3(...) -- if numeric values matter
local t = {...}
	for k, sett in ipairs(t) do
	t[k] = tonumber(sett) and math.floor(math.abs(tonumber(sett))) or false -- false is to prevent storing nil and thereby impeding table.unpack because without saved n value (number of fields) it will only unpack up until the first nil
	end
return table.unpack(t)
end



function validate_global_var(var_name, typ)
-- var_name is a string
-- typ is a string supported by the Lua type() function, optional
local var = _G[var_name]
return (not typ or typ and type(var) == typ) and var
end
-- EXAMPLE
-- local func = validate_global_var('func_name', 'function') -- look for global function referenced as a string

-- validate local variable
-- https://stackoverflow.com/questions/2834579/print-all-local-variables-accessible-to-the-current-scope-in-lua
-- https://www.gammon.com.au/scripts/doc.php?lua=debug.getlocal
-- this loop must not be enclosed in a function otherwise only variables local to the function will be traversed
local i = 1
local var_name, typ, var = '', '' -- type in var name and type supported by the Lua type() function which is optional
	repeat
	local name, val = debug.getlocal(1, i) -- 1 is stack level
		if name == var_name and (not typ or typ and type(val) == typ) then var = val break end
	i = i+1
	until not name


function Validate_All_Global_Settings(is_literal, ...) -- global vars must be passed as arguments in string representation; in current form only suitable for validation of truth
-- https://stackoverflow.com/questions/59448334/convert-string-to-variable-name-in-lua
-- https://love2d.org/forums/viewtopic.php?t=75392
-- https://stackoverflow.com/questions/67407628/in-lua-having-found-a-variable-of-type-function-in-g-how-to-pass-a-paramete

-- is_literal is boolean to determine the gsub pattern
-- in case literal string is used for a setting, e.g. [[ ]]

-- if literal string is used for a setting it may happen to contain
-- implicit new lines which should be accounted for in evaluation
local pattern = is_literal and '[%s%c]' or ' '
local t = {...}
local t2 = {}
	for k, setting in ipairs(t) do
	local glob_var = t[k]
	t2[setting] = #_G[glob_var]:gsub(pattern,'') > 0 -- OR #_G[t[k]]... // OR _G[glob_var]:match('[^%s%c]+')
	end
return t2
end
--[[
USAGE
a = '.'
b = ''
c = ' 2'
local t = Validate_All_Global_Settings(is_literal, 'a','b','c')
Msg(t.a) Msg(t.b) Msg(t.c)
]]



function Settings_Management_Menu_And_Help(condition, want_help, want_run)
-- manage script settings from a menu,
-- mainly geared towards boolean settings
-- (a version of the function which includes non-boolean settings
-- is used in Trigger action by audio signal or silence.lua)
-- the function updates the actual script file
-- used in Transcribing A - Create and manage segments (MAIN).lua
-- and Transcribing B - Create and manage segments (MAIN).lua
-- relies on Reload_Menu_at_Same_Pos2() and Esc() functions;
-- condition is boolean which triggers menu call,
-- want_help is boolean if 'About' text needs to be displayed to the user,
-- want_run is a boolean to create a menu button to execute the script;
-- any user settings not explicitly listed in user_sett table below 
-- will be ignored in the menu, i.e. MANAGE_SETTINGS_VIA_MENU setting
-- if present

--[[ -- HERE INSERT SOME CONDITION TO OPEN THE SETTINGS MENU IN A REGULAR SCRIPT
	 -- LIKE MOUSE POSITION SO THE MENU IS ONLY DISPLAYED AT CERTAIN MOUSE COORDINATES
	if not condition then return end -- this will allow the main script routine to run if the condition for menu display isn't met
]]

::RELOAD::

local is_new_value, scr_name, sect_ID, cmd_ID, mode, resol, val, contextstr = r.get_action_context() -- TO BE AWARE THAT HERE THIS FUNCTION WILL GLITCH OUT IF IT'S ALREADY USED OUTSIDE OF THE FUNCTION SO scr_name VAR MAY NEED TO BE FED AS AN ARGUMENT

local sett_t, help_t, about = {}, want_help and {} -- help_t is optional if help is important enough
	for line in io.lines(scr_name) do
	-- collect settings
		if line:match('----- USER SETTINGS ------') and #sett_t == 0 then
		sett_t[#sett_t+1] = line
		elseif line:match('END OF USER SETTINGS')
		and not sett_t[#sett_t]:match('END OF USER SETTINGS') then
		sett_t[#sett_t+1] = line
		break
		elseif #sett_t > 0 then
		sett_t[#sett_t+1] = line
		end
		-- collect help
		if want_help then
			if #help_t == 0 and line:match('About:') then
			help_t[#help_t+1] = line:match('About:%s*(.+)')
			about = 1
			elseif line:match('----- USER SETTINGS ------') then
			about = nil -- reset to stop collecting lines
			elseif about then -- collect lines
			help_t[#help_t+1] = line:match('%s*(.-)$')
			end
		end
	end

local user_sett = {'setting1', 'setting2'} -- POPULATE WITH NAMES OF ACTUAL SETTING VARIABLES // not all settings have to be included, those which aren't listed will not be available in the menu
local menu_sett = {}
	for k, v in ipairs(user_sett) do
		for k, line in ipairs(sett_t) do
		local sett = line:match(v..'%s*=%s*"(.-)"')
			if sett then
			menu_sett[#menu_sett+1] = #sett:gsub(' ','') > 0 and '!' or ''
			end
		end
	end

-- type in actual setting names or their versions as menu item labels
local menu = ('USER SETTINGS'):gsub('.','%0 ')..'||'..menu_sett[1]..'sett1||'
..menu_sett[2]..'sett2||'..menu_sett[3]..'sett3||'
..menu_sett[4]..'sett4|||View Help|'..(want_run and ('RUN'):gsub('.','%0 ') or ' ')

local output = Reload_Menu_at_Same_Pos(menu, 1) -- keep_menu_open true

	if output == 6 and want_help and #help_t > 0 then -- THE output VALUE DEPENDS ON THE NUMBER OF MENU ITEMS
	r.ShowConsoleMsg(table.concat(help_t,'\n'):match('(.+)%]%]'),r.ClearConsole()) -- trimming the first line of user settings section because it's captured by the loop
	end
	
	if want_run and output == 7 then -- THE output VALUE DEPENDS ON THE NUMBER OF MENU ITEMS
	return menu_sett
	elseif output == 0 then return 1 -- i.e. truth will trigger script abort to prevent activation of the main routine when menu is exited
	elseif output < 2 or output >= 6 then -- THE VALUES DEPEND ON THE NUMBER OF MENU ITEMS
	return 1 -- 1 i.e. truth will trigger script abort to prevent activation of the main routine when menu is exited
	-- OR goto RELOAD -- if clicked on an invalid item, i.e. title or blank
	end

output = output-1 -- offset the 1st menu item which is a title
local src = user_sett[output]
local sett = menu_sett[output] == '!' and '' or '1' -- fashion toggle
local repl = src..' = "'..sett..'"'
local cur_settings = table.concat(sett_t,'\n')
local upd_settings, cnt = cur_settings:gsub(src..'%s*=%s*".-"', repl, 1)

	if cnt > 0 then -- settings were updated, get script
	local f = io.open(scr_name,'r')
	local cont = f:read('*a')
	f:close()
	cur_settings = Esc(cur_settings)
	upd_settings = upd_settings:gsub('%%','%%%%')
	cont, cnt = cont:gsub(cur_settings, upd_settings)
		if cnt > 0 then -- settings were updated, write to file
		local f = io.open(scr_name,'w')
		f:write(cont)
		f:close()
		end
	end

goto RELOAD

end
--[[ USE:
	if Settings_Management_Menu_And_Help(condition, want_help) then -- want_run is nil so the script will be aborted in any event
	return r.defer(no_undo) -- menu was exited or item is invalid
	end

-- OR (if MANAGE_SETTINGS_VIA_MENU setting is present or the settings are meant to be managed via the menu always)

local menu = #MANAGE_SETTINGS_VIA_MENU:gsub(' ','') > 0 -- only if such setting is present

local user_sett = menu and Settings_Management_Menu_And_Help(condition, want_help, 1) -- want_run true

	if not user_sett then r.defer(no_undo) end
	
-- initialize here if settings menu is enabled, 
-- otherwise use original variables from USER SETTINGS section
function validate_sett(sett, menu_sett)
return #(menu_sett or sett):gsub(' ','') > 0
end
sett1 = validate_sett(sett1, user_sett and user_sett[1])
sett2 = validate_sett(sett2, user_sett and user_sett[2])
sett3 = validate_sett(sett3, user_sett and user_sett[3])

]]




function Toggle_Settings_From_Menu(t, menu, scr_path)
-- t is table containing setting values, setting names and setting menu labels
-- see example after the function,
-- in the function instance before the menu loading it includes attributes of all settings,
-- in the function instance triggered by a click on a menu item it only includes 
-- attributes of a setting which corresponds to the clicked menu item;
-- scr_path serves as trigger for the routine of toggling the setting directly from the menu
-- if scr_path arg is absent the menu is updated based on the current
-- settings passed as t (first function instance)

	local function update_menu_items(menu, sett, menu_itm)
	return menu:gsub((sett and '' or '!')..menu_itm,
	(sett and '!' or '')..menu_itm, 1)
	end

	if not scr_path then
	-- compare current settings in the script with the menu state loaded as extended data
	-- at the menu loading stage
		for k, nested_t in pairs(t) do -- using pairs in case indexing doesn't start at 1 and/or isn't sequential
		local sett, menu_itm = nested_t[1], nested_t[3]
		local menu_itm_checked = menu:match('!'..menu_itm) and true or false -- assign booleans for comparison of identical value type
			if sett ~= menu_itm_checked then
			menu = update_menu_items(menu, sett, menu_itm) -- if menu item is not checkmarked, add checkmark and vice versa
			end
		end
	else
	local sett_name, menu_itm = t[2], t[3]
	-- toggle from the menu
	local menu_itm_checked = menu:match('!'..menu_itm) and true or false -- assign booleans for comparison of identical value type 
	-- toggle
	menu = update_menu_items(menu, not menu_itm_checked, menu_itm) -- 'not' because here if menu item is checked it must be flipped as a result of a toggle and vice versa
	 
		if sett == menu_itm_checked then

		-- Update the setting within the script

		-- load the setting
		local settings, sett_line
			for line in io.lines(scr_path) do
				if not settings and line:match('----- USER SETTINGS ------') then
				settings = 1
				elseif settings and line:match('^%s*'..sett_name..'%s*=%s*".-"') then -- ensuring that it's the setting line and not reference to it elsewhere
				sett_line = line
				break
				elseif line:match('END OF USER SETTINGS') then
				break
				end
			end

			-- update script if settings equal to the original menu item state
			-- i.e. state before the change of the menu item state      
			if sett_line and #sett_line:match('"([^%s]-)"') > 0 == menu_itm_checked then -- basically redundant condition because this was already evaluated as 'sett == menu_itm_checked' above
			local f = io.open(scr_path,'r')
			local cont = f:read('*a')
			f:close()
			local sett_upd = sett_name..' = "'..(menu_itm_checked and '' or '1')..'"' -- toggle
			local cont, cnt = cont:gsub(sett_name..'%s*=%s*".-"', sett_upd, 1)
				if cnt > 0 then -- settings were updated, write to file
				local f = io.open(scr_path,'w')
				f:write(cont)
				f:close()
				end
			end

		t[1] = not t[1] -- invert original setting boolean because it's been toggled

		end 
	 
	end

return menu, t[1] -- 2nd return value is the setting after toggling to be used by script functions downstream

end

--[[ USE EXAMPLE:

-- MEANT TO BE USED IN PARALLEL WITH MENU STORAGE AS EXTENDED STATE

-- validate settings
sett1 = validate_sett(sett1)
sett2 = validate_sett(sett2)
sett3 = validate_sett(sett3)

--	IF SETTING MENU ITEMS INDICES AREN'T SEQUENTIAL
-- THE KEYS WILL HAVE TO BE EXPLICITLY SPECIFIED IN ALL THE TABLES
local sett_t = table.pack(sett1, sett2, sett3) -- setting values, settings must be pure booleans, nil value isn't supported
local menu_t = {'menu item1', 'menu item2', 'menu item3'} -- menu labels which match settings
local t = {{'sett1'},{'sett2'},{'sett3'}} -- setting names

  for k in pairs(t) do -- using pairs in case indexing doesn't start at 1 and/or isn't sequential
  table.insert(t[k],1, sett_t[k])
  table.insert(t[k], menu_t[k])
  end
--[=[ the loop above creates a table structured like this:
{{sett1, 'sett1,', 'menu item1'},
{sett2, 'sett2,', 'menu item2'},
{sett3, 'sett3,', 'menu item3'},}
--]=]

local menu = table.concat(menu_t,'|')

-------- LOAD/STORE MENU STATE START --------

local ext_state = r.GetExtState(scr_name, KEY) -- first try loading the menu from the global extended state
		if ext_state == '' then -- if absent, load from project extended state
		ret, ext_state = r.GetProjExtState(0, scr_name, KEY)
		end
		if ext_state ~= '' then -- if there's extended state menu data
		-- update items toggle state in the menu loaded from extended state
		-- according to the current settings in the script in case it's changed
		menu = Toggle_Settings_From_Menu(t, menu)
		end

::RELOAD::

-- store updated menu item toggle state
r.SetExtState(scr_name, KEY, menu, false) -- persist false
r.SetProjExtState(0, scr_name, KEY, menu)

-------- LOAD/STORE MENU STATE END --------

local output = Reload_Menu_at_Same_Pos(menu, 1) -- keep_menu_open true

  if output > 0 and output < 4 then -- the actual output values will depend on the menu structure, the output value may need offsetting if setting menu items don't start at index 1 as they do within the table
  menu, retval = Toggle_Settings(t[output], menu, 1)
    if output == 1 then
    sett1 = retval
    elseif output == 2 then
    sett2 = retval
    else
    sett3 = retval
    end
  goto RELOAD
  end

--]]


function Toggle_Setting_From_Menu(sett_name, scr_path)
-- sett_name is a string
-- the function is not designed to work
-- with menu loaded from extended state

-- load the setting
local settings, sett_line
	for line in io.lines(scr_path) do
		if not settings and line:match('----- USER SETTINGS ------') then
		settings = 1
		elseif settings and line:match('^%s*'..sett_name..'%s*=%s*".-"') then -- ensuring that it's the setting line and not reference to it elsewhere
		sett_line = line
		break
		elseif line:match('END OF USER SETTINGS') then
		break
		end
	end

local sett_new_state = sett_line:match('^%s*'..sett_name..'%s*=%s*"(%S+)"') and '' or '1' -- toggle

-- update
local f = io.open(scr_path,'r')
local cont = f:read('*a')
f:close()
local sett_upd = sett_name..' = "'..sett_new_state..'"'
local cont, cnt = cont:gsub(sett_name..'%s*=%s*".-"', sett_upd, 1)
	if cnt > 0 then -- settings were updated, write to file
	local f = io.open(scr_path,'w')
	f:write(cont)
	f:close()
	end

return sett_new_state

end
--[[ USE EXAMPLE:
::RELOAD::
sett = sett:match('%S+') -- validate
local output = Reload_Menu_at_Same_Pos(menu)
	if output == 1 then
	sett = Toggle_Setting_From_Menu(sett_name, scr_path)
	goto ::RELOAD::
	end
--]]


function Display_Script_Help_Txt(scr_path)
-- scr_path stems from get_action_context()

local help_t = {}
	for line in io.lines(scr_path) do
		if #help_t == 0 and line:match('About:') then
		help_t[#help_t+1] = line:match('About:%s*(.+)')
		about = 1
		elseif line:match('----- USER SETTINGS ------') then -- captures without escaped '-' for some reason
		r.ShowConsoleMsg(table.concat(help_t,'\n'):match('(.+)%]%]'), r.ClearConsole()) return -- trimming the first line of user settings section because it's captured by the loop
		elseif about then
		help_t[#help_t+1] = line:match('%s*(.-)$')
		end
	end
end



function Get_Main_Script_Settings(main_scr_name)
-- load main script settings in an ancillary script
-- and only use ancillary script own setting if they're enabled
-- main_scr_name must include extension

package.path = debug.getinfo(1,"S").source:match[[^@?(.*[\/])[^\/]-$]]
local path = package.path..'my_Multi-line caption aide (for use with Video processor).lua'
local f = io.open(path,'r')
local values = {sett1, sett2, sett3} -- variable values // not all settings have to be included, only those relevant to the current script

	if f then	

	-- parse main script settings section
	local sett_t = {}
		for line in f:lines() do
			if line:match('----- USER SETTINGS ------') and #sett_t == 0 or #sett_t > 0 then
			sett_t[#sett_t+1] = line
			elseif #sett_t > 0 and line:match('END OF USER SETTINGS')
			and not sett_t[#sett_t]:match('END OF USER SETTINGS') then
			break
			end
		end
		
	f:close()

	-- not all settings have to be included, only those relevant to the current script
	local names = {'sett1', 'sett2', 'sett3'} -- variable names, must match 'values' table above

		for k, name in ipairs(names) do
			for i, line in ipairs(sett_t) do
			local sett = line:match(name..'%s*=%s*"(.-)"')
				if sett then
				local val = values[k]
				values[k] = val:match('%S+') and val or sett -- if setting is enabled in the current script, use it, otherwise assign the state the setting has in the main script
				end
			end
		end
	
	end

return table.unpack(values)	
	
end
--[[ USE:
sett1, sett2, sett3 = Get_Main_Script_Settings(main_scr_name) -- first load them from the main script
-- then validate as usual and as necessary depending on the setting type
]]



function validate_output1(str) -- with GetUserInputs()
local str = str:gsub(' ','')
return #str > 0 and str ~= ',,' -- 3 field user dialogue if separator is a comma
end
-- USE:
-- if not retval or not validate_output(output) then return r.defer(function() do return end end) end


function validate_output2(str, separator, field_cnt) -- with GetUserInputs()
-- str and separator are strings
-- field_cnt is integer
local str = str:gsub(' ','')
return #str > 0 and str ~= separator:rep(field_cnt)
end


---------------------------------------------------------------------------------------------
-- Get command ID of the executed action, the action must be run
-- for its command ID to be returned by the function
local comm_id

function Get_Action_ID()
--local t = {0,32060,32061,32062,32063} -- UNUSED
comm_id = r.PromptForAction(0, 0, 0) -- session_mode 0, init_id 0, section_id 0 // POLL
--Msg(comm_id)
	if comm_id > 0 then
	r.PromptForAction(-1, 0, 0) -- session_mode -1, init_id 0, section_id 0 // STOP
	return end
r.defer(Get_Action_ID)
end

r.PromptForAction(1, 0, 0) -- session_mode 1, init_id 0, section_id 0 // LAUNCH
Get_Action_ID()
r.atexit(function() r.ShowConsoleMsg(r.ReverseNamedCommandLookup(comm_id)) end)

----------------------------------------------------------------------------------------

-- do something in X sec
local cur_time = os.time() -- in sec
local duration = 300 -- in sec
function do_in_X_mins(cur_time, duration)
	if select(2, math.modf((os.time() - cur_time)/duration)) == 0 then -- when the difference can be divided by duration without remainder it means exactly the duration value
		-- DO STUFF --
	end
end


function ACT1(comm_ID) -- both string and integer work
local comm_ID = comm_ID and r.NamedCommandLookup(comm_ID)
local act = comm_ID and comm_ID ~= 0 and r.Main_OnCommand(r.NamedCommandLookup(comm_ID),0)
end


function ACT2(comm_ID, islistviewcommand, midi) -- islistviewcommand, midi are boolean
-- islistviewcommand is based on evaluation of sectionID returned by get_action_context()
-- e.g. sectionID == 32061
local act = midi and r.MIDIEditor_LastFocused_OnCommand(r.NamedCommandLookup(comm_ID), islistviewcommand) -- islistviewcommand false
or not midi and r.Main_OnCommand(r.NamedCommandLookup(comm_ID), 0) -- not midi cond is required because even if midi var is true the previous expression produces falsehood because the MIDIEditor_LastFocused_OnCommand() function doesn't return anything
end


function ACT3(comm_ID, islistviewcommand, midi) -- islistviewcommand, midi are boolean
-- islistviewcommand is based on evaluation of sectionID returned by get_action_context()
-- e.g. sectionID == 32061
local comm_ID = comm_ID and r.NamedCommandLookup(comm_ID)
local act = comm_ID and comm_ID ~= 0 and (midi and r.MIDIEditor_LastFocused_OnCommand(comm_ID, islistviewcommand) -- islistviewcommand false
or not midi and r.Main_OnCommand(comm_ID, 0)) -- not midi cond is required because even if midi var is true the previous expression produces falsehood because the MIDIEditor_LastFocused_OnCommand() function doesn't return anything // only if valid command_ID
end



local ME = r.MIDIEditor_GetActive() -- UNRELIABLE if script is run from the Main section of the action list, see MIDIEditor_GetActiveAndVisible()
function ACT4(ID, ME) -- supports MIDI Editor actions, get MIDI editor pointer ME and add as argument otherwise can be left out
-- ID - string or integer
	if ID then
	local ID = r.NamedCommandLookup(ID) -- works with srings and integers
		if ID ~= 0 then -- valid command_ID
			if not ME then r.Main_OnCommand(ID, 0)
			else
			r.MIDIEditor_LastFocused_OnCommand(ID, false) -- islistviewcommand is false
		--	r.MIDIEditor_OnCommand(ME, ID)
			end
		end
	end
end


function get_tog_state(sect_ID, comm_ID)
-- supports string command IDs
return r.GetToggleCommandStateEx(sect_ID, r.NamedCommandLookup(comm_ID))
end


function capture_command(input, str) -- weed out illegal entries in the Profile console
-- the input comes from GetUserInputs()

	for cmd in input:gmatch('[^,]*') do -- check all slots; if dot were added here it would help to catch decimal numbers, but opted for error in the main routine
		if cmd ~= '' and cmd ~= '0' and cmd ~= '1' and not cmd:match('^h+$') and not cmd:match('oo?ut') and cmd ~= 'quit' and not cmd:match('oo?pen') and cmd ~= 'reload' and not cmd:match('toolbar[0-9]+') and not cmd:match('toolbar[0-8]m') and not cmd:match('auto[0-9]+') and cmd ~= 'auto0' then input = nil break end
	end

	if input and str then
	input = input:match('^('..str..'),') or input:match(',('..str..'),') or input:match(',('..str..')$')
	end

return input

end


--------------------------------------------

-- Enable this setting by inserting any QWERTY alphanumeric
-- character between the quotation marks so the script can be used
-- then configure the settings below
ENABLE_SCRIPT = ""
function Script_Not_Enabled(ENABLE_SCRIPT)
	if #ENABLE_SCRIPT:gsub(' ','') == 0 then
	local emoji = [[
		_(ツ)_
		\_/|\_/
	]]
	r.MB('  Please enable the script in its USER SETTINGS.\n\nSelect it in the Action list and click "Edit action...".\n\n'..emoji, 'PROMPT', 0)
	return true
	end
end
if Script_Not_Enabled(ENABLE_SCRIPT) then return r.defer(function() do return end end) end


-- Enable this setting by inserting by inserting any alphanumeric
-- character between the quotation marks
-- to permanently prevent USER SETTINGS reminder pop-up
REMINDER_OFF = ""
function Reminder_Off(REMINDER_OFF)
	local function gap(n) -- number of repeats, integer
	local n = not n and 0 or tonumber(n) and math.abs(math.floor(n)) or 0
	return string.rep(' ',n)
	-- return (' '):rep(n)
	end
local _, scr_name, scr_sect_ID, cmd_ID, _,_,_ = r.get_action_context()
local scr_name = scr_name:match('([^\\/]+)%.%w+') -- without path and extension
--local cmd_ID = r.ReverseNamedCommandLookup(cmd_ID) -- to use instead of scr_name // just an idea
local ret, state = r.GetProjExtState(0, scr_name, 'REMINDER_OFF')
	if #REMINDER_OFF:gsub(' ','') == 0 and ret == 0 then
	local resp = r.MB('\t'..gap(7)..'This is to make you aware\n\n'..gap(12)..'that the script includes USER SETTINGS\n\n'..gap(10)..'you might want to tailor to your workflow.\n\n'..gap(17)..'Clicking "OK" disables this prompt\n\n'..gap(8)..'for the current project (which will be saved).\n\n\t'..gap(6)..'To disable it permanently\n\n change the REMINDER_OFF setting inside the script.\n\n   Select it the the Action list and click "Edit action..."', 'REMINDER', 1)
		if resp == 1 then
		r.SetProjExtState(0, scr_name, 'REMINDER_OFF', '1')
		r.Main_SaveProject(0, false) -- forceSaveAsIn false
		return true
		end
	else return true
	end
end
if not Reminder_Off(REMINDER_OFF) then return r.defer(function() do return end end) end


-------------------------------------------

-- before build 6.82 gfx.showmenu didn't work on Windows without gfx.init
-- https://forum.cockos.com/showthread.php?t=280658#25
-- https://forum.cockos.com/showthread.php?t=280658&page=2#44
-- the earliest appearence of a particular character in the menu can be used as a shortcut
-- in this case they don't have to be preceded with ampersand '&'
-- only if particular instance of a character should be used as a shortcut
-- such character must be preceded with ampresand '&' otherwise it will be overriden
-- by its earliest appearance in the menu
-- some characters still do need ampresand, e.g. < and >
local old = tonumber(r.GetAppVersion():match('[%d%.]+')) < 6.82
-- screen reader used by blind users with OSARA extension may be affected
-- by the absence if the gfx window therefore only disable it in builds
-- newer than 6.82 if OSARA extension isn't installed
-- ref: https://github.com/Buy-One/REAPER-scripts/issues/8#issuecomment-1992859534
local OSARA = r.GetToggleCommandState(r.NamedCommandLookup('_OSARA_CONFIG_reportFx')) >= 0 -- OSARA extension is installed
local init = (old or OSARA) and gfx.init('', 0, 0)
-- open menu at the mouse cursor
-- https://www.reaper.fm/sdk/reascript/reascripthelp.html#lua_gfx_variables
gfx.x = gfx.mouse_x
gfx.y = gfx.mouse_y
local input = gfx.showmenu(menu) -- menu string
local quit = old and gfx.quit()



function Show_Menu_Dialogue(menu)
-- before build 6.82 gfx.showmenu didn't work on Windows without gfx.init
-- https://forum.cockos.com/showthread.php?t=280658#25
-- https://forum.cockos.com/showthread.php?t=280658&page=2#44
-- the earliest instance of a particular character at the start of a menu item
-- can be used as a shortcut provided this character is unique in the menu
-- in this case they don't have to be preceded with ampersand '&'
-- if it's not unique, inputting it from keyboard will select
-- the menu item starting with this character
-- and repeated input will oscilate the selection between menu items
-- which start with it without actually triggering them
-- only if particular instance of a character should be used as a shortcut
-- such character must be preceded with ampresand '&' otherwise it will be overriden
-- by its earliest instance at the start of a menu item
-- some characters still do need ampresand, e.g. < and >;
-- characters which aren't the first in the menu item name
-- must also be explicitly preceded with ampersand
local old = tonumber(r.GetAppVersion():match('[%d%.]+')) < 6.82
-- screen reader used by blind users with OSARA extension may be affected
-- by the absence if the gfx window therefore only disable it in builds
-- newer than 6.82 if OSARA extension isn't installed
-- ref: https://github.com/Buy-One/REAPER-scripts/issues/8#issuecomment-1992859534
local OSARA = r.GetToggleCommandState(r.NamedCommandLookup('_OSARA_CONFIG_reportFx')) >= 0 -- OSARA extension is installed
local init = (old or OSARA) and gfx.init('', 0, 0)
-- open menu at the mouse cursor
-- https://www.reaper.fm/sdk/reascript/reascripthelp.html#lua_gfx_variables
gfx.x = gfx.mouse_x
gfx.y = gfx.mouse_y
return gfx.showmenu(menu)
end
-- if output == 0 then return r.defer(no_undo) end -- IF RELOADING AFTER CLICK IS CRUCIAL TO PREVENT ENDLESS LOOP OR do if output > 0 then ... else return r.defer(no_undo) end



function Reload_Menu_at_Same_Pos1(menu, keep_menu_open, left_edge_dist)
-- only useful for looking up the result of a toggle action, 
-- see a more practical example as Reload_Menu_at_Same_Pos2() below
-- keep_menu_open is boolean
-- left_edge_dist is integer to only display the menu
-- when the mouse cursor is within the sepecified distance in px from the screen left edge
-- the earliest instance of a particular character at the start of a menu item
-- can be used as a shortcut provided this character is unique in the menu
-- in this case they don't have to be preceded with ampersand '&'
-- if it's not unique, inputting it from keyboard will select
-- the menu item starting with this character
-- and repeated input will oscilate the selection between menu items
-- which start with it without actually triggering them
-- only if particular instance of a character should be used as a shortcut
-- such character must be preceded with ampresand '&' otherwise it will be overriden
-- by its earliest instance at the start of a menu item
-- some characters still do need ampresand, e.g. < and >;
-- characters which aren't the first in the menu item name
-- must also be explicitly preceded with ampersand

::RELOAD::

left_edge_dist = left_edge_dist and left_edge_dist > 0 and math.floor(left_edge_dist)
local x, y = r.GetMousePosition()

	if left_edge_dist and x <= left_edge_dist or not left_edge_dist then -- 100 px within the screen left edge
	-- before build 6.82 gfx.showmenu didn't work on Windows without gfx.init
	-- https://forum.cockos.com/showthread.php?t=280658#25
	-- https://forum.cockos.com/showthread.php?t=280658&page=2#44
	-- BUT LACK OF gfx WINDOW DOESN'T ALLOW RE-OPENING THE MENU AT THE SAME POSITION via ::RELOAD::
	-- therefore enabled when keep_menu_open is valid
	local old = tonumber(r.GetAppVersion():match('[%d%.]+')) < 6.82
	-- screen reader used by blind users with OSARA extension may be affected
	-- by the absence if the gfx window therefore only disable it in builds
	-- newer than 6.82 if OSARA extension isn't installed
	-- ref: https://github.com/Buy-One/REAPER-scripts/issues/8#issuecomment-1992859534
	local OSARA = r.GetToggleCommandState(r.NamedCommandLookup('_OSARA_CONFIG_reportFx')) >= 0 -- OSARA extension is installed
	local init = (old or OSARA or not old and not OSARA and keep_menu_open) and gfx.init('', 0, 0)
			-- open menu at the mouse cursor, after reloading the menu doesn't change its position based on the mouse pos after a menu item was clicked, it firmly stays at its initial position
			-- ensure that if keep_menu_open is enabled the menu opens every time at the same spot
			if keep_menu_open and not coord_t then -- keep_menu_open is the one which enables menu reload
			coord_t = {x = gfx.mouse_x, y = gfx.mouse_y}
			elseif not keep_menu_open then
			coord_t = nil
			end

	-- sets menu position to mouse
	-- https://www.reaper.fm/sdk/reascript/reascripthelp.html#lua_gfx_variables
	gfx.x = coord_t and coord_t.x or gfx.mouse_x
	gfx.y = coord_t and coord_t.y or gfx.mouse_y
	local retval = gfx.showmenu(menu) -- menu string
		if retval > 0 then
		goto RELOAD
		end
	end

end



function Reload_Menu_at_Same_Pos2(menu, keep_menu_open, left_edge_dist)
-- keep_menu_open is boolean
-- left_edge_dist is integer to only display the menu
-- when the mouse cursor is within the sepecified distance in px from the screen left edge
-- the earliest instance of a particular character at the start of a menu item
-- can be used as a shortcut provided this character is unique in the menu
-- in this case they don't have to be preceded with ampersand '&'
-- if it's not unique, inputting it from keyboard will select
-- the menu item starting with this character
-- and repeated input will oscilate the selection between menu items
-- which start with it without actually triggering them
-- only if particular instance of a character should be used as a shortcut
-- such character must be preceded with ampresand '&' otherwise it will be overriden
-- by its earliest instance at the start of a menu item
-- some characters still do need ampresand, e.g. < and >;
-- characters which aren't the first in the menu item name
-- must also be explicitly preceded with ampersand

left_edge_dist = left_edge_dist and left_edge_dist > 0 and math.floor(left_edge_dist)
local x, y = r.GetMousePosition()

	if left_edge_dist and x <= left_edge_dist or not left_edge_dist then -- 100 px within the screen left edge
	-- before build 6.82 gfx.showmenu didn't work on Windows without gfx.init
	-- https://forum.cockos.com/showthread.php?t=280658#25
	-- https://forum.cockos.com/showthread.php?t=280658&page=2#44
	-- BUT LACK OF gfx WINDOW DOESN'T ALLOW RE-OPENING THE MENU AT THE SAME POSITION via ::RELOAD::
	-- therefore enabled with keep_menu_open is valid
	local old = tonumber(r.GetAppVersion():match('[%d%.]+')) < 6.82
	-- screen reader used by blind users with OSARA extension may be affected
	-- by the absence if the gfx window therefore only disable it in builds
	-- newer than 6.82 if OSARA extension isn't installed
	-- ref: https://github.com/Buy-One/REAPER-scripts/issues/8#issuecomment-1992859534
	local OSARA = r.GetToggleCommandState(r.NamedCommandLookup('_OSARA_CONFIG_reportFx')) >= 0 -- OSARA extension is installed
	local init = (old or OSARA or not old and not OSARA and keep_menu_open) and gfx.init('', 0, 0)
	-- open menu at the mouse cursor, after reloading the menu doesn't change its position based on the mouse pos after a menu item was clicked, it firmly stays at its initial position
		-- ensure that if keep_menu_open is enabled the menu opens every time at the same spot
		if keep_menu_open and not coord_t then -- keep_menu_open is the one which enables menu reload
		coord_t = {x = gfx.mouse_x, y = gfx.mouse_y}
		elseif not keep_menu_open then
		coord_t = nil
		end

	gfx.x = coord_t and coord_t.x or gfx.mouse_x
	gfx.y = coord_t and coord_t.y or gfx.mouse_y

	return gfx.showmenu(menu) -- menu string

	end

end
-- USE:
--[[
::RELOAD::
local retval = Reload_Menu_at_Same_Pos2(menu)
	if retval and retval == xyz then -- returned menu item index other than 0
-- DO STUFF
	goto RELOAD
	else return r.defer(function() do return end end)
	end
-- OR
	if retval == 0 then return r.defer(function() do return end end) -- CRUCIAL TO PREVENT ENDLESS RELOAD LOOP
	else
		if retval == abc then
		-- DO STUFF
		elseif retval == xyz then
		-- DO OTHER STUFF
		end
	goto RELOAD
	end
]]


-- to be used with a gfx window to open the menu when the window is clicked
function Reload_Menu_at_Same_Pos_gfx(menu)
	if gfx.mouse_y > gfx.y and gfx.mouse_y < gfx.h then
	gfx.y = gfx.mouse_y + 3 -- open the menu 3 px under the mouse cursor to prevent activation of the top menu item
	end
return gfx.showmenu(menu) -- menu string
end
--[[ USE:
::RELOAD::
local output = Reload_Menu_at_Same_Pos_gfx(menu)
	if output > 0 then
	-- DO STUFF
	goto RELOAD
	end
]]



function Get_Set_Menu_Toggle_Options(named_ID, opt_st_idx, opt_end_idx, t, output, want_excl)
-- named_ID is the script named ID converted with ReverseNamedCommandLookup()
-- from numeric command ID obtained from get_action_context()
-- opt_st_idx, opt_end_idx are options start and end indices in the menu
-- must be contiguous;
-- options are stored as 0s and 1s, e.g. 00101
-- t, output and want_excl are only relevant at the Set stage
-- t is returned at Get stage, output is index returned by the menu
-- want_exl is boolean if options must be mutually exclusive
-- the Get stage comes before menu concatenation
-- the Set stage comes after receiving menu output

local opts = r.GetExtState(named_ID, 'OPTIONS')

	if not t then -- GET
	local t = {}
		for i=opt_st_idx, opt_end_idx do
		t[i] = 0 -- initialize all off
		end
	local i = opt_st_idx
		for opt in opts:gmatch('%d') do
			if opt then
			t[i] = opt
			i=i+1
			end
		end
	return t -- will be used for adding checkmarks to the menu and for activating the SET stage
	else -- SET
	local cnt = opt_end_idx-opt_st_idx+1
	opts = want_excl and ('0'):rep(cnt) or opts
-- OR without cnt
--	opts = want_excl and ('0'):rep(#t) or opts
		for k, opt in ipairs(t) do
			if output == k then
			local new_val = opt == '1' and '0' or '1' -- toggle
		-- OR
		--	local new_val = tonumber(opt)~1 -- toggle
			local i = 0
			opts = opts:gsub('0', function() i=i+1 if i==k then return new_val end end)
			break end
		end
	--[[ ALSO WORKS
	local i = 0 -- if options didn't start from index 1, i value would have to be offset
		for opt in opts:gmatch('%d') do
			if opt then
			i=i+1
				if i == output then
				local new_val = t[i] == '1' and '0' or '1' -- toggle
			-- OR
			-- local new_val = tonumber(t[i])~1 -- toggle
				local i = 0
				opts = opts:gsub('0', function() i=i+1 if i==output then return new_val end end)
				break end
			end
		end
	--]]
	r.SetExtState(named_ID, 'OPTIONS', opts, false) -- persist false
	end

end
--[[ USE

::RELOAD::
local opts_t = Get_Set_Menu_Toggle_Options(named_ID, opt_st_idx, opt_end_idx)

function menu_check(sett)
return sett == '1' and '!' or ''
end

local menu = menu_check(opts_t[1])..'opt1||'..menu_check(opts_t[2])..'opt2||' -- AND SO ON

local output = Reload_Menu_at_Same_Pos(menu, 1) -- keep_menu_open true

	if output >= opt_st_idx and output <= opt_end_idx then
	Get_Set_Menu_Toggle_Options(named_ID, opt_st_idx, opt_end_idx, opts_t, output, want_excl)
	goto RELOAD
	end
]]


function Menu_With_Toggle_Options1(scr_cmd_ID, sett_t, menu_t, default_sett_state)
-- scr_cmd_ID comes from get_action_context()
-- default_sett_state is optional, the format is e.g. '111', i.e. all 3 options
-- are On by default, the string length must be equal to #sett_t
-- if invalid or not equal to #sett_t defaults to all Off;
-- relies on Reload_Menu_at_Same_Pos2() function

::RELOAD::

local sett_t = sett_t or {'My setting 1', 'My setting 2', 'My setting 3'}
local menu_t = menu_t or {'Item 1|', 'Item 2|', sett_t[1]..'|',  sett_t[2]..'|', 'Item 3|', sett_t[3]..'|'}

local sett_indices_t = {}
	for menu_idx, item in ipairs(menu_t) do
		for sett_idx, sett in ipairs(sett_t) do
			if item:gsub('|','') == sett then
			sett_indices_t[menu_idx] = sett_idx -- store settings array index under menu index
			break end
		end
	end

local default_sett_state = default_sett_state and #default_sett_state == #sett_t and default_sett_state 
or ('0'):rep(#sett_t) -- if invalid or length doesn't match sett_t length default to all Off
local sett = r.GetExtState(scr_cmd_ID, 'SETTINGS')
local sett_bools_t = {(#sett > 0 and sett or default_sett_state):match(('(%d)'):rep(#sett_t))} -- initializing defaults if first load

	-- Checkmark enabled settings in the menu
	for sett_idx, bool in ipairs(sett_bools_t) do
		for menu_idx, v in pairs(sett_indices_t) do
			if v+0 == sett_idx then -- a setting index in the menu has been found
			local sett = menu_t[menu_idx]
			menu_t[menu_idx] = bool == '1' and '!'..sett or sett
			break end
		end
	end

local output = Reload_Menu_at_Same_Pos2(table.concat(menu_t), 1) -- keep_menu_open true
	
	if output == 0 then return
	elseif sett_indices_t[output] then
	local idx = sett_indices_t[output] -- extract index relevant for sett_t table
	local i = 0
	sett = table.concat(sett_bools_t):gsub('%d', function(c) i=i+1 if i==idx then return math.floor(c+0~1) end end) -- flipping the bit
	else -- expand with other menu items if necessary
	end
	
	if sett_indices_t[output] then -- this condition will likely need expansion to include indices of other menu items which aren't settings
	r.SetExtState(scr_cmd_ID, 'SETTINGS', sett, false) -- persist false
	goto RELOAD end
	
end
--[[ USE:
local is_new_value, scr_name, sect_ID, cmd_ID, mode, resol, val, contextstr = r.get_action_context()
local named_ID = r.ReverseNamedCommandLookup(cmd_ID) -- convert to named
or scr_name -- if an non-installed script is run via 'ReaScript: Run (last) ReaScript (EEL2 or lua)' actions get_action_context() won't return valid command ID, in which case fall back on the script full path
Menu_With_Toggle_Options(named_ID, sett_t, menu_t, default_sett_state)
]]



function Menu_With_Toggle_Options2(scr_cmd_ID, sett_t, menu_t, default_sett_state)
-- this version stores enabled settings as a bitfield 
-- rather than as a literal base 2 value;
-- scr_cmd_ID comes from get_action_context()
-- default_sett_state is a bitfield, optional, the format is 
-- e.g. 1|2|4|8|16 etc., i.e. all 5 options are On by default, 
-- 1|4 - options 1 and 3 are On by defaullt,
-- 2|8|16 - options 2,4 and 5 are On by default
-- relies on Reload_Menu_at_Same_Pos2() function

::RELOAD::

local sett_t = sett_t or {'My setting 1', 'My setting 2', 'My setting 3'}
local menu_t = menu_t or {'Item 1|', 'Item 2|', sett_t[1]..'|',  sett_t[2]..'|', 'Item 3|', sett_t[3]..'|'}

local sett_indices_t = {}
	for menu_idx, item in ipairs(menu_t) do
		for sett_idx, sett in ipairs(sett_t) do
		if item:gsub('|','') == sett then
		sett_indices_t[menu_idx] = sett_idx -- store settings array index under menu index
		break end
		end
	end

local bitfield = r.GetExtState(scr_cmd_ID, 'SETTINGS')
bitfield = #bitfield > 0 and bitfield+0 or default_sett_state or 0

-- Extract set bits
local sett_bools_t = {}
	for k in ipairs(sett_t) do
	local bit = 2^(k-1)
	sett_bools_t[k] = bitfield&bit == bit
	end

	-- Checkmark enabled settings in the menu
	for sett_idx, truth in ipairs(sett_bools_t) do
		for menu_idx, v in pairs(sett_indices_t) do
			if v+0 == sett_idx then -- a setting index in the menu has been found
			local sett = menu_t[menu_idx]
			menu_t[menu_idx] = truth and '!'..sett or sett
			break end
		end
	end

local output = Reload_Menu_at_Same_Pos2(table.concat(menu_t), 1) -- keep_menu_open true
  
	if output == 0 then return
	elseif sett_indices_t[output] then -- toggle the setting
	local idx = sett_indices_t[output] -- extract index relevant for sett_t table
	sett_bools_t[idx] = not sett_bools_t[idx] -- flip because it's a toggle
	else -- expand with other menu items if necessary
	end
  
	if sett_indices_t[output] then -- this condition will likely need expansion to include indices of other menu items which aren't settings
	-- Store new bitfield
	local bitfield = 0
		for k, truth in ipairs(sett_bools_t) do
			if truth then
			bitfield = bitfield|2^(k-1)
			end
		end
	r.SetExtState(scr_cmd_ID, 'SETTINGS', bitfield, false) -- persist false
	goto RELOAD end
  
end



function Toggle_Option(option, data, output, scr_ID)
-- toggle in response to menu item click;
-- option arg is string, one of the options stored as extended state in 0 and 1 format;
-- data is string, stems from extended state extracted before loading the menu, i.e.
--[[ 
local data = r.GetExtState(scr_ID, 'OPTIONS')
local option1, option2, option3 = data:match('(%d)(%d)(%d)')
]]
-- output is integer, menu output;
-- scr_ID stems from get_action_context();
-- if option index in extended state doesn't match its index in the menu
-- output value will have to be adjusted accordingly
local option = option == '1' and '0' or '1'
local i = 0
local data = data:gsub('%d', function() i=i+1; if i==output then return option end end)
r.SetExtState(scr_ID, 'OPTIONS', data, false) -- persist false
end



function Create_Submenus_Dynamically(t, limit)
-- meant for creation of a menu with a limited number
-- of items in the main menu in order to fit within the screen height
-- and placing all items in excess inside submenus 
-- accessible from the main menu;
-- t is either a table with values to be displayed as menu items
-- or integer in which case numerals will be used as menu items;
-- limit is integer denoting main menu max item count,
-- if exceeded, for every next menu items count which equals the limit
-- a submenu is created;
-- the main menu is shortened by the number of submenus
-- to accommodate submenu items and prevent exceeding the limit
-- in the main menu itself;
-- if the limit is smaller than the submenu count, 
-- main_menu_cnt var will end up being negative
-- and submenus will be created from the very first menu item;
-- one extra submenu over submenu_count value could be added
-- to accommodate remaining outstanding menu items

local tab = type(t) == 'table'
local max_cnt = tab and #t or t
local int, frac = math.modf(max_cnt/limit)
-- count submenus
local submenu_count = int < 1 and 0 or int + (frac ~= 0 and 1 or 0) - 1 -- if there's fractional part count it as another submenu, because it exceeds the items count limit per submenu, subtract 1 to exclude the main menu items because these don't go into the submenu but this isn't mandatory
local main_menu_cnt = limit-submenu_count -- allocate as many items to the main menu as there're going to be submenus by shortening it by submenu count so that main menu's own item count doesn't exceed the limit when submenus are created // the var will be negative if the limit is smaller than the submenu count
local menu, count = '', 0
	for k = 1, max_cnt do
	local v = tab and t[k] or k
	count = k > main_menu_cnt and (count == limit and 1 or count+1) or 0 -- reset once the limit is reached to start next submenu, keeping at 0 while main menu is being concatenated, i.e. as long as main_menu_cnt hasn't been exceeded
	local opening = count == 1 and '>'..k..'-'..(max_cnt-k > limit and k+limit-1 or max_cnt)..'|' or ''
	local closure = count == limit and '<' or ''
	menu = menu..(#menu > 0 and '|' or '')..opening..closure..v
	end
return menu

end



function Options_State_Readout(...)
-- vararg is a list of option vars holding strings '1' or '0';
-- in place of irrelevant options false must passed instead of nil
-- so that ipairs loop below doesn't break;
-- meant to display in the main menu
-- the state of options hidden in a submenu
local result
	for k, opt in ipairs({...}) do
	result = (result or '')
	..(not opt and '' or opt == '1' and string.char(226,157,181+k)..' ' or string.char(226,145,159+k)..' ') -- Dingbat Negative Circled Digit X OR Circled Digit X, starting from 1, 226,157,182 or 226,145,160 respectively
	-- OR
	-- ..(not opt and '' or opt == '1' and string.char(0xE2,0x9D,B5+k)..' ' or string.char(0xE2,0x91,0x9F+k)..' ')
	end
return result
end



function ShowMessageBox_Menu(message_lines, buttons_t, title)
-- message_lines is a multi-line literal string
-- a line per menu item, empty lines are supported
-- buttons_t is a table of button captions
-- title is the dialogue title to be displayed at the very top
-- if invalid 'PROMPT' title is used
-- relies on Reload_Menu_at_Same_Pos2() function

	local function center_text(t, max_len)
		for k, line in ipairs(t) do
		local line_len = #line:gsub('[\128-\191]','')
	--	local diff = (max_len-line_len)/4
	--	diff = math.floor(diff*3+0.5) -- figured out empirically, 3/4 or 4/5 of the difference give the best result with English though not ideal, for Russian 5/6 // ideally pixels must be counted rather than characters
	-- OR simply
		local diff = math.floor((max_len-line_len) * 4/5 + 0.5)
		t[k] = (' '):rep(diff)..line -- add leading spaces to center the line // may not be accurate if lines text is in different register
		end
	return t
	end

local message_lines = message_lines or [[
Lorem ipsum dolor sit amet, consectetur
adipiscing elit, sed do eiusmod tempor incididunt ut
labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut
aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat
nulla pariatur. Excepteur sint occaecat cupidatat
non proident, sunt in culpa qui officia deserunt
mollit anim id est laborum.
]]

message_lines = not message_lines:sub(-1):match('\n') and message_lines..'\n' or message_lines -- OR message_lines:sub(-1) ~= '\n' etc. -- ensures that the last line is captured with gmatch search
local buttons_t = buttons_t or {'Button 1', 'Button 2', 'Button 3'}

local message_t, max_len = {}, 0

	for line in message_lines:gmatch('(.-)\n') do -- accounting for empty lines if any
		if line then
		line = line:match('(%S.-)%s*$') or line -- trimming both leading and trailing spaces if any, leading spaces will be added for centering inside center_text()
		local line_len = #line:gsub('[\128-\191]','') -- removing continuation (trailing) bytes
		max_len = math.max(line_len, max_len)
		message_t[#message_t+1] = line..'|'
		end
	end
	
-- Center the message
message_t = center_text(message_t, max_len)
buttons_t = center_text(buttons_t, max_len)

local title = title or ('PROMPT'):gsub('.','%0    ')
-- title = (' '):rep(math.floor((max_len-#title)/2+#title/2+0.5))..title 
-- OR better yet ('  '):rep(math.floor((max_len-#title)/2+0.5))..title -- center the title, works for spaced out 'PROMPT', same can be done with the button captions
local menu = title..'||'..table.concat(message_t)..'||'..table.concat(buttons_t,'|')

::RELOAD::
local output = Reload_Menu_at_Same_Pos(menu, 1) -- keep_menu_open is true

	if output == 0 then return
	elseif output > #message_t+1 then -- a button was pressed, +1 to account for the title
	return output-#message_t-1 -- return button index, -1 to account for the title
	elseif output <= #message_t+1 then -- if message menu item was clicked, +1 to account for the title
	goto RELOAD
	end

end
-- USE:
-- local user_choice = ShowMessageBox_Menu()



function Re_Store_Ext_State(section, key, persist, val) 
-- section & key args are strings, 
-- persist is boolean, if false/nil global ext state 
-- is only stored for the duration of REAPER session, 
-- only relevant for storage stage; 
-- presence of val arg is anything which needs storage, 
-- determines whether the state is loaded or stored
	if not val then -- load
	local ret, state = r.GetProjExtState(0, section, key)
	local state = (ret == 0 or #state == 0) and r.GetExtState(section, key) or state
	return state
	else -- store
	r.SetExtState(section, key, val, persist)
	r.SetProjExtState(0, section, key, val)
	end
end

-- USAGE:
-- local state = Re_Store_Ext_State(section, key) -- load
-- Re_Store_Ext_State(section, key, persist, val) -- store




local function Wrapper1(func,...) -- see Wrapper_multi_function() below
-- r.atexit() CAN BE USED WITHOUT THE WRAPPER FUNCTION AS FOLLOWS
-- r.atexit(function() my_function(arg1, arg2, arg3) end)
-- ARGUMENTS DON'T HAVE TO BE GLOBAL 
-- AND UPVALUE NAMES DON'T HAVE TO MATCH THE ARGUMENTS

-- wrapper for a 3d function with arguments
-- to be used with defer() and atexit()
-- thanks to Lokasenna, https://forums.cockos.com/showthread.php?t=218805 -- defer with args
-- func is function name, the elipsis represents the list of function arguments
-- Lokasenna's code didn't work because func(...) produced an error
-- " cannot use '...' outside a vararg function near '...' "
-- without there being elipsis in function() as well, but gave direction;
-- if original function has arguments they MUST be passed to the Wrapper() function
-- regardless of their scope (global or local);
-- if it doesn't, the upvalues must all be global and it doesn't matter
-- whether they're passed to the Wrapper() function
local t = {...}
return function() func(table.unpack(t)) end
end
-- USE:
--[[
function MY_FUNCTION(arg1, arg2)
r.defer(Wrapper(MY_FUNCTION, arg1, arg2))
end
MY_FUNCTION(arg1, arg2)

function My_Function(arg1, arg2, arg3) -- some routine -- end
r.atexit(Wrapper(My_Function, arg1, arg2, arg3)
]]



local function Wrapper2(...) -- more wordy, see Wrapper_multi_function() below
-- r.atexit() CAN BE USED WITHOUT THE WRAPPER FUNCTION AS FOLLOWS
-- r.atexit(function() my_function(arg1, arg2, arg3) end) 
-- ARGUMENTS DON'T HAVE TO BE GLOBAL 
-- AND UPVALUE NAMES DON'T HAVE TO MATCH THE ARGUMENTS

-- to be used with defer() and atexit()
-- https://forums.cockos.com/showthread.php?t=218805 Lokasenna
local t = {...}
local func = t[1] -- assign function name val
table.remove(t,1) -- remove function name arg
return function() func(table.unpack(t)) end
end



function Wrapper_multi_function(...)
-- r.atexit() CAN BE USED WITHOUT THE WRAPPER FUNCTION AS FOLLOWS
-- r.atexit(function() my_function1(arg1, arg2, arg3) my_function2(arg1, arg2, arg3) end) 
-- ARGUMENTS DON'T HAVE TO BE GLOBAL 
-- AND UPVALUE NAMES DON'T HAVE TO MATCH THE ARGUMENTS

-- the vararg syntax is as follows:
-- {func1, arg1, arg2, arg3}, {func2, arg1, arg2, arg3} etc.
local macro = {}
	for _, t in ipairs({...}) do
	local func = t[1]
	macro[func] = {table.unpack(t, 2)}
	end
return
	function()
		for func, args in pairs(macro) do
		func(table.unpack(args))
		end
	end
end
-- USE:
-- r.atexit(Wrapper_multi_function({func1, arg1, arg2, arg3}, {func2, arg1, arg2, arg3})) etc.




--------------------- T O G G L E S -------------------------

-- (re)setting toggle state and updating toolbar button, see also Re_Set_Toggle_State() below
local _, scr_name, sect_ID, cmd_ID, _,_,_ = r.get_action_context()

r.SetToggleCommandState(sect_ID, cmd_ID, 1)
r.RefreshToolbar(cmd_ID)

-- CODE (mainly for defer functions)

r.atexit(function() r.SetToggleCommandState(sect_ID, cmd_ID, 0); r.RefreshToolbar(cmd_ID) end)


function EMERGENCY_TOGGLE()
local t = {reaper.get_action_context()}
reaper.SetToggleCommandState(t[3], t[4], 0)
end
---------------- EMERGENCY -------------------

-- EMERGENCY_TOGGLE() do return end

---------------------------------------------


local _, scr_name, sect_ID, cmd_ID, _,_,_ = r.get_action_context()
function Re_Set_Toggle_State(sect_ID, cmd_ID, toggle_state) -- in deferred scripts can be used to set the toggle state on start and then with r.atexit and At_Exit_Wrapper() to reset it on script termination
r.SetToggleCommandState(sect_ID, cmd_ID, toggle_state)
r.RefreshToolbar(cmd_ID)
end
-- USAGE:
-- Re_Set_Toggle_State(sect_ID, cmd_ID, 1)
-- defer routine
-- r.atexit(At_Exit_Wrapper(Re_Set_Toggle_State, sect_ID, cmd_ID, 0))
-- OR
-- r.atexit(function() r.SetToggleCommandState(sect_ID, cmd_ID, 0); r.RefreshToolbar(cmd_ID) end)

-- TOGGLE MODE AND ARMABILITY ARE NOT COMPATIBLE



function Get_Option_Script_Toggle_State(sectionID, scr_name)
-- option script is an ancillary script on whose toggle state
-- relies functionality of another script, much like REAPER
-- native toggle option actions,
-- this mechanism can be used instead of internal script setting,
-- the drawback is that its toggle state isn't restored at
-- REAPER starup unless the script is explicitly run at startup,
-- so the main use is inside custom actions to modify the main
-- script behavior on demand, setting the desired toggle state 
-- during custom action execution with the sequence:
--[[
Action: Skip next action, set CC parameter to relative +1 if action toggle state enabled, -1 if disabled, 0 if toggle state unavailable.
<OPTION SCRIPT>
Action: Skip next action if CC parameter >0/mid  // if toggle state is OFF, set to ON
<OPTION SCRIPT>
<MAIN SCRIPT>
Action: Skip next action if CC parameter >0/mid // restore original toggle state if it was OFF
<OPTION SCRIPT>
]]
-- section ID is integer ID of Action list section
-- the option script toggle state must be looked in
-- although probably unnecessary because script command ID
-- includes section ID;
-- relies on Esc() function

local path = r.GetResourcePath()
local sep = path:match('[\\/]')
local scr_cmdID, scr_path
	for line in io.lines(path..sep..'reaper-kb.ini') do
		if line:match('SCR') and line:match(Esc(scr_name)) then
		scr_cmdID, scr_path = line:match('SCR %d+ %d+ (%S*) ".-" "?(.+%a)') -- or "?([^"]+)
		break end
	end

scr_path = scr_path and (scr_path:match('^%u:'..sep) and scr_path -- absolute path, script is outside of the Scripts folder
or path..sep..'Scripts'..sep..scr_path) -- script is inside of the Scripts folder

	if scr_path then -- validate script path
	local f = io.open(scr_path, 'r')
		if not f then return end
	f:close()
	end

local numeric_ID = r.NamedCommandLookup('_'..scr_cmdID)
return (sectionID and r.GetToggleCommandStateEx(sectionID, numeric_ID) or r.GetToggleCommandState(numeric_ID)) == 1

end



--------------------- T O G G L E S  E N D -------------------------

-- STORE DEFERRED SCRIPT DATA -----------------------------------------------------------
function defer_store()
local is_new_value, fullpath, sectionID, cmdID, mode, resolution, val = reaper.get_action_context()
-- Find first available slot
local i = 1
	repeat
	local state = r.GetExtState(os.date('%x'), 'defer'..i)
		if #state == 0 then break end
	i = i+1
	until #state == 0
r.SetExtState(os.date('%x'), 'defer'..i, table.concat({sectionID, cmdID, fullpath:match('.+[\\/](.+)'), fullpath}, ';'), false)
return i
end

local defer_data_slot = defer_store()

-- EXTRACT STORED DEFERRED SCTIPT DATA
local i = 1
	repeat
	local sectionID, cmdID, name, fullpath = r.GetExtState(os.date('%x'), 'defer'..i):match('(.+);(.+);(.+);(.+)')
		if not sectionID then break end
	i = i+1
	until not sectionID

-- DELETE STORED DEFERRED SCRIPT DATA
r.atexit(r.DeleteExtState(os.date('%x'), 'defer'..defer_data_slot, true))

--------------------------------------------------------------------------------------------------


function Count_Proj_Tabs()
local i = 0
	repeat
	local retval, projfn = r.EnumProjects(i)
	i = retval and i+1 or i
	until not retval
return i
end


function Open_Close_Temp_Proj_Tab_Without_Save_Prompt1()
-- relies on Get_Or_Create_Dummy_Project_File() if current tab isn't linked to a saved project
local cur_proj, projfn = r.EnumProjects(-1) -- store cur project pointer; returns empty string if project doesn't have a file and returns path even if the project file and possibly folder was deleted while the project is open
r.Main_OnCommand(41929, 0) -- New project tab (ignore default template) // open new proj tab
-- DO STUFF
local dummy_proj = Get_Or_Create_Dummy_Project_File()
r.Main_openProject('noprompt:'..dummy_proj) -- open dummy proj in the newly open tab without save prompt // THIS CHANGES CURRENT WORKING DIRECTORY, SO NEXT TIME THE OPEN PROJECT DIALOGUE WILL POINT TO THE DUMMY PROJ FILE DIRECTORY
r.Main_OnCommand(40860, 0) -- Close current (temp) project tab // save prompt won't appear because nothing has changed in the dummy proj
--	if dummy_proj then os.remove(dummy_proj) end -- NOT ADVISED IF THE DUMMY PROJECT FILE IS TO BE REUSED TO ENSURE THAN THE RECENT PROJECTS LIST ISN'T OVERFLOWN WITH NEW PATHS
r.SelectProjectInstance(cur_proj) -- re-open orig proj tab
end


function Open_Close_Temp_Proj_Tab_Without_Save_Prompt2()
-- relies on Get_Or_Create_Dummy_Project_File() if no valid project file to load was found
-- Close temp project tab without save prompt; when a freshly opened project closes there's no prompt
local cur_proj, projfn = r.EnumProjects(-1) -- store cur project pointer; returns empty string if project doesn't have a file and returns path even if the project file and possibly folder was deleted while the project is open
	if #projfn == 0 then -- current tab isn't linked to saved project file, look elsewhere
	local i = 0
		repeat
		cur_proj, fn = r.EnumProjects(i)
			if #fn > 0 then projfn = fn end -- get path associated with the most recently opened proj tab, normally the righmost, so loop runs until the end because the count is from left to right
		i=i+1
		until not cur_proj
		if #projfn == 0 then -- if still not found in the open tabs, look for recently opened
		local recent
			for line in io.lines(r.get_ini_file()) do
				if line:match('%[Recent%]') then recent = 1 -- section start
				elseif recent then
				-- file_exists() returns true if passed a file name only and a file with the same name
				-- is found in the current working directory, which is a bug https://forum.cockos.com/showthread.php?t=300386
				-- so must be additionaly validated
					if not line:match('^recent%d+=') then break -- section end
					elseif line:match('^recent%d+=(.+)'):match('[\\/]') -- validate proper path due to the bug mentioned above to ensure it's not just a bare file name without a path which can happen if r.Main_SaveProjectEx() was ever used with file name only and flag 8
					and r.file_exists(line:match('^recent%d+=(.+)'))
					then
					projfn = line:match('^recent%d+=(.+)') break
					end
				end
			end		
		end
		if #projfn == 0 then -- still not found in recently opened, use dummy
		projfn = Get_Or_Create_Dummy_Project_File()
		end
	end
r.Main_OnCommand(41929, 0) -- New project tab (ignore default template) // open new proj tab
-- DO STUFF
r.Main_openProject('noprompt:'..projfn) -- open the stored project in the temp tab // this updates the current working directory so next time the open project dialogue will point to the directory of last loaded file be it another project or dummy project
r.Main_OnCommand(40860, 0) -- Close current project tab // won't generate a save prompt
r.SelectProjectInstance(cur_proj) -- re-open orig proj tab
end


function Open_Close_Temp_Proj_Tab_Without_Save_Prompt3(path)
-- creates temp project file, uses it, then deletes it
-- THE TEMP FILE IS ADDED TO RECENT PROJECTS MENU
-- provided the preference at 
-- Prefs -> General -> Recent projects list display button -> Add to recent list when loading project is enabled (and it's enabled by default)
-- SO WITH FREQUENT USE THE MENU WILL BE INUNDATED WITH TEMP FILES
-- BECAUSE THEY ALL WILL BE UNIQUE, SO MUCH CLEANER IS TO USE
-- THE SAME SPECIFIC DUMMY FILE IN EACH FUNCTION CALL
-- for consistency's sake path is the path of the last loaded/saved template 
-- stemming from the extended state
-- if not stored yet, use REAPER own last/current working directory
local path = path or select(2, r.get_config_var_string('lastcwd'))
local sep = path:match('[\\/]')
	if #path > 0 then
	path = path..(path:sub(1,-2) == sep and '' or sep)..tostring(r.time_precise())..'.RPP' -- using time precise since the odds of it being a unique name are pretty high
	local f = io.open(path,'w')
	f:write('<REAPER_PROJECT\n>')
	f:close()
		if r.file_exists(path) then
		r.Main_openProject('noprompt:'..path) -- open suppressing prompt to save currently unsaved project // THIS CHANGES CURRENT WORKING DIRECTORY UNLESS IT'S USED FOR THE TEMP PROJ FILE CREATION, SO NEXT TIME THE DIALOGUE WILL POINT TO THE TEMP PROJ FILE DIRECTORY
		r.Main_OnCommand(40860, 0) -- Close current project tab
		os.remove(path)
		end
	end
end


function Validate_Proj_Tab(target_proj)
-- same as r.ValidatePtr(target_proj, 'ReaProject*')
	if not target_proj then
	return r.EnumProjects(-1)
	else
	local i = 0
		repeat
		local proj = r.EnumProjects(-1)
			if proj == target_proj then return true end
		until not proj
	end
end
-- USE:
-- local proj = Validate_Proj_Tab()
-- local vald = Validate_Proj_Tab(proj)



function Is_Win()
local OS = r.GetAppVersion()
return not OS:match('/') or OS:match('/x')
end


function Get_OS()
local OS = r.GetAppVersion()
return (not OS:match('/') or OS:match('/x')) and 'win'
or OS:match('OS') and 'mac' or OS:match('linux')
-- OR
-- local OS = r.GetOS()
-- return OS:match('Win') or OS:match('OSX') and 'Mac' or 'Other'
end



function All_Proj_Change_Cnt() -- get proj change count accounting for all open projects // hardly necessary as changes are only registered in the active one
local i = 0
local count = 0
	repeat
	local retval, projfn = r.EnumProjects(i)
	count = retval and count + r.GetProjectStateChangeCount(retval) or count
	i = i+1
	until not retval
return count
end


function Bump_Proj_Change_Cnt() -- API functions seems to not update project change count, most of them anyway
r.Main_OnCommand(41156,0) -- Options: Selecting one grouped item selects group
r.Main_OnCommand(41156,0)
end



function PAUSE()
do r.MB('PAUSE','PAUSE',0) return end
end

do r.MB('PAUSE','PAUSE',0) return end



function EvaluateTAG(fx_name,TAG)
-- in FX/track/item/take/marker/region names
return fx_name:match('^('..Esc(TAG)..')%s')
or fx_name:match('%s('..Esc(TAG)..')%s')
or fx_name:match('%s('..Esc(TAG)..')$')
or fx_name:match('^%s*'..Esc(TAG)..'%s*$') -- when the TAG is the whole name
end
TAG = TAG:match('[%w%p].+[%w%p]') or TAG:match('[%w%p]+') -- strip leading/trailing spaces, account for single character



function is_tbl_or_ptr_or_fnc(obj)
-- same as type(obj) == 'table', type(obj) == 'userdata', type(obj) == 'function'
local obj = tostring(obj)
return obj:match('table: %w+'), obj:match('userdata: %w+'), obj:match('function: %w+')
end


-- complements GetUserInputs_Alt() below in cases where dialogue fields
-- may contain characters requiring balancing
function resolve_all_or_restore_apostrophe(fields_t, sep, resolve)
-- fields_t is table of fields content returned by GetUserInputs_Alt() as 1st return value
-- if sep arg isn't supplied, default to comma
-- the function is meant to balance unbalanced perenthesis '(' or ')', quotation marks " and apostrophe '
-- before content is fed back into GetUserInputs_Alt() on dialogue reload because lack of parenthesis balance
-- or odd number of quotation marks and apostrophe breaks fields separation
-- https://forum.cockos.com/showthread.php?t=288046
-- {}, [], <> don't cause this problem
-- the function is to be run after GetUserInputs_Alt() in resolve mode
-- to balance any unbalanced characters and store the returned result as extended state
-- so that it can be fed back into the dialogue reliably later on
-- then followed by another instance of the function in restore mode
-- to restore balanced apostrophe instances to their original form in order to accurately
-- find and replace content in the target text
-- unbalanced quotation marks and parentheses after resolution trigger a warning message
-- and reloading of the dialogue to allow the user to resolve the unbalanced characters
-- as they see fit

	if resolve then
	local sep, unbalanced_char_data = sep or ',', ''
		for field_idx, field in ipairs(fields_t) do
			if field_idx < #fields_t and #field > 0 then -- unbalanced characters in the last field don't break the dialogue so it can be excluded
				for k, char in ipairs({'"',"'"}) do
				local unbalanced_char = select(2, field:gsub(char,''))%2 > 0 -- if quote char or apostrophe count is odd, they're unbalanced
					if unbalanced_char then
						if field_idx > 2 then -- !!! SCRIPT SPECIFIC, CHANGE DEPENDING ON THE ACTUAL DIALOGUE CONFIG specifying indices of fields where aplhabetic content is meaningless and where unbalanced characters can be replaced with + or any other safe character
						field = '+'
						else
						local pt1, pt2 = field:match("(.*"..char..")(.*)") -- isolate pt1 up to the last (odd) char
						field = pt1..char..pt2 -- balance the last char
							if char == '"' then
							unbalanced_char_data = unbalanced_char_data..'Field: '..math.floor(field_idx)..'\tCharacter: '..char..'\n'
							end
						end
					end
				end
			-- determine which parenthesis instances are fewer and make up for the deficit
			-- to balance out the oppotite parenthesis instances
			local open_parenth_cnt = select(2, field:gsub('%(',''))
			local clsd_parenth_cnt = select(2, field:gsub('%)',''))
			local minim = math.min(open_parenth_cnt, clsd_parenth_cnt)
			local maxim = math.max(open_parenth_cnt, clsd_parenth_cnt)
			local parenth = open_parenth_cnt ~= clsd_parenth_cnt and (minim == open_parenth_cnt and '(' or ')') -- determine type if parenthesis to be added
				if parenth then -- will be false if open_parenth_cnt and clsd_parenth_cnt are equal, i.e. all instances are balanced
					if field_idx > 2 then -- in this script fields at indices greater than 2 are boolean therefore there's no point in balancing their characters, it's enough to replace them with one which doesn't require balancing
					field = '+'
					else
				--	local src_parenth = parenth:byte() == 40 and ')' or '(' -- 40 is ASCII code for left parenthesis, 41 is for right, determine the source parenthesis to be complemented with replacement parenthesis // TOO VERBOSE
					local src_parenth = parenth == '(' and ')' or '(' -- determine the source parenthesis to be complemented with balancing parenthesis, all instances of the balancing parenthesis are appended to the first instance of the opposite parenthesis
					field = field..' '..parenth:rep(maxim-minim) -- escaping parenth at the string end
					unbalanced_char_data = unbalanced_char_data..'Field: '..math.floor(field_idx)..'\tCharacter: '..src_parenth..'\n'
					end
				end
			end
		fields_t[field_idx] = field
		end
		if #unbalanced_char_data > 0 then
		r.MB('Please resolve unbalanced characters in:\n\n'..unbalanced_char_data:sub(1,-2)..'\n\nThey have been balanced for the settings\nto be properly displayed in the reloaded dialogue.\n\nBut if you leave them as they are, that\'s how\nthe terms will be searched for and/or appear\nafter replacement in the transcript.', 'WARNING',0) -- stripping trailing new line character from unbalanced_char_data
		end
	return fields_t, unbalanced_char_data -- unbalanced_char_data return value will be used to condition reloading of the dialogue by setting off the 'goto' loop
	else -- restore apostrophe
		for k, field in ipairs(fields_t) do
		fields_t[k] = field:gsub("'''*","'") -- replace all instances of muliple apostrophes with a single one
		end
	return fields_t
	end
end




function GetUserInputs_Alt(title, field_cnt, field_names, field_cont, separator, comment_field, comment, empty_comm_fields)
-- title string, field_cnt integer which can be smaller or greater 
-- than the number of fields in field_names arg, in which case fields will
-- be subtracted, or added but without names, if 0 <= field_cnt 
-- then field_cnt will be derived from field_names arg 
-- and if field_names is empty but comment_field is enabled
-- field_cnt will default to 1 to add one field besides the comment field(s),
-- otherwise the dialogue won't load because field count 0 disables it in the native function
-- while negative value generates a blank window with buttons, which is prevented here,
-- field_cnt doesn't account for the comment field,
-- if final field count exceeds the total limit of 16, 
-- it gets clamped to 16 and disables the comment if enabled,
-- if fields count isn't constant because their appearance is conditional
-- it may prove more relialbe to calculate the field_cnt value in the code 
-- outside of the function because extra separators which separate fields
-- whose appearance condition isn't met will affect the internal
-- calculation;
-- field_names is table or string comma delimited
-- OR separator delimited IF commas must be used in field names, 
-- because 'separator=' setting applies to field name separation as well, 
-- OR empty string,
-- it's safer to use \n or \r or \t or any other control char as a separator
-- to ensure that the separator has no chance of clashing with the user content
-- because literal control characters input by the user won't be recognized as such,
-- in this case however such characters must be excluded from the user content
-- to prevent them from being recognized as control chars when the content
-- is processed internally;
-- unbalanced quotes, apostrophes and parenthesis break field separation
-- SEE ALSO resolve_all_or_restore_apostrophe() above;
-- the length of field names list should obviously match field_cnt arg
-- it's more reliable to contruct a table of names 
-- and pass the two vars field_cnt and field_names as #t, t
-- field_cont is empty string or nil unless they must be initially filled,
-- to fill out only specific fields precede them with as many separator characters
-- as the number of fields which must stay empty
-- in which case it's a separator delimited list e.g.
-- ,,field 3,,field 5,
-- if some/all fields must initially be filled out field_cont may be a table;
-- separator is a string, character which delimits the fields,
-- if invalid / empty string, defaults to comma
-- the function relies on Esc() function if separator character needs escaping,
-- MULTIPLE CHARACTERS CANNOT BE USED AS FIELD SEPARATOR 
-- BECAUSE FIELD NAMES LIST OR ITS FORMATTING BREAKS,
-- Lua string library magic characters are NOT recommended as separators
-- because if these characters also present in the text fields
-- captures won't work accurately, \n, \r and \t are the safest because 
-- they're not confused with their literal look-alikes;
-- comment_field is boolean, comment is string to be displayed in the comment field(s),
-- if comment_field is true but comment arg is an empty string 
-- or only contains separators, comment_field arg is ignored 
-- and no comment field(s) is displayed, UNLESS empty_comm_fields arg is true,
-- multiple comments must be delimited by the character used as the separator arg
-- or by comma if separator is the comma,
-- if comment text contains commas, separator arg must be set specifically 
-- to be anything but comma, 
-- if final field count with comment fields hits or exceeds the limit of 16, 
-- comment fields number is reduced, text of any extra comment fields is merged 
-- into the last visible comment field if any remains;
-- empty_comm_fields arg is boolean, allows having empty comment fields
-- if their intended use is other than comment;
-- extrawidth parameter is to be set diectly inside the function code;

	if (not field_cnt or field_cnt <= 0) then -- if field_cnt arg is invalid, derive count from field_names arg
		if #field_names:gsub(' ','') == 0 and not comment_field then return end
	field_cnt = select(2, field_names:gsub(',',''))+1 -- +1 because last field name isn't followed by a comma and one comma less was captured
	--	if field_cnt-1 == 0 and not comment_field then return end -- SAME AS THE ABOVE CONDITION
	end
	
	if field_cnt >= 16 then
	field_cnt = 16 -- clamp to the limit supported by the native function
	comment_field = nil -- disable comment if field count hit the limit, just in case 
	end

	local function add_separators(field_cnt, arg, sep)
	-- for field_names and field_cont as arg
	-- add delimiting separators when they're fewer than field_cnt
	-- due to lacking field names or field content
	-- which means they will delimit trailing empty fields
	local sep_esc = Esc(sep)
	local _, sep_cnt = arg:gsub(sep_esc,'')
	return sep_cnt == field_cnt-1 and arg -- -1 because the last field isn't followed by a separator
	or sep_cnt < field_cnt-1 and arg..(sep):rep(field_cnt-1-sep_cnt) -- add trailing separators
	or arg:match(('.-'..sep_esc):rep(field_cnt)):sub(1,-2) -- truncate arg when field_cnt value is smaller than the number of fields, excluding the last separator captured with the pattern inside string.match because the last field isn't followed by a separator
	end

	local function format_fields(arg, sep, field_cnt, trim_leading_space)
	-- for field_names and field_cont as arg
	local sep_esc = Esc(sep)
	local arg = type(arg) == 'table' and table.concat(arg, sep) or arg
	local formatted = add_separators(field_cnt, arg, sep)
	return not trim_leading_space and formatted or formatted:gsub(sep_esc..' ', sep) -- if there's space after labels separator, remove because with multiple fields the field names will not line up vertically
	end

-- for field names sep must be a comma because that's what field names list is delimited by
-- regardless of internal 'separator=' argument
-- but if comma must be used in field names, they must be delimited
-- by the main separator
local field_names = format_fields(field_names, ',', field_cnt, 1) -- trim_leading_space true // if commas need to be used in field names and the main separator is not a comma (because if it is comma cannot delimit field names), pass here the separator arg from the function
local sep = separator and #separator > 0 and separator or ','
local sep_esc = Esc(sep)
local field_cont = field_cont or ''
field_cont = format_fields(field_cont, sep, field_cnt, 1) -- trim_leading_space true, but may need to be false, depending on the field content and script design
local sep_cnt = comment and select(2,comment:gsub(sep_esc,''))
local comment_field = comment_field and type(comment) == 'string' and (#comment ~= sep_cnt or empty_comm_fields)
local comment = comment_field and comment or ''
local comment_field_cnt = select(2, comment:gsub(sep_esc,''))+1 -- +1 because last comment field isn't followed by the separator so one less will be captured
local field_cnt = comment_field and field_cnt+comment_field_cnt or field_cnt

	if field_cnt >= 16 then 
	-- disable some or all comment fields if field count hit the limit after comment fields have been added	
	comment_field_cnt = field_cnt - 16
	field_cnt = 16
	end

field_names = comment_field and field_names..(',Scratch field:'):rep(comment_field_cnt) or field_names
field_cont = comment_field and field_cont..sep..comment or field_cont
local separator = sep ~= ',' and ',separator='..sep or '' -- if commas need to be used in field names, these must be delimited by the main separator which also should be used here
local ret, output = r.GetUserInputs(title, field_cnt, field_names..',extrawidth=300'..separator, field_cont) -- same as above regarding delimiter
local comment_pattern = (sep_esc..'.*'):rep(comment_field_cnt)
comment = comment_field and output:match('.*('..comment_pattern..')') -- captured with leading separator which separates comment(s) from the main fields
output = comment_field and output:match('(.*)'..comment_pattern) or output -- strip comment fields content // * operator accommodates single empty field // output capture doesn't include trailing separator
field_cnt = comment_field and field_cnt-comment_field_cnt or field_cnt -- adjust for the next statement
	
	if not ret	
	--[[
	-- this condition will need commenting out if empty dialogue
	-- sumbission is allowed by script design, mainly if there're multiple fields in the dialogue	
	or (not comment_field and output or output:gsub('[%s%c]','') == (sep):rep(field_cnt-1)) -- if there're comment fields, exclude trailing separator left behind after stripping comment fields content above // * operator accommodates single empty field // -1 because the last field doesn't end with a separator	
	--]]
	then return end
	--[[ OR
	-- to condition action by the type of the button pressed
	-- which will be assigned to the first return value that's supposed to be output_t
	if not ret then return 'cancel'
	elseif not comment_field and output or output:gsub('[%s%c]','') == (sep):rep(field_cnt-1) -- if there're comment fields, exclude trailing separator left behind after stripping comment fields content above // * operator accommodates single empty field // -1 because the last field doesn't end with a separator
	then return 'empty' end
	--]]

-- construct table out of input fields, empty fields and fields only filled with spaces are permitted
-- must be validated after values return
local t = {}
output = output..sep -- add trailing separator to be able to capture last field in the dialogue or last before comment field(s) because it doesn't end with a separator
	for s in output:gmatch('(.-)'..sep_esc) do
		if s then t[#t+1] = s end
	end

-- return fields content in a table and as a string to refill the dialogue on reload
return t, output:match('(.*)'..sep_esc), comment and comment:match(sep_esc..'(.*)') -- remove hanging separator from output return value to simplify re-filling the dialogue in case of reload, when there's a comment field the separator will be added with it, comment isn't included in the returned output // * operator accommodates single empty field // comment is returned without leading separator to be collected and fed back into the dialogue if it's generated dynamically and needs preserving when the dialogue is reloaded

end
-- USE:
-- local output_t, output = GetUserInputs_Alt(...)
--	if not output_t then return r.defer(no_undo) end -- aborted by the user or submitted empty
--[[ validate fields
	for k, sett in ipairs(output_t) do
	output_t[k] = validate_sett(sett) and sett -- function from  U T I L I T Y section of this document
	end
]]

--[[ EXAMPLE OF USE WITH resolve_all_or_restore_apostrophe()

::CONTINUE::
local stored_content = r.GetExtState(section, key)
local output_t = GetUserInputs_Alt(..., stored_content)
output_t, unbalanced_char_data = resolve_all_or_restore_apostrophe(output_t, sep, 1) -- resolve true // resolve any unbalanced characters input by the user
r.SetExtState(section, key, table.concat(output_t, sep), false) -- persist false // keep latest search settings during REAPER session to autofill the search dialogue when it's opened

	if #unbalanced_char_data > 0 then
	goto CONTINUE
	end

output_t = resolve_all_or_restore_apostrophe(output_t, sep) -- resolve nil, restore instances of resolved apostrophe to a single apostrophe in each occurrence

-- PROCEED TO PROCESS DIALOGUE FIELDS CONTENT

]]



function Get_Type_Of_Action(str) -- str stems from reaper-kb.ini
local native = str ~= '0' and tonumber(str)
local script = str:match('_?RS') and (#str == 43 or #str == 42)
local cust_act = str:match('^_?[%l%d]+$') and (#str == 33 or #str == 32)
local sws_act = str:match('^_?[%u%p%d]+$')
return native, cust_act, sws_act, script
end



function Get_Armed_Action(path, sep)
-- relies on Esc() function
-- for full functionality requires build 6.71+ or SWS extension

	-- only run the function if Action list window is open to force deliberate use 
	-- and prevent accidents in case some action is already armed for other purposes
	if r.GetToggleCommandStateEx(0,40605) == 0 then -- Show action list
	Error_Tooltip('\n\n the action list is closed \n\n', 1, 1) -- caps, spaced true
	return end

	local function script_exists(line, name)
	-- how paths external to \Scripts folder may look on MacOS
	-- https://github.com/Buy-One/Samelot_Reaper
	local f_path = line:match(Esc(name)..' "(.+)"$') or line:match(Esc(name)..' (.+)$') -- path either with or without spaces, in the former case it's enclosed within quotation marks
	local f_path = f_path:match('^%u:') and f_path or path..sep..'Scripts'..sep..f_path -- full (starts with the drive letter and a colon) or relative file path; in reaper-kb.ini full path is stored when the script resides outside of the 'Scripts' folder of the REAPER instance being used // NOT SURE THE FULL PATH SYNTAX IS VALID ON OSs OTHER THAN WIN
	return r.file_exists(f_path)
	end
	
	local function space(length)
	return (' '):rep(length)
	end
	
local sect_t = {['']=0,['alt']=0,['MIDI Editor']=32060,['MIDI Event List Editor']=32061,
['MIDI Inline Editor']=32062,['Media Explorer']=32063}

local path = path or r.GetResourcePath()
local sep = sep or path:match('[\\/]')

	if r.GetToggleCommandStateEx(0,40605) == 1 then -- Show action list // only if Action list window is open to force deliberate use of action notes and prevent accidents in case some action is already armed for other purposes --- THIS CONDITION IS REDUNDANT IF 'the action list is closed' ERROR IS RETURNED ABOVE
	 
	local cmd, section = r.GetArmedCommand() -- cmd is 0 when no armed action, empty string section is 'Main' section
	r.ArmCommand(0, section) -- 0 unarm all
		if cmd > 0 then
		local named_cmd = r.ReverseNamedCommandLookup(cmd) -- if the cmd belongs to a native action or is 0 the return value is nil
		local name, scr_exists, mess = false, true -- mess is nil // scr_exists is true by default to accomodate actions which can't be removed, if removed, such as custom actions, they can't be armed since they're removed directly from reaper-kb.ini unlike scripts which are only referenced there and appear in the Action list even after having been removed from their original location
			if cmd > 0 and not named_cmd and not r.kbd_getTextFromCmd and not r.CF_GetCommandText then -- native action is armed; without kbd_getTextFromCmd() which was added in build 6.71 and CF_GetCommandText() there's no way to retrieve native action name, only script and custom action names via reaper-kb.ini; without the sws extension cycle actions aren't available
		--	Error_Tooltip('\n\n'..space(6)..'since the sws extension \n\n'..space(11)..'is not installed \n\n only non-cycle custom actions \n\n'..space(4)..'and scripts are supported \n\n')
		--	return
			mess = space(4)..'Since REAPER build is older \n\n than 6.71 and the sws extension \n\n'..space(13)..'is not installed \n\n  only non-cycle custom actions \n\n'..space(6)..'and scripts are supported'
			elseif named_cmd and not r.kbd_getTextFromCmd and not r.CF_GetCommandText then -- without kbd_getTextFromCmd() which was added in build 6.71 and CF_GetCommandText() there's no way to retrieve the sws extension action names, only custom actions and scripts from reaper-kb.ini; without the sws extension cycle actions aren't available anyway
		--	local f = io.open(path..sep..'reaper-kb.ini', 'r')
		--	local cont = f:read('*a')
		--	f:close()
				for line in io.lines(path..sep..'reaper-kb.ini') do -- much quicker than using io.read() which freezes UI
				name = line:match('ACT.-("'..esc(named_cmd)..'" ".-")') or line:match('SCR.-('..esc(named_cmd)..' ".-")') -- extract command ID and name
					if name then
						if line:match('SCR') then -- evaluate if script exists
						scr_exists = script_exists(line, name)
						end
					name = name:gsub('Custom:', 'Script:', 1) -- make script data retrieved from reaper-kb.ini conform to the name returned by CF_GetCommandText() and kbd_getTextFromCmd() which prefix the name with 'Script:' following their appearance in the Action list instead of 'Custom:' as they're prefixed in reaper-kb.ini file
					break end
				end
			elseif cmd > 0 then -- either build 6.71+ or sws extension is installed
			local section = sect_t[section] or sect_t[section:match('alt')]
			local args = r.kbd_getTextFromCmd and {cmd, section} or r.CF_GetCommandText and {section,cmd} -- the order of args in the functions differ
			--	name = cmd > 0 and (named_cmd or cmd)..' "'..r.CF_GetCommandText(sect_t[section], cmd)..'"' -- add quotes to match data being retrieved form reaper-kb.ini to simplify creation of section title // if script, returns name with prefix 'Script:' as they're listed in the Action list even though in reaper-kb.ini script names are prefixed with 'Custom:' just like custom action names
			name = cmd > 0 and GetCommandText(table.unpack(args))
				if name and name:match('Script:') then -- script
				local scr_name = name:gsub('Script:', 'Custom:') -- evaluate if script exists having made a replacement to conform to the reaper-kb.ini syntax
					for line in io.lines(path..sep..'reaper-kb.ini') do
						if line:match(Esc(scr_name)) then
						scr_exists = script_exists(line, '"'..scr_name..'"')
						break end
					end
				end
			end
			mess = mess or not scr_exists and '  the script doesn\'t exist \n\n at the registered location'
			if mess then
		--	Error_Tooltip('\n\n '..mess..' \n\n', 1, 1) -- caps, spaced true
			return mess
			end
	--	return name, scr_exists, mess
		return cmd, name, sect_t[section] or sect_t[section:match('alt')] -- OR sect_t['alt']
		
		end -- 'if cmd > 0' condition end
	
	end -- 'if r.GetToggleCommandStateEx(0,40605) == 1' cond. end

end


-- local is_new_value, fullpath, sectionID, cmdID, mode, resolution, val = reaper.get_action_context()
function Condition_Action_By_Armed_State(cmdID, sectionID)
local cmd, section = r.GetArmedCommand() -- cmd is 0 when no armed action, empty string section is 'Main' section
local sect_t = {['']=0,['alt']=0,['MIDI Editor']=32060,['MIDI Event List Editor']=32061,
['MIDI Inline Editor']=32062,['Media Explorer']=32063}
	if cmd == cmdID and (sect_t[section] == sectionID
	or sect_t[section:match('alt')] and sectionID == 0) then
	r.ArmCommand(0, section) -- 0 unarm all
	-- DO STUFF
	-- OR
	-- return true
	end
end



function Validate_Command_ID(cmdID, section_ID)
-- it's advised to add leading underscrore to cmdID before passing into the function, e.g.
-- cmdID = (tonumber(cmdID) or cmdID:sub(1,1) == '_') and cmdID or '_'..cmdID -- add leading underscrore if none to named command ID

local cmdID = cmdID:gsub(' ','')
local named_cmd_ID = cmdID:gsub('_','')
local err = cmdID == '' and 'the field is empty'
local invalid = 'invalid action command ID'
err = err or tonumber(cmdID) and 
(#cmdID > 6 or r.kbd_getTextFromCmd and #r.kbd_getTextFromCmd(cmdID, section_ID) == 0 -- not native action
or r.CF_GetCommandText and #r.CF_GetCommandText(section_ID, cmdID) == 0)
and '  '..invalid..'\n\n or the action doesn\'t belong \n\n\t to the Main section'
or not tonumber(cmdID) and 
(#named_cmd_ID ~= 32 and #named_cmd_ID ~= 42 and #named_cmd_ID ~= 47 -- neither custom action nor script
or r.NamedCommandLookup(cmdID) == 0)
and invalid
	if err then
	Error_Tooltip('\n\n '..err..' \n\n', 1, 1, 200) -- caps, spaced true, x2 - 200 to move tooltip away from the mouse cursor so it doesn't block the GetUserInputs() dialogue OK button
	return
	end
return true
end



function Is_Non_Native_Action(cmdID)
-- return value nil or false doesn't necessarily mean 
-- that the cmdID belongs to a valid native action
-- to ascertain that it is see Get_Action_Name() function below
	if tonumber(cmdID) then
	return r.ReverseNamedCommandLookup(cmdID) -- accepts integers in string format as well, if the cmdID belongs to a native action or is 0 or is otherwise invalid returns nil
	else
	local num_cmdID = r.NamedCommandLookup(tostring(cmdID)) -- for numeric command IDs outputs the same integer as was put in regardless of their existence in the Action list, for invalid name command IDs outputs 0
	return num_cmdID > 0 and num_cmdID ~= tonumber(cmdID)
	end
end



function Get_Action_Name(cmdID, section_ID)
-- can be used to ascertain that the command ID belongs to a valid action

	function Esc(str)
		if not str then return end -- prevents error
	-- isolating the 1st return value so that if vars are initialized in a row outside of the function the next var isn't assigned the 2nd return value
	local str = str:gsub('[%(%)%+%-%[%]%.%^%$%*%?%%]','%%%0'):gsub('\\','%0%0')
	return str
	end
	
	local function script_exists(line, name)
	-- how paths external to \Scripts folder may look on MacOS
	-- https://github.com/Buy-One/Samelot_Reaper
	local f_path = line:match(Esc(name)..' "(.+)"$') or line:match(Esc(name)..' (.+)$') -- path either with or without spaces, in the former case it's enclosed within quotation marks
	local f_path = f_path:match('^%u:') and f_path or path..sep..'Scripts'..sep..f_path -- full (starts with the drive letter and a colon) or relative file path; in reaper-kb.ini full path is stored when the script resides outside of the 'Scripts' folder of the REAPER instance being used // NOT SURE THE FULL PATH SYNTAX IS VALID ON OSs OTHER THAN WIN	
	return r.file_exists(f_path)
	end

	if not cmdID then return end

local path = r.GetResourcePath()
local sep = path:match('[\\/]')
local named_cmd = tonumber(cmdID) and r.ReverseNamedCommandLookup(cmdID) -- ReverseNamedCommandLookup() accepts integers in string format as well, if the cmdID belongs to a native action or is 0 ReverseNamedCommandLookup() return value is nil
local act_name, mess

	if r.kbd_getTextFromCmd or r.CF_GetCommandText then -- accept command both as integer and as a string, covers all types of actions
		if not section_ID then return end
	local cmdID = named_cmd and cmdID or r.NamedCommandLookup(cmdID) -- if cmdID is integer use it, otherwise look up numeric command ID
	local GetCommandText = r.kbd_getTextFromCmd or r.CF_GetCommandText
	local args = r.kbd_getTextFromCmd and {cmdID, section_ID} or r.CF_GetCommandText and {section_ID, cmdID} -- the order of args in the functions differ
	act_name = GetCommandText(table.unpack(args))
		if named_cmd and act_name and act_name:match('Script') then -- named_cmd var makes the condition focus on non-native actions thereby excluding narive actions containing the word 'Script' in their name such as 'ReaScript: Close all running ReaScripts'
		local scr_name = act_name:gsub('Script:', 'Custom:') -- evaluate if script exists having made a replacement to conform to the reaper-kb.ini syntax
			for line in io.lines(path..sep..'reaper-kb.ini') do
				if line:match(Esc(scr_name)) then
				scr_exists = script_exists(line, '"'..scr_name..'"')
				break end
			end
		mess = not scr_exists and '  the script doesn\'t exist \n\n at the registered location'
		end
	elseif named_cmd then -- custom action or a script
		for line in io.lines(path..sep..'reaper-kb.ini') do -- much quicker than using io.read() which freezes UI
		act_name = line:match('ACT.-("'..Esc(named_cmd)..'" ".-")') or line:match('SCR.-('..Esc(named_cmd)..' ".-")') -- extract command ID and name
			if act_name then
				if line:match('SCR') then -- evaluate if script exists
				scr_exists = script_exists(line, name)
				end
			act_name = act_name:gsub('Custom:', 'Script:', 1) -- make script data retrieved from reaper-kb.ini conform to the name returned by CF_GetCommandText() and kbd_getTextFromCmd() which prefix the name with 'Script:' following their appearance in the Action list instead of 'Custom:' as they're prefixed in reaper-kb.ini file
			mess = not scr_exists and '  the script doesn\'t exist \n\n at the registered location'
			break end
		end
	end
	
	if mess then
	Error_Tooltip('\n\n '..mess..' \n\n', 1, 1, 200) -- caps, spaced true, x2 - 200 to move tooltip away from the mouse cursor or menu so it doesn't block the GetUserInputs() dialogue OK button or covered by the reloaded menu
	return
	end
	
return act_name, mess -- mess is optional, returned if isn't used as a condition for error display above

end


-- TO UNDO A TOOLTIP RUN THE SAME FUNCTION WITH AN EMPTY STRING,
-- OTHER ARGUMENTS AREN'T NECESSARY

function timed_tooltip1(tooltip, x, y, time) -- local x, y = r.GetMousePosition()
-- sticks for the duration of time in sec if the script is run from a floating toolbar button
-- so it's overrides button own tooltip which interferes

local _ = r.TrackCtl_SetToolTip

local lt, top, rt, bot = r.my_getViewport(0, 0, 0, 0, 0, 0, 0, 0, true) -- screen dimensions; wantWorkArea is true // https://forum.cockos.com/showthread.php?t=195629#4

	if r.GetCursorContext() == -1 -- when a floating toolbar button is pressed,
	-- doesn't apply to the Main toolbar docked toolbars since they do register context
	or r.GetCursorContext() > -1 and (x <= 200 or rt - x <= 200 or y <= 200 or bot - y <= 200) -- when docked or Main toolbar button is pressed, affects also calling the script from menu and via a shortcut in other areas (Mixer/TCP bottom, ruler, focused toolbar/window); won't work if the program window is shrunk
	then
	_(tooltip, x, y+10, true) -- initial display; topmost true
	local t = os.clock()
		repeat -- freezes UI so the tooltip sticks
	--	while os.clock() - t <= time do -- alternative
	--	end
		until os.clock() - t > time -- greater > sign instead of == because the exact time stamp might not get caught due to speed and the decimal value
	else _(tooltip, x, y+10, true) -- topmost is true
	end

end



function timed_tooltip2(x,y) -- deferred, all used vars must be global and come from outside, 'start' in particular
local x, y = r.GetMousePosition()
	if r.time_precise - start < 1 -- 1 sec
	then r.defer(timed_tooltip) end
r.TrackCtl_SetToolTip('TEXT', x, y, true) -- topmost is true; if x and y are taken from screen/window dimensions and divided use math.floor() so values are integers
end


function Error_Tooltip1(text, caps, spaced, x2, y2)
-- the tooltip sticks under the mouse within Arrange
-- but quickly disappears over the TCP, to make it stick
-- just a tad longer there it must be directly under the mouse
-- not directly under the mouse the tooltip sticks if mouse is over Arrange
-- but soon disappears if mouse is in the TCP area but not over the TCP
-- and immediately disappears if the mouse is over the TCP
-- caps and spaced are booleans, caps doesn't apply to non-ANSI characters
-- x2, y2 are integers to adjust tooltip position by,
-- both refer to the upper left hand corner of the tooltip,
local x, y = r.GetMousePosition()
--[[ IF USING WITH gfx
local x, y = 0,0 -- set to 0 so that they can be overridden with x2 and y2 arguments which are passed as gfx.clienttoscreen(0,0) so that the tooltip is displayed over the gfx window
]]
local text = caps and text:upper() or text
local utf8 = '[\0-\127\194-\244][\128-\191]*'
local text = spaced and text:gsub(utf8,'%0 ') or text -- supporting UTF-8 char
local x2, y2 = x2 and math.floor(x2) or 0, y2 and math.floor(y2) or 0
r.TrackCtl_SetToolTip(text, x+x2, y+y2, true) -- topmost true
-- r.TrackCtl_SetToolTip(text:upper(), x, y, true) -- topmost true
-- r.TrackCtl_SetToolTip(text:upper():gsub('.','%0 '), x, y, true) -- spaced out // topmost true
--[[
-- a time loop can be added to run until certain condition obtains, e.g.
local time_init = r.time_precise()
repeat
until condition and r.time_precise()-time_init >= 0.7 or not condition
]]
r.UpdateTimeline() -- might be needed because tooltip can sometimes affect graphics
end



function Error_Tooltip2(text, caps, spaced, x2, y2, want_color, want_blink)
-- the tooltip sticks under the mouse within Arrange
-- but quickly disappears over the TCP, to make it stick
-- just a tad longer there it must be directly under the mouse
-- not directly under the mouse the tooltip sticks if mouse is over Arrange
-- but soon disappears if mouse is in the TCP area but not over the TCP
-- and immediately disappears if the mouse is over the TCP
-- caps and spaced are booleans, caps doesn't apply to non-ANSI characters
-- x2, y2 are integers to adjust tooltip position by,
-- both refer to the upper left hand corner of the tooltip,
-- want_color is boolean to enable temporary ruler coloring to emphasize the error
-- want_blink is boolean to enable ruler color blinking
local x, y = r.GetMousePosition()
--[[ IF USING WITH gfx
local x, y = 0,0 -- set to 0 so that they can be overridden with x2 and y2 arguments which are passed as gfx.clienttoscreen(0,0) so that the tooltip is displayed over the gfx window
]]
local text = caps and text:upper() or text
local utf8 = '[\0-\127\194-\244][\128-\191]*'
local text = spaced and text:gsub(utf8,'%0 ') or text -- supporting UTF-8 char
local x2, y2 = x2 and math.floor(x2) or 0, y2 and math.floor(y2) or 0
r.TrackCtl_SetToolTip(text, x+x2, y+y2, true) -- topmost true
-- r.TrackCtl_SetToolTip(text:upper(), x, y, true) -- topmost true
-- r.TrackCtl_SetToolTip(text:upper():gsub('.','%0 '), x, y, true) -- spaced out // topmost true
	if want_color then
	local color_init = r.GetThemeColor('col_tl_bg', 0) -- get default theme color, determined by the settings in the 'Theme development/tweaker' dialogue (NOT in the .ReaperTheme file) ignoring settings in the 'Theme Color Control' dialogue (https://forum.cockos.com/showthread.php?t=291551)
	-- 255<<8 green, 255 red, 255<<16 blue, 255<<8|32767 or 65535 yelow
	local color = color_init ~= 255 and 255 or 65535 -- use red or yellow if red is taken
		if want_blink then
		    for i = 1, 100 do
				if i == 1 or i == 40 or i == 80 then
				r.SetThemeColor('col_tl_bg', color, 0)
				elseif i == 20 or i == 60 or i == 100 then
				r.SetThemeColor('col_tl_bg', color_init, 0)
				end
			r.UpdateTimeline()
			end
		else
		r.SetThemeColor('col_tl_bg', color, 0) -- Timeline background
			for i = 1, 200 do -- ensures that the warning color sticks for some time
			-- without the function inside the loop the end (200) value must be much greater
			r.UpdateTimeline()
			end
		r.SetThemeColor('col_tl_bg', color_init, 0) -- Timeline background // restore the orig color
		r.UpdateTimeline() -- without this function the color will only be restored when user clicks within the Arrange
		end
	end
--[[
-- a time loop can be added to run until certain condition obtains, e.g.
local time_init = r.time_precise()
repeat
until condition and r.time_precise()-time_init >= 0.7 or not condition
]]
r.UpdateTimeline() -- might be needed because tooltip can sometimes affect graphics
end



function Error_Tooltip3(text, format) -- format must be true
-- the tooltip sticks under the mouse within Arrange
-- but quickly disappears over the TCP, to make it stick
-- just a tad longer there it must be directly under the mouse
-- not directly under the mouse the tooltip sticks if mouse is over Arrange
-- but soon disappears if mouse is in the TCP area but not over the TCP
-- and immediately disappears if the mouse is over the TCP
local x, y = r.GetMousePosition()
-- supporting UTF-8 char
local utf8 = '[\0-\127\194-\244][\128-\191]*'
local text = text and type(text) == 'string' and (format and text:upper():gsub(utf8,'%0 ') or text) or 'not a valid "text" argument'
r.TrackCtl_SetToolTip(text, x, y, true) -- topmost true
r.UpdateTimeline() -- might be needed because tooltip can sometimes affect graphics
end



function Center_Message_Text(mess, spaced)
-- to be used before Error_Tooltip()
-- spaced is boolean, must be true if the same argument is true in Error_Tooltip()
local t, max = {}, 0
	for line in mess:gmatch('[^%c]+') do
		if line then
		t[#t+1] = line
		max = #line > max and #line or max
		end
	end
local coeff = spaced and 1.5 or 2 -- 1.5 seems to work when the text is spaced out inside Error_Tooltip(), otherwise 2 needs to be used
	for k, line in ipairs(t) do
	local shift = math.floor((max - #line)/2*coeff+0.5)
	local lb = k < #t and '\n\n' or ''
	t[k] = (' '):rep(shift)..line..lb
	end
return table.concat(t)
end



function Get_Mouse_Pos_Sec(want_over_arrange, want_snapping)

	if want_over_arrange and not r.GetTrackFromPoint(r.GetMousePosition()) -- look for the mouse cursor pos // GetTrackFromPoint() prevents getting mouse position if the script is run from a toolbar or the Action list window floating over Arrange or if mouse cursor is outside of Arrange because in this case GetTrackFromPoint() returns nil; usually in this case the script should fall back on getting edit cursor position; this condition doesn't apply to mouse over a Mixer track
	then return end

local comm_id = want_snapping and 40513 -- View: Move edit cursor to mouse cursor
or 40514 -- View: Move edit cursor to mouse cursor (no snapping)
r.PreventUIRefresh(1)
local cur_pos = r.GetCursorPosition() -- store current edit cur pos
r.Main_OnCommand(comm_id,0)
local mouse_pos = r.GetCursorPosition()
r.SetEditCurPos(cur_pos, false, false) -- moveview, seekplay false // restore edit cur pos
r.PreventUIRefresh(-1)
return mouse_pos
end


function Get_Mouse_Time_Pos() -- isn't suitable for use during playback as it stops it (this seems wrong), won't return true mouse cursor position if it's over TCP, Get_TCP_MCP_Under_Mouse() must be used to ascertain that it's outside of it
r.PreventUIRefresh(1) -- ensures that the edit cursor movements aren't noticeable
local cur_pos_init = r.GetCursorPosition()
r.Main_OnCommand(40514, 0) -- View: Move edit cursor to mouse cursor (no snapping)
local cur_pos = r.GetCursorPosition()
r.SetEditCurPos(cur_pos_init, false, false) -- moveview, seekplay false // restore orig edit curs pos
r.PreventUIRefresh(-1)
return cur_pos
end



function Get_Mouse_Or_Edit_Curs_Pos()
-- relies on Get_TCP_MCP_Under_Mouse() to ensure that the mouse cursor is not over TCP
-- if it is, edit cursor pos is returned

local edit_curs_pos = r.GetCursorPosition() -- store
local cur_pos

local tr, info = r.GetTrackFromPoint(r.GetMousePosition())
-- ensuring that mouse cursor is over Arrange allows ignoring mouse position
-- when the script is run via toolbar button, menu item or from the Action list
	if tr and not Get_TCP_MCP_Under_Mouse() and info ~= 2 then -- not FX window
	r.PreventUIRefresh(1)
	r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping) // more sensitive than with snapping
	cur_pos = r.GetCursorPosition()
	r.SetEditCurPos(edit_curs_pos, false, false) -- moveview, seekplay false // restore orig. edit curs pos
	r.PreventUIRefresh(-1)
	end

return cur_pos or edit_curs_pos

end



function Get_Mouse_TimeLine_Pos(zones_t)
-- zones_t contains start and end time along X axis
-- if zones_t arg is absent the function evaluates if mouse if over the TCP, otherwise if mouse is within a paricular zone on the Arrange time line
-- r.GetTrackFromPoint() covers the entire track timeline hence isn't suitable for getting the TCP
-- master track is supported
local right_tcp = r.GetToggleCommandStateEx(0,42373) == 1 -- View: Show TCP on right side of arrange
local curs_pos = r.GetCursorPosition() -- store current edit curs pos
local start_time, end_time = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false, screen_x_start, screen_x_end are 0 to get full arrange view coordinates // get time of the current Arrange scroll position to use to move the edit cursor away from the mouse cursor // https://forum.cockos.com/showthread.php?t=227524#2 the function has 6 arguments; screen_x_start and screen_x_end (3d and 4th args) are not return values, they are for specifying where start_time and end_time should be on the screen when non-zero when isSet is true // when the Arrange is scrolled all the way to the start the function ignores project start time offset and any offset start still treats as 0
--local TCP_width = tonumber(cont:match('leftpanewid=(.-)\n')) -- only changes in reaper.ini when dragged
r.PreventUIRefresh(1)
local edge = right_tcp and start_time-5 or end_time+5
r.SetEditCurPos(edge, false, false) -- moveview, seekplay false // to secure against a vanishing probablility of overlap between edit and mouse cursor positions in which case edit cursor won't move just like it won't if mouse cursor is over the TCP // +/-5 sec to move edit cursor beyond right/left edge of the Arrange view to be completely sure that it's far away from the mouse cursor // if start_time is 0 and there's negative project start offset the edit cursor is still moved to the very start, that is past 0, the function ignores negative start offset therefore is fully compatible with GetSet_ArrangeView2()
r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping) // more sensitive than with snapping // works along the entire screen Y axis outside of the TCP regardless of whether the program window is under the mouse
local new_cur_pos = r.GetCursorPosition()
local target
	if not zones_t then
	target = new_cur_pos == edge or new_cur_pos == 0 -- if the TCP is on the right and the Arrange is scrolled all the way to the project start or close enough to it start_time-5 won't make the edit cursor move past the project start hence the 2nd condition, but it can move past the right edge
	else
	target = new_cur_pos >= zones_t.start and new_cur_pos <= zones_t.fin
	end
-- Restore orig. edit cursor pos
r.SetEditCurPos(curs_pos, false, false) -- moveview, seekplay false // restore orig. edit curs pos
r.PreventUIRefresh(-1)
return target
end



function isMouseInArrangeView()
-- https://github.com/LAxemann/LAxemann_ReaperScripts/blob/main/Various/LAx_SlipView/LAx_SlipView%20-%20Main.lua
return r.BR_GetMouseCursorContext() == "arrange"
end



function Get_Tooltip_Settings()
-- r.get_config_var_string() can be used instead of io.open()
-- which is preferbale because the key is always present in the RAM
-- Preferences -> Appearance - Appearance settings - Tooltips:
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local val = cont:match('tooltips=(.-)\n')
local delay = cont:match('tooltipdelay=(.-)\n') -- likely in ms
local val, delay = tonumber(val), tonumber(delay)
local UI, itm_env, env_hov
-- Thanks to Mespotine
-- https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
	if val then
	UI, itm_env, env_hov = val&2 == 0, val&1 == 0, val&4 == 0 -- UI elements, Items/envelopes, Envs on hover -- enabled
	end
return UI, itm_env, env_hov, delay
end


-- for keeping user stored parameter a limited amount of time, e.g. when two script runs must follow each other in close succession so that if the follow-up execution isn't performed within specific time frame, the value is invalid for the next run
function Keep_ExtState_For_X_Mins1(Sect, Key, Val, Minutes, Set)
-- Minutes is number, Set is boolean whether to set or get
	if Set then
	r.SetExtState(Sect, Key, Val..':'..os.clock(), false) -- persist false
	else
	local state = r.GetExtState(Sect, Key)
	local time_init = state:match(':(.+)')
		if (os.clock() - (time_init+0))/60 >= Minutes then return
		else
		return state:match('(.+):')
		end
	end
end


-- this version is to be used as a boolean to determine whether to run GetExtState() to retrieve the stored value
function Keep_ExtState_For_X_Mins2(Minutes, Set)
-- Minutes is number, Set is boolean whether to set or get
	if Set then
	r.SetExtState('KEEP EXT STATE FOR X MINS', 'TIME INIT', os.clock(), false) -- persist false
	else
	local time_init = r.GetExtState('KEEP EXT STATE FOR X MINS', 'TIME INIT')
		if (os.clock() - (time_init+0))/60 >= Minutes then return
		else
		return true
		end
	end
end
--[[ USASE EXAMPLE:
Keep_ExtState_For_X_Mins2(1, true) -- Set true, Minutes argument isn't used at this stage
local elapsed = Keep_ExtState_For_X_Mins2(1) -- Set is false, Minutes argument is 1
	if elapsed then (some message) return end
local state = not elapsed and r.GetExtState(section, key) -- get the stored data since the storage time hasn't elapsed
--]]


function ExtState_Expiry_Timer(cmd_ID, threshold)
-- threshold is integer, time in seconds
-- useful for limiting the time of data storage in the buffer
-- used in Import metadata from media into the Project Render Metadata.lua
local timestamp = tonumber(r.GetExtState(cmd_ID, 'EXPIRY TIMER'))
	if not timestamp and not threshold then -- this conditions timer setting
	r.SetExtState(cmd_ID, 'EXPIRY TIMER', r.time_precise(), false) -- persist false
	elseif timestamp and threshold and r.time_precise()-timestamp >= threshold then
	r.DeleteExtState(cmd_ID, 'EXPIRY TIMER', true) -- persist true // clear timer	
	return true
	elseif not timestamp and threshold then
	return true -- this conditions greyed out Undo menu item when the script hasn't been run yet and so the timer hasn't been set
	end
end
--[[USE:
ExtState_Expiry_Timer(cmd_ID) -- store
	if not ExtState_Expiry_Timer(cmd_ID, 60) then -- 60 sec haven't elapsed
	-- DO STAFF
	end
	-- OR
	if ExtState_Expiry_Timer(cmd_ID, 60) then return r.defer(no_undo) end
]]



function Set_Get_Delete_ExtState_Series(Set, Get, Del, t)
-- all args are booleans, t is a table containing values to be stored,
-- ommission of t argument disables Set arg
local _, scr_name, sect_ID, cmd_ID, _,_,_ = r.get_action_context()
local named_ID = r.ReverseNamedCommandLookup(cmd_ID)
	if Set and t and type(t) == 'table' then
		for k, v in ipairs(t) do
		r.SetExtState(named_ID, k, v, false) -- persist false
		end
	elseif Get then
	local t = {}
	local i = 1
		repeat -- construct table from extended states
		t[#t+1] = r.GetExtState(named_ID, i)
		i = i+1
		until r.GetExtState(named_ID, i) == '' -- first key without stored value
	return t
	elseif Del then
	local i = 1
		repeat
		r.DeleteExtState(sect, i, true) -- persist true
		i = i+1
		until r.GetExtState(sect, i) == '' -- first key without stored value
	end
end



function WAIT(duration_in_sec)
-- https://stackoverflow.com/questions/1034334/easiest-way-to-make-lua-script-wait-pause-sleep-block-for-a-few-seconds other suggestions
local t = os.clock()
	repeat -- freezes UI so the tooltip sticks
	until os.clock() - t > duration_in_sec
-- 	OR
--	while os.clock() - t <= duration_in_sec do
--	end
end

DURATION_IN_SEC = ""
function DEFERRED_WAIT()
-- https://stackoverflow.com/questions/1034334/easiest-way-to-make-lua-script-wait-pause-sleep-block-for-a-few-seconds other suggestions
local t = os.clock()
	if os.clock() - t > tonumber(DURATION_IN_SEC) then
	-- DO STUFF
	return end
r.defer(DEFERRED_WAIT)
end


function Archie_WAIT()
-- https://rmmedia.ru/threads/110165/post-2519952
-- https://rmmedia.ru/threads/110165/post-2520017 explanation + further below
x = x + 1
	if x >= 10 then
	-- DO STUFF, OR KEEP IDLE
	return
	end
r.defer(Archie_WAIT)
end
--r.defer(Archie_WAIT)


-- REAPER version check
function REAPER_Ver_Check1(build) -- build is REAPER build number, the function must be followed by 'do return end'
	if tonumber(r.GetAppVersion():match('[%d%.]+')) < build then
	local x,y = r.GetMousePosition()
	local mess = '\n\n   THE SCRIPT REQUIRES\n\n  REAPER '..build..' AND ABOVE  \n\n '
	local mess = mess:gsub('.','%0 ')
	r.TrackCtl_SetToolTip(mess, x, y+10, true) -- topmost true
	return true
	end -- 'ReaScript:Run' caption is displayed in the menu bar but no actual undo point is created because Undo_BeginBlock() isn't yet initialized, here and elsewhere
end


function REAPER_Ver_Check2(some_build) -- some_build is a string/number
local some_build = some_build and tonumber(some_build)
local cur_build = tonumber(r.GetAppVersion():match('[%d%.]+'))
	if some_build then -- return full table
	return {current = cur_build, earlier = cur_build < some_build, later = cur_build > some_build, same = cur_build == some_build}
	end
	return {current = cur_build} -- if not some_build or it's not a number, only current build number
end


function REAPER_Ver_Check3(build, want_later, want_earlier, want_current)
-- build is REAPER build number or sring, the function must be followed by 'do return end'
-- want_later, want_earlier and want_current are booleans
-- obviously want_later and want_earlier are mutually exclusive
-- want_later includes current, want_earlier is the up-to version
local build = build and tonumber(build)
local cur_buld = tonumber(r.GetAppVersion():match('[%d%.]+'))
local later, earlier, current = cur_buld >= build, cur_buld < build, cur_buld == build
local err = '   the script requires \n\n  '
local err = not later and err..'reaper '..build..' and later '
or not earlier and err..'reaper not later than '..build
	if err then
	local x,y = r.GetMousePosition()
	err = err:upper():gsub('.','%0 ')
	r.TrackCtl_SetToolTip(err, x, y+10, true) -- topmost true
	return true
	end -- 'ReaScript:Run' caption is displayed in the menu bar but no actual undo point is created because Undo_BeginBlock() isn't yet initialized, here and elsewhere
end
-- USE:
-- if REAPER_Ver_Check3(build, want_later, want_earlier, want_current)
-- then return r.defer(function() do return end end) end -- OR use no_undo() function


function SWS_Version_Check(ver, older, newer, same)
-- ver is a string contaning a version number
-- to compare current version againts
-- the rest are booleans which are comparison criteria
-- obviously older and newer are mutually exclusive
-- and option 'older' has priority if both are true
-- same is compatible with both and complementary
-- or can be used by itself
	if r.CF_GetSWSVersion then -- accounting for versions before this function was available
	-- https://forums.cockos.com/showthread.php?p=2026809 2.9.8
	-- remove all dots so it looks like an integer and convert to number
	local ver = ver:gsub('%.','')+0
	local curr_ver = r.CF_GetSWSVersion():gsub('%.','')+0
	local result = older and curr_ver < ver or not older and newer and curr_ver > ver -- 'not older' ensures that when both older and newer args are true the function doesn't return truth if first evaluaton fails because not older
	return result or same and curr_ver == ver
	end
end



function how_recently_the_project_was_saved()
local retval, projfn = r.EnumProjects(-1) -- -1 current project; returns empty string if project doesn't have a file and returns path even if the project file and possibly folder was deleted while the project is open

	if not r.file_exists(projfn) then return end -- either tab with no project file or deleted project file in which case it's impossible or pointless to retrieve last save time

local last_save_time

	for line in io.lines(projfn) do
		if line:match('REAPER_PROJECT') then last_save_time = line:match('.+ (%d+)') break end -- the integer represents Unix time at the moment the project was last saved https://www.askjf.com/index.php?q=6650s
	end
	
	if not proj_file_exists then os.remove(projfn) end -- delete temp proj file
	
--os.setlocale ('', 'time') -- set, otherwise timestamp doesn't use current locale https://www.gammon.com.au/scripts/doc.php?lua=os.date // doesn't set custom date format
local diff = os.time() - last_save_time
return diff, -- seconds
math.floor(diff/60+0.5), -- minutes, rounded
math.floor(diff/3600+0.5), -- hours, rounded
math.floor(diff/(3600*24)+0.5), -- days, rounded
os.date('%x %X',last_save_time), -- last save date & time in current locale format
os.date('%x %X',os.time()) -- current date & time in current locale format
	
end
-- USE:
-- local sec, mins, hrs, days, timestamp_save, timestamp_cur = how_recently_the_project_was_saved()


function Time_Sel_Or_Loop_Exist(want_loop)
local start, fin = r.GetSet_LoopTimeRange(false, want_loop, 0, 0, false) -- isSet, allowautoseek false
return start ~= fin
end


function Is_Ctrl_And_Shift()
-- check if the script is bound to a shortcut containing both Ctrl & Shift
-- which is not advised when the version of Get_Arrange_and_Header_Heights() function is used which creates temporary project tab to fetch the Arrange height data because in this case if the key combination is long pressed a prompt will appear offering to load project with FX offline
-- only relevant if SWS and js_ReaScriptAPI extensions are not installed
-- because only in this case to get the Arrange height a track max zoom is used in a temp proj tab
local is_new_value,filename,sectID,cmdID,mode,resol,val = r.get_action_context()
local named_ID = r.ReverseNamedCommandLookup(cmdID) -- convert numeric returned by get_action_context to alphanumeric listed in reaper-kb.ini
local res_path = r.GetResourcePath()..r.GetResourcePath():match('[\\/]') -- path with separator; or or package.config:sub(1,1) to get the separator
local s,R = ' ', string.rep
	for line in io.lines(res_path..'reaper-kb.ini') do
		if line:match('_'..named_ID) then -- in the shortcut data section command IDs are preceded with the underscore
		local modif = line:match('KEY (%d+)')
			if modif == '13' or modif == '29' then -- Ctrl+Shift or Ctrl+Shift+Alt
			r.MB(R(s,3)..'The script is bound to a shotrcut\n\n'..R(s,5)..'containing Ctrl and Shift keys.\n\n'..R(s,12)..'This will unfortunately\n\n intefere with the script performance.\n\n'..R(s,7)..'It\'s strongly advised to remap\n\n'..R(s,6)..'the script to another shortcut.\n\n\tSincere apologies!','ERROR',0)
			return true
			end
		end
	end
end
-- if Is_Ctrl_And_Shift(cmdID) then return r.defer(no_undo) end



function GetPlayPosition3() -- using r.GetPlayPosition2() only when transport runs because the function runs independently of it
-- https://forum.cockos.com/showthread.php?p=2617467
-- https://forum.cockos.com/showthread.php?t=273086
-- r.GetPlayPosition2() initial time depends on the edit cursor position, so once transport starts the value changes to the one corresponding to the current edit cursor position
local pos
	if r.GetPlayState() > 0 then
	pos = r.GetPlayPosition2()
	else
	pos = r.GetCursorPosition()
	end
return pos
end



function Is_Mouse_Over_Arrange1() -- SEE Is_Mouse_Over_Arrange2() for version without limitations AND a streamlined version Is_Mouse_Over_Arrange3()
-- if no items or tracks temp objects are added
-- set up to only detect Arrange when the mouse cursor is placed opposite of a track with Arrange
-- so won't detect Arrange without tracks in the project
-- temp track routine has been superseded by condition to abort function if no tracks in the project or mouse is outside of tracks within the time line, due to reasons explained below
local x, y = r.GetMousePosition()
	if r.GetItemFromPoint(x, y, true)-- allow_locked true
	then return true end -- if there's item under mouse it's surely over Arrange

local tr_at_mouse, info = r.GetTrackFromPoint(x, y)
	if not tr_at_mouse or info == 2 -- info 2 - FX
	then return end -- scripts which will rely in this function WILL HAVE TO INCLUDE INSTRUCTION to place cursor opposite to any track in Arrange, this is to prevent the ugly track expansion trick below, this means that below the track list on X axis Arrange won't be detected

local item, tr
local ACT = r.Main_OnCommand

	-- Isn't used due to 'not tr_at_mouse' condition above
	if not r.GetTrack(0,0) then -- insert temp track to insert temp item on
	r.InsertTrackAtIndex(0, false) -- wantDefaults false
	tr = r.GetTrack(0,0) -- track to be deleted
	r.SetTrackSelected(tr, true) -- selected true
	end

	if r.CountMediaItems(0) == 0 then -- create temp item
	local track = r.GetTrack(0,0) -- track to be kept
	item = r.AddMediaItemToTrack(track) -- insert temp item
	-- if mouse happens to point at a temporary item it itself or the temp track won't be deleted
	-- hence it must be invisible to the mouse, so the length isn't set, and pos is set to be outside of visible Arrange area
	-- r.SetMediaItemInfo_Value(item, 'D_LENGTH', 2) -- 2 sec
	local st, fin = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false
	r.SetMediaItemInfo_Value(item, 'D_POSITION', fin)
	end

----- Temp track routine
---- The following routine is prevented by 'not tr_at_mouse' condition above because of its ugly implementation due to botched track zoom overhaul in build 6.76 https://forum.cockos.com/showthread.php?t=278646, it could work if increase and decrease loops where both enclosed between the same PreventUIRefresh() instances but it's not possible because they will prevent getting new track height, but otherwise
-- it determines if mouse points at a track within Arrange and if not, expands the last track to the entire Arrange height so the mouse ends up pointing at it because the action 'Item: Select item under mouse cursor' used to detect Arrange only works along a track time line therefore if the mouse doesn't already point at a track either the track must be made Arrange tall by expansion or multiple tracks must be inserted to fill the entire Arrange height
-- by itself validity if tr_at_mouse value isn't indicative because TCP outside or Arrange is also covered, it's used to condition track expansion below if the mouse happens to not point at a track within the time line; tr_at_mouse is valid when the cursor points at an item as well
local tr_at_mouse = tr_at_mouse and info ~= 2 -- info 2 is FX, info 1 - envelope is also valid both at TCP and along the time lime
local sel_t = {tr={}, itm={}}
	if not tr_at_mouse then -- store since selection may change due to necessity to expand a track below which has to be selected
		for i = 0, r.CountSelectedTracks(0)-1 do
		sel_t.tr[#sel_t.tr+1] = r.GetSelectedTrack(0,i)
		end
	end
local track = not tr_at_mouse and r.GetTrack(0,r.GetNumTracks()-1) -- use last to expand because if 1st is used the track list scrolls to it when it's expanded, and if there're enough tracks in the project the only situation when mouse won't point at any is at the bottom of the track list anyway, in all other cases track list isn't long enough and it will be scrolled to the start at the end of the routine
	if track then -- only runs if mouse doesn't point at a track within Arrange
--[[ -- not really successful attempt to prevent triggering the function multiple times in a row if script is triggered with a mousewheel because 1 mousewheel scroll sends multiple triggers, which turns out to be faster than the track expansion and contraction
	local last = r.GetExtState('Is_Mouse_Over_Arrange()', 'last')
	local cur_time = r.time_precise()
		if #last > 0 and cur_time-last < 2 then Msg(last, 'last') return end
--	r.SetExtState('Is_Mouse_Over_Arrange()', 'last', cur_time, false) -- persist false
--]]
	r.PreventUIRefresh(1)
	r.SetOnlyTrackSelected(track)
	-- looks ugly with mousewheel because temp tracks are deleted slower than the script is triggered
	-- 100 value looks better but on big monitors may not be enough to make TCP fill the entire Arrange
		for i = 1, 200 do
		ACT(41325, 0) -- View: Increase selected track heights // works in 8 px increments
		end
	r.PreventUIRefresh(-1)
	end
----------------------------

-- REAPER devs don't recommend using CountSelectedMediaItems()
-- and GetSelectedMediaItem in favor of CountMediaItems()
-- and IsMediaItemSelected() instead
-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
local GetCount = r.CountSelectedMediaItems
local itm_cnt = GetCount(0)
	for i = 0, itm_cnt-1 do	-- store selected items
	sel_t.itm[#sel_t.itm+1] = r.GetSelectedMediaItem(0,i)
	end
	if itm_cnt == 0 then -- if no selected select 1st item to use as a means of evaluation
	r.SetMediaItemSelected(r.GetMediaItem(0,0), true)
	itm_cnt = 1
	end -- selected true
ACT(40528, 0) -- Item: Select item under mouse cursor // selects item under mouse (or keeps selected), deselects others; deselects all if mouse is outside of items within Arrange
local arrange = GetCount(0) < itm_cnt
-- in theory the action above may not affect selection if the mouse was hovering over a lone selected item to begin with, but this possibility is eliminated with GetItemFromPoint() above which in itself is enough to determine that the mouse is over Arrange, still adding the option for completeness, will make the function work even without GetItemFromPoint()
	if GetCount(0) == itm_cnt then
	r.SelectAllMediaItems(0,false) -- selected false // deselect all
	ACT(40528, 0) -- repeat action // if the item wasn't re-selected, the the mouse is not within Arrange
	arrange = GetCount(0) == itm_cnt -- indeed the cursor already pointed at an item
	end
	if tr then r.DeleteTrack(tr) -- temp track // isn't used due to 'not tr_at_mouse' condition above
	elseif item then -- temp item
	r.DeleteTrackMediaItem(r.GetMediaItemTrack(item), item)
	end
	r.PreventUIRefresh(1)
	--------------------
	-- isn't used due to 'not tr_at_mouse' condition above
	if not tr and track then -- all this is redundant if temp track tr was used, because it's deleted above
		for i = 1, 200 do
		ACT(41326, 0) -- View: Decrease selected track heights // works in 8 px increments
		end
	r.CSurf_OnScroll(0,-1000) -- scroll back to the track list start since expansion of the last makes the list scroll to its end
	end
	------------------
	if not tr then -- same as above
	local sel = sel_t.tr[1] and r.SetOnlyTrackSelected(sel_t.tr[1])
		for _, tr in ipairs(sel_t.tr) do
		r.SetTrackSelected(tr, true) -- selected true
		end
	end
r.SelectAllMediaItems(0,false) -- selected false // deselect all
	for _, itm in ipairs(sel_t.itm) do -- restore item selection
	r.SetMediaItemSelected(itm, true) -- selected true
--	r.UpdateItemInProject(itm) -- same as r.UpdateArrange()
	end
	r.PreventUIRefresh(-1)

r.UpdateArrange()
return arrange
end



function Is_Mouse_Over_Arrange2() -- SEE streamlined Is_Mouse_Over_Arrange3() below
-- if no items or tracks temp objects are added
local x, y = r.GetMousePosition()
	if r.GetItemFromPoint(x, y, true) -- allow_locked true
	then return true end -- if there's item under mouse it's surely over Arrange

local item, tr
local ACT = r.Main_OnCommand

	if not r.GetTrack(0,0) then -- insert temp track to insert temp item on
	r.InsertTrackAtIndex(0, false) -- wantDefaults false
	tr = r.GetTrack(0,0) -- track to be deleted
	r.SetTrackSelected(tr, true) -- selected true
	end

	if r.CountMediaItems(0) == 0 then -- create temp item
	local track = r.GetTrack(0,0) -- track to be kept
	item = r.AddMediaItemToTrack(track) -- insert temp item
	-- if mouse happens to point at a temporary item it itself or the temp track won't be deleted
	-- hence it must be invisible to the mouse, so the length isn't set, and pos is set to be outside of visible Arrange area
	-- r.SetMediaItemInfo_Value(item, 'D_LENGTH', 2) -- 2 sec
	local st, fin = r.GetSet_ArrangeView2(0, false, 0, 0, start_time, end_time) -- isSet false
	r.SetMediaItemInfo_Value(item, 'D_POSITION', fin)
	end

local tr_at_mouse, info = r.GetTrackFromPoint(x, y)
local tr_at_mouse = tr_at_mouse and info ~= 2 -- info 2 is FX, info 1 - envelope is also valid both at TCP and along the time lime
local track = not tr_at_mouse and r.GetTrack(0,r.GetNumTracks()-1) -- use last to expand because if 1st is used the track list scrolls to it when it's expanded, and if there're enough tracks in the project the only situation when mouse won't point at any is at the bottom of the track list anyway, in all other cases track list isn't long enough and it will be scrolled to the start at the end of the routine
local tr_h = track and r.GetMediaTrackInfo_Value(track, 'I_TCPH')
	if track then -- only runs if mouse doesn't point at a track within Arrange
	r.SetMediaTrackInfo_Value(track, 'I_HEIGHTOVERRIDE', 800)
	r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275
	end

-- REAPER devs don't recommend using CountSelectedMediaItems()
-- and GetSelectedMediaItem in favor of CountMediaItems()
-- and IsMediaItemSelected() instead
-- https://forum.cockos.com/showthread.php?p=2807092#post2807092
local GetCount = r.CountSelectedMediaItems
local itm_cnt = GetCount(0)
local sel_t = {}
	for i = 0, itm_cnt-1 do	-- store selected items
	sel_t[#sel_t+1] = r.GetSelectedMediaItem(0,i)
	end
	if itm_cnt == 0 then -- if no selected select 1st item to use as a means of evaluation
	r.SetMediaItemSelected(r.GetMediaItem(0,0), true)
	itm_cnt = 1
	end -- selected true
ACT(40528, 0) -- Item: Select item under mouse cursor // selects item under mouse (or keeps selected), deselects others; deselects all if mouse is outside of items within Arrange
local arrange = GetCount(0) < itm_cnt
-- in theory the action above may not affect selection if the mouse was hovering over a lone selected item to begin with, but this possibility is eliminated with GetItemFromPoint() above which in itself is enough to determine that the mouse is over Arrange, still adding the option for completeness, will make the function work even without GetItemFromPoint()
	if GetCount(0) == itm_cnt then
	r.SelectAllMediaItems(0,false) -- selected false // deselect all
	ACT(40528, 0) -- repeat action // if the item wasn't re-selected, the mouse is not within Arrange
	arrange = GetCount(0) == itm_cnt -- indeed the cursor already pointed at an item
	end
	if tr then r.DeleteTrack(tr) -- temp track // isn't used due to 'not tr_at_mouse' condition above
	elseif item then -- temp item
	r.DeleteTrackMediaItem(r.GetMediaItemTrack(item), item)
	end
	r.PreventUIRefresh(1)
	if not tr and track then -- all this is redundant if temp track tr was used, because it's deleted above
	r.SetMediaTrackInfo_Value(track, 'I_HEIGHTOVERRIDE', tr_h)
	r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275
	r.CSurf_OnScroll(0,1000) -- scroll back to the track list end since expansion of the last makes the list scroll up
	end
r.SelectAllMediaItems(0,false) -- selected false // deselect all
	for _, itm in ipairs(sel_t) do -- restore item selection
	r.SetMediaItemSelected(itm, true) -- selected true
--	r.UpdateItemInProject(itm) -- same as r.UpdateArrange()
	end
	r.PreventUIRefresh(-1)

r.UpdateArrange()
return arrange
end



function Is_Mouse_Over_Arrange3(ignore_items)
-- relies on Get_TCP_MCP_Under_Mouse()
-- ignore_items is boolean, if true, only cursor outside of items in Arrange is respected

local x, y = r.GetMousePosition()

	-- if there's item under mouse it's surely over Arrange unless ignore_items is true
	if r.GetItemFromPoint(x, y, true) -- allow_locked true
	then return not ignore_items end

local tr, info = r.GetTrackFromPoint(x, y)
	if tr and info ~= 2 and not Get_TCP_MCP_Under_Mouse() then return tr end -- info 2 is FX window

	if not tr then -- the cursor might be located within Arrange but below the last track in which case tr will be nil
--	r.PreventUIRefresh(1) -- doesn't help much
	local tr_idx = not r.GetTrack(0,0) and 0 or r.GetNumTracks()-1 -- insert temp track if no tracks or cursor is lower than the last track in which case tr cannot be valid
	r.InsertTrackAtIndex(tr_idx, false) -- wantDefaults false
	local temp_tr = r.GetTrack(0, tr_idx) -- track to be deleted
		if r.GetTrackFromPoint(x, y) and not Get_TCP_MCP_Under_Mouse()
		then
		r.DeleteTrack(temp_tr) -- temp track
	--	r.PreventUIRefresh(-1)
		return true
	--	else
	--	r.PreventUIRefresh(-1)
		end
	-- if not found at cursor, increase height
	r.SetMediaTrackInfo_Value(temp_tr, 'I_HEIGHTOVERRIDE', 800)
	r.TrackList_AdjustWindows(true) -- isMinor is true // updates TCP only https://forum.cockos.com/showthread.php?t=208275
--	r.PreventUIRefresh(1)
	local tr  = r.GetTrackFromPoint(x, y)
	r.DeleteTrack(temp_tr) -- temp track
--	r.PreventUIRefresh(-1)
	r.CSurf_OnScroll(0,1000) -- scroll back to the track list end since expansion of the last makes the list scroll up
	return not Get_TCP_MCP_Under_Mouse() and tr
	end

end



function Get_Cursor_Contexts(allow_locked, sectionID, cmd_ID)
-- uses Mouse_Cursor_outside_painoroll(), Get_Mouse_Coordinates_MIDI(),
-- Get_TCP_MCP_Under_Mouse() and Is_Mouse_Over_Arrange()

local allow_locked = not allow_locked and false or true
local x, y = r.GetMousePosition()
local item, take = r.GetItemFromPoint(x, y, allow_locked) -- allow_locked boolean
local build_6_36 = tonumber(r.GetAppVersion():match('[%d%.]+')) >= 6.36 -- build since which GetThingFromPoint() is supported
local tr, info = table.unpack(build_6_36 and {r.GetThingFromPoint(x, y)} or {r.GetTrackFromPoint(x, y)})
	if item then
	local env = r.GetSelectedEnvelope(0)
	local parent_take, fx_idx, parm_idx = table.unpack(env and {r.Envelope_GetParentTake(env)} or {})
	return parent_take == take and 'envelope' or r.CountTakes(item) == 1 and 'item' or 'take'
	elseif tr then
		if build_6_36 then
		local tcp, mcp, fx, env, arrange = info:match('tcp'), info:match('mcp'), info:match('fx'),
		info:match('env'), -- regardless of env selection
		info:match('arrange') -- arrange excluding items because items are evaluated earlier
		return arrange or fx or env and 'envelope' or tcp or mcp -- in this order because when env and fx, tcp or mcp are also true
		else
		local env, fx = info == 1 and 'envelope', info == 2 and 'fx' -- env regardless of env selection
		return env or fx or tr and (Get_TCP_MCP_Under_Mouse() and 'tcp' or 'arrange')
		end
	elseif sectionID == 32060 then
	local ME = r.MIDIEditor_GetActive()
	local ctx = r.MIDIEditor_GetSetting_int(ME, 'last_clicked_cc_lane') -- click context, returns -1 if Piano roll/Event list, > -1 if any lane
		if ctx and ctx > -1 then return 'cc' -- ctx may be false if the Main section script instance is triggered
		elseif not Mouse_Cursor_outside_painoroll(r.MIDIEditor_GetTake(ME))
		and Get_Mouse_Coordinates_MIDI() -- wantSnapped false
		then return 'pianoroll'
		elseif Is_Mouse_Over_Arrange() then return 'arrange'
		end
--	elseif not tr and Is_Mouse_Over_Arrange() then return 'arrange' -- either no tracks in the project or mouse is lower than the last track // WORKS BUT IF THE SCRIPT IS RUN FROM A TOOLBAR OR A MENU MOUSE CONTEXT IS ALWAYS INVALID WHICH TRIGGERS Is_Mouse_Over_Arrange() AND TEMP TRACK FLASHES BECAUSE PreventUIRefresh() IS UNUSED AS IT PREVENTS TRACK HEIGHT UPDATE INSIDE Is_Mouse_Over_Arrange() PLUS 'arrange' CONTEXT IS STILL NOT RETURNED, THEREFORE THE CONDITION HAS BEEN DISABLED
	else
	local trans = info:match('trans')
	return trans and 'transport'
--	return trans and 'transport' or Get_TCP_MCP_Under_Mouse() and 'tcp' or 'arrange' // WORKS BUT FOREGOING THIS OPTION IN FAVOR OF OPENING LAST STORED LAYER WHEN NO VALID CONTEXT, OTHERWISE IF THE SCRIPT IS RUN FROM A TOOLBAR/MENU THE CONTEXT ALWAYS WILL BE EITHER TCP OR ARRANGE DEPENDING ON THE TOOLBAR/MENU LOCATION
	end

--[[UNUSED, FOR INFO
local cur_ctx = r.GetCursorContext2(x,y, true) -- click context, want_last_valid true meaning returns last context if current is invalid which seems mostly relevant over windows while the script is run with a global shortcut, because if the shortcut scope isn't global it's simply ignored over windows and the script doesn't run // 1 is transport as well
local tr, arrange, env = cur_ctx == 0, cur_ctx == 1, cur_ctx == 2
]]
-- item, take
-- mcp, tcp, fxlist, sendlist, fx, io, env, recmode, arrange (track level in Arrange), trans (trans.),
-- env 0, 1, 2, 3 etc - active (not selected) track or fx envelopes in the order of appearence; take envelopes aren't supported
-- fx_chain (over FX windows shortcut with Win modidier only works in global scope), fx_0, fx_1 (floating fx windows index accoridng to their order in the fx chain
-- MIDI piano roll, MIDI lanes
end



function GetRulerTimeUnit(main) -- main is boolean
-- thanks to Mespotine https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
-- https://github.com/mespotine/ultraschall-and-reaper-docs/blob/master/Docs/Reaper-ConfigVariables-Documentation.txt
-- can be extracted from the listed toggle actions state
local main_t = {
40365, -- Minutes:Seconds 40365
40366, -- Measures.Beats / Minutes:Seconds 40366
41918, -- Measures.Beats (minimal) / minutes:Seconds 41918
40367, -- Measures.Beats 40367
41916, -- Measures.Beats (minimal) 41916
40368, -- Seconds 40368
40369, -- Samples 40369
40370, -- Hours:Minutes:Seconds:Frames 40370
41973  -- Absolute Frames 41973
}
local second_t = {
42360, -- None 42360
42361, -- Minutes:Seconds 42367
42362, -- Seconds 42362
42363, -- Samples 42363
42364, -- Hours:Minutes:Seconds:Frames 42364
42365  -- Absolute Frames 42365
}
local t = main and main_t or second_t
	for k, ID in ipairs(t) do
	t[k] = r.GetToggleCommandStateEx(0, ID) == 1
	end
return t

end


function GetTransportTimeUnit(main) -- main is boolean
-- thanks to Mespotine https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
-- https://github.com/mespotine/ultraschall-and-reaper-docs/blob/master/Docs/Reaper-ConfigVariables-Documentation.txt
local main_t = {
40379, -- Use ruler time unit 40379
40410, -- Minutes:Seconds 40410
40534, -- Measures.Beats / Minutes:Seconds 40534
40411, -- Measures.Beats 40411
40412, -- Seconds 40412
40413, -- Samples 40413
40414, -- Hours:Minutes:Seconds:Frames 40414
41972  -- Absolute Frames 41972
}
local second_t = {
42366, -- None 42366
42367, -- Minutes:Seconds 42367
42368, -- Seconds 42368
42369, -- Samples 42369
42370, -- Hours:Minutes:Seconds:Frames 42370
42371  -- Absolute Frames 42371
}
local t = main and main_t or second_t
	for k, ID in ipairs(t) do
	t[k] = r.GetToggleCommandStateEx(0, ID) == 1
	end
return t

end


function Un_Set_MW_Config_Flags(TCP, focused_fx, all_faders, TCP_faders) -- TCP and focused_fx are booleans, all_faders, TCP_faders are for restoration
-- Preferences -> Editing behavior -> Mouse
-- 'Ignore mousewheel on all faders'
-- 'Ignore mousewheel on track panel faders'
-- Thanks to Mespotine
-- https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
	if not all_faders and not TCP_faders then -- clear flags
	local MW_mode = r.SNM_GetIntConfigVar('mousewheelmode', 0)
	local all_faders, TCP_faders = MW_mode&2 == 2, MW_mode&4 == 4
-- https://stackoverflow.com/questions/63158929/how-can-i-clear-multiple-bits-at-once-in-c
	local MW_mode_new = all_faders and TCP_faders and TCP and MW_mode&~2&~4 -- or MW_mode&~(2|4)
	or all_faders and focused_fx and MW_mode&~2 or TCP_faders and TCP and MW_mode&~4
	local unset = MW_mode_new and r.SNM_SetIntConfigVar('mousewheelmode', MW_mode_new)
	return all_faders, TCP_faders
	else -- re-enable flags
	local MW_mode = r.SNM_GetIntConfigVar('mousewheelmode', 0)
	local MW_mode_new = all_faders and TCP_faders and TCP and MW_mode|2|4
	or all_faders and focused_fx and MW_mode|2 or TCP_faders and TCP and MW_mode|4
	local unset = MW_mode_new and r.SNM_SetIntConfigVar('mousewheelmode', MW_mode_new)
	end
end


function Get_Mousewheel_Mode()
-- Preferences -> Editing behavior -> Mouse
-- 'Ignore mousewheel on all faders'
-- 'Ignore mousewheel on track panel faders'
-- Thanks to Mespotine
-- https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
-- get_config_var_string() can be used instead of io.open()
local f = io.open(r.get_ini_file(),'r')
local cont = f:read('*a')
f:close()
local val = cont:match('mousewheelmode=(%d+)\n')
local all_faders, TCP_faders = val+0&2 == 2, val+0&4 == 4 -- +0 is accommodating for Lua 5.4 where implicit conversion of strings to integers doesn't work in bitwise operations
return all_faders, TCP_faders
end


-- Can be used in defer functions to prevent script activity in project tabs other than the one it was launched under
-- when the project is switched the script will terminate
proj_init, projfn_init = r.EnumProjects(-1)
function RUN1()
local proj, projfn = r.EnumProjects(-1)
-- MAIN CODE
--	if projfn == projfn_init then -- this won't work in tabs without saved project
	if proj == proj_init then
	defer(RUN)
	end
end


-- to keep the script running without execution
function RUN2()
local proj, projfn = r.EnumProjects(-1)
--	if projfn == projfn_init then -- this won't work in tabs without saved project
	if proj == proj_init then
	-- MAIN CODE
	end
defer(RUN)
end


-- to be able to run the script exclusively under the project it's been originally launched under and re-link it to another project by toggling Master track visibility in TCP, including to re-link automatically after the orig proj has been closed
IGNORE_OTHER_PROJECTS = "1"
IGNORE_OTHER_PROJECTS = #IGNORE_OTHER_PROJECTS:gsub(' ','') > 0
proj = r.EnumProjects(-1) -- -1 current, project the script was launched under
local new_tab, master_vis = proj
function Link_To_New_Project()
-- if orig proj tab has been closed
local i = 0
	repeat
	local p = r.EnumProjects(i)
		if p == proj then return end -- original project is still open
	i = i+1
	until not p
return r.EnumProjects(-1) -- original project wasn't found, switch to currently open
end
function RUN()
-- re-ordering proj tabs doesn't affect linkage
proj = IGNORE_OTHER_PROJECTS and r.EnumProjects(-1) ~= proj and Link_To_New_Project() or proj -- switch to currently open proj if the orig one wasn't found

	if IGNORE_OTHER_PROJECTS then
		if r.EnumProjects(-1) ~= new_tab then -- another project tab, store its current Master track visibility
		master_vis = r.GetMasterTrackVisibility()&1 -- store current Master track visibility under new tab
		new_tab = r.EnumProjects(-1) -- update to make this condition false in subsequent cycles
		elseif master_vis and master_vis ~= r.GetMasterTrackVisibility()&1 then -- re-link to another project if its Master track visibility has been toggled
		proj, master_vis = r.EnumProjects(-1), nil -- update project, reset Master track visibility status
		end
	end

	if IGNORE_OTHER_PROJECTS and r.EnumProjects(-1) == proj or not IGNORE_OTHER_PROJECTS then
	-- MAIN CODE
	end
defer(RUN)
end



function monitor_defer_loop_update_rate()
	if r.time_precise() ~= last_t then
		if last_t then Msg(r.time_precise()-last_t) end
	last_t = r.time_precise()
	end
end



function Note_Format_Check(note) -- string
-- note is either whole 1,2,3 etc or fractional 1/2, 3/4, 7/12 etc
	for i = 1, 8 do
	local denom = 2^i -- straight note value in all major note divisions is a power of 2
	local straight = tostring(denom):match('(.+)%.') -- truncating decimal 0 with string function
	local triplet = tostring(denom+denom/2):match('(.+)%.') -- a triplet note denominator is a sum of straight note denominator + half of the straight note denominator: 1/3 = 1/2 + 1; 1/6 = 1/4 + 2; 1/12 = 1/8 + 4; 1/24 = 1/16 + 8; 1/48 = 1/32 + 16; 1/96 = 1/64 + 32
		if note:match('%-?%d+/'..straight) or note:match('%-?%d+/'..triplet)
		or tonumber(note) and tonumber(note) == math.floor(tonumber(note)) -- whole
		then
		return true end
	end
return note:match('^/$')
end


function Custom_Horiz_Scroll(x, y, SEC, VALUE, mousewheel_dir, mousewheel_reverse, auto_zoom) -- x and y are integers representing the number of pixels; mousewheel_reverse, auto_zoom are boolean // relies on the round() function, Horiz_Scroll_Distance() function for x value and r.get_action_context() for mousewheel_dir ('val' return value) as this function doesn't work inside a user function !!! SEC and VALUE are passed to Horiz_Scroll_Distance() function below (SEC is boolean to use seconds as scroll unit when VALUE is in seconds; otherwise musical division)

-- in CSurf_OnScroll() minimum possble x step is 16 px, not 1 px; minimum possble y step is 8 px; each next increment adds 16 or 8 px respectively, so the input value is multiplied by 16 or 8, e.g. value 16 means 256 px = 16 x 16

--local is_new_value,filename,sectionID,cmdID,mode,resolution,val = r.get_action_context() -- if mouse scrolling up val = 15 - righwards, if down then val = - 15 - leftwards // THE FUNCTION DOESN'T WORK WITHIN A USER FUNCTION
--Msg(val, 'VAL')

local val = mousewheel_dir -- 15 or -15

	if mousewheel_reverse then
	val = val > 0 and -1 or val < 0 and 1 -- down (forward) - leftwards or up (backwards) - rightwards
	else -- default
	val = val > 0 and 1 or val < 0 and -1 -- down (forward) - rightwards or up (backwards) - leftwards
	end

local x = x < 16 and 0 or round(x/16) -- either round up to 1 since pixels cannot be fractional or keep the value, or keep 0 if that's what was passed as the argument
local y = y < 8 and 0 or round(y/8) -- same

-- Auto-zoom in or prompt to zoom in

	if x == 0 and auto_zoom then -- INCREMENT setting is too fine for the current zoom amount (minimum possible for horizontal scroll is 16 px as per the limit of CSurf_OnScroll() function), so zoom in until it fits
	r.Main_OnCommand(40514,0) -- View: Move edit cursor to mouse cursor (no snapping) // centermode arg of adjustZoom() function is only known to support default setting of Preferences -> Editing Behavior -> Horizontal zoom center; what integer makes it hone in on the mouse cursor is not documented, hence the use of the edit cursor to point to the mouse cursor // overall seems to work with mouse cursor as the zoom center if either edit or mouse cursor are set in the Preferences, center view doesn't seem to work well with the routine

		repeat -- zoom in until the resolution is sufficient
		r.adjustZoom(5, 0, true, -1) -- amt, forceset, doupd, centermode // HORIZONTAL ZOOM ONLY // amt > 0 zooms in, < 0 zooms out, the greater the value the greater the zoom; forceset ~= 0 zooms out, if amt value is 1 then zooms out fully, if amt is greater then depends on the amt value but the relationship isn't clear, if bound to mousewheel, amt must be modified by val return value of get_action_context() function to change direction of the zoom, positive IN, negative OUT; doupd false no zoomming; centermode ?????
		-- forceset=0,doupd=true (do update),centermode=-1 for default
		until Scroll_Distance(SEC, VALUE) >= 16 -- minimum required for horizontal scroll in CSurf_OnScroll()

	elseif x == 0 then -- when auto_zoom is false
	Error_Tooltip('\n\n     low resolution, \n\n zoom in horizontally. \n\n')
	end

r.CSurf_OnScroll(x*val,y*val)

end


function Mouse_Wheel_Direction(val, mousewheel_reverse) -- mousewheel_reverse is boolean
local is_new_value,filename,sectionID,cmdID,mode,resolution,val = r.get_action_context() -- if mouse scrolling up val = 15 - righwards, if down then val = -15 - leftwards // val seems to not be able to co-exist with itself retrieved outside of the function, in such cases inside the function it's returned as 0; if there's another function which includes this function in one of them it won't work properly so the val will have to be taken outiside of both functions and used as an argument in them
-- THE FUNCTION DOESN'T TAKE INTO ACCOUNT MOUSE CLICK WHICH IS ASSOCIATED WITH val 63
-- and will trigger wheel up (forward) action
	if mousewheel_reverse then
	return val > 0 and -1 or val < 0 and 1 -- wheel up (forward) - leftwards/downwards or wheel down (backwards) - rightwards/upwards
	else -- default
	return val > 0 and 1 or val < 0 and -1 -- wheel up (forward) - rightwards/upwards or wheel down (backwards) - leftwards/downwards
	end
end
-- USE:
-- dir = Mouse_Wheel_Direction(val, mousewheel_reverse)
-- if dir > 0 then DO STUFF
-- elseif dir < 0 then DO OTHER STUFF
-- end


function Process_Mouse_Wheel_Direction1(val, mousewheel_reverse) -- mousewheel_reverse is boolean
local is_new_value,filename,sectionID,cmdID,mode,resolution,val = r.get_action_context() -- if mouse scrolling up val = 15 - righwards, if down then val = -15 - leftwards // val seems to not be able to co-exist with itself retrieved outside of the function, in such cases inside the function it's returned as 0; if there's another function which includes this function in one of them it won't work properly so the val will have to be taken outiside of both functions and used as an argument in them
-- if mouse scrolling up val = 15 - righwards, if down then val = -15 - leftwards
-- THE FUNCTION DOESN'T TAKE INTO ACCOUNT MOUSE CLICK WHICH IS ASSOCIATED WITH val 63
-- and will trigger wheel up (forward) action
return mousewheel_reverse and val > 0 or val < 0, -- wheel in/down/backwards = leftwards/downwards
mousewheel_reverse and val < 0 or val > 0 -- -- wheel out/up/forward = rightwards/upwards
end
-- USE:
-- left_down, right_up = Process_Mouse_Wheel_Direction(val, mousewheel_reverse)


function Process_Mouse_Wheel_Direction2(val, mousewheel_reverse)
-- val comes from r.get_action_context()
-- mousewheel_reverse is boolean
-- if mouse scrolling up val = 15 - righwards, if down then val = -15 - leftwards
-- THE FUNCTION DOESN'T TAKE INTO ACCOUNT MOUSE CLICK WHICH IS ASSOCIATED WITH val 63
-- and will trigger wheel up (forward) action
--[[INEFFICIENT
return mousewheel_reverse and val > 0 or not mousewheel_reverse and val < 0, -- wheel in/down/backwards = leftwards/downwards
mousewheel_reverse and val < 0 or not mousewheel_reverse and val > 0 -- -- wheel out/up/forward = rightwards/upwards
end
]]
local left_down, right_up = table.unpack(mousewheel_reverse and {val > 0, val < 0} or {val < 0, val > 0}) -- left/down, right/up
return left_down, right_up
end



function Process_Mousewheel_Sensitivity(val, cmdID, MOUSEWHEEL_SENSITIVITY, percent, MOUSEWHEEL)
-- val & cmdID stem from r.get_action_context()
-- MOUSEWHEEL_SENSITIVITY unit is one mousewheel nudge, normally a single scroll consists of 5-6 nudges
-- percent is boolean if the sensitivity is measured in pecentage rather than in mousewheel nudges count,
-- i.e. 1 = 100% (1 nudge), 0.5 = 50% (2 nudges), 0.3 = 30% (3 nudges), 0.25 = 25% (4 nudges), 0.2 = 20% (5 nudges) etc
-- the lower the less sensitive in contrast with nudges count
local MW_sens = MOUSEWHEEL_SENSITIVITY
MW_sens = MW_sens:gsub(' ','')
MW_sens = tonumber(MW_sens) and (percent and MW_sens+0 < 1 and math.abs(MW_sens+0)
or not percent and MW_sens+0 > 1 and math.floor(math.abs(MW_sens+0)))
MW_sens = MW_sens and (percent and 1/MW_sens or MW_sens) or 1
--MW_sens = MOUSEWHEEL and val == 63 and 1 or MW_sens -- if mousewheel and mousewheel sensitivity are enabled but the script is run via a shortcut (val returned by get_action_context() is 63), disable the mousewheel sensitivity otherwise if it's greater than 4 the script won't be triggered at the first run because the expected value will be at least 5x15 = 75 (val returned by get_action_context() is ±15) while val will only produce 63 per execution, it will only be triggered on the next run since 63x2 = 126 > 75
	if MOUSEWHEEL_SENSITIVITY == 1 then return true end -- no scaling
local cmdID = r.ReverseNamedCommandLookup(cmdID) -- command ID differs in different Action list sections
local data = r.GetExtState(cmdID, 'MOUSEWHEEL')
data = #data == 0 and 0 or data+0
local diff_sign = data > 0 and val < 0 or data < 0 and val > 0
local val = diff_sign and val or data+val -- when the stored and current vals have diff signs, reset to prevent values offsetting which results in higher sensitivity when scroll direction is reversed, e.g. when sensitivity is 10, if scroll direction after 5 changes, the script will be triggered after only 5 nudges (5-5=0) instead of 10
--[[ WORKS, substituted with 2 lines below marked NEW, to prevent frequent deletion of the ext state as it seems unnecessary
	if #data ~= 0 and math.abs((data+val)/MOUSEWHEEL_SENSITIVITY) >= 15 then -- +val to accound for the latest event, otherwise the switch will only occur on the next
	r.DeleteExtState(cmdID, 'MOUSEWHEEL', true) -- persist true
	return true end -- 1 mousewheel nudge equals 15 or -15 depending on direction
--]]
val = math.abs(val/MOUSEWHEEL_SENSITIVITY) >= 15 and 0 or val -- NEW instead of the statement commented out above
r.SetExtState(cmdID, 'MOUSEWHEEL', val, false) -- persist false
return val == 0 -- NEW instead of the statement commented out above
end
--[[ USE:

MOUSEWHEEL_SENSITIVITY = MOUSEWHEEL_SENSITIVITY:gsub(' ','')
MOUSEWHEEL_SENSITIVITY = tonumber(MOUSEWHEEL_SENSITIVITY) and tonumber(MOUSEWHEEL_SENSITIVITY) > 1 and math.floor(math.abs(tonumber(MOUSEWHEEL_SENSITIVITY))) or 1

MOUSEWHEEL_SENSITIVITY = not MOUSEWHEEL and val == 63 and nil or MOUSEWHEEL_SENSITIVITY = MOUSEWHEEL and val == 63 and 1 or MOUSEWHEEL_SENSITIVITY -- if mousewheel and mousewheel sensitivity are enabled but the script is run via a shortcut (val returned by get_action_context() is 63), disable the mousewheel sensitivity otherwise if it's greater than 4 the script won't be triggered at the first run because the expected value will be at least 5x15 = 75 (val returned by get_action_context() is ±15) while val will only produce 63 per execution, it will only be triggered on the next run since 63x2 = 126 > 75 -------- IF THIS EXPRESSION IS USED THE WARNING MESSAGE BELOW IS REDUNDANT, BECAUSE IT DISABLES SENSITIVITY IF SCRIPT IS RUN WITH A SHORTCUT

	if MOUSEWHEEL and MOUSEWHEEL_SENSITIVITY > 4 and val == 63 then -- val stems from r.get_action_context() // val is ±15 when mousewheel is used and 63 in all other cases (excluding MIDI), when mousewheel is enabled and its sensitivity setting is 5 the expected sum to trigger action is 15x5 = 75, therefore if the script is not run with the mousewheel the action won't be triggered due to 63 being less than 75, but it will on the next run since 63x2 = 126 > 75, if the sensitivity is 4, that is 15x4 = 60, and the first run produces 63 this will be enough to trigger action
	local function s(n) return (' '):rep(n) end
	Error_Tooltip('\n\n'..s(4)..'since the script is executed \n\n\t'..s(6)..'with a shortcut \n\n while the mousewheel is enabled \n\n\t'..s(4)..'and its sensitivity \n\n\t'..s(5)..'is greater than 4, \n\n  it won\'t work at the first run \n\n',1,1) -- caps, spaced true
	end

if Process_Mousewheel_Sensitivity(val, cmdID, MOUSEWHEEL_SENSITIVITY) then
--DO STUFF
end

--]]


local is_new_value,filename,sectionID,cmdID,mode,resolution,val = r.get_action_context()-- if mouse scrolling up val = 15 - righwards, if down then val = -15 - leftwards // the function must be outside as it cannot work properly inside more than 1 user function, in which case val will be 0
function Mousewheel_Or_Shortcut(val)
return val == math.abs(15) or mode == 1, val == 63 or mode == 0 -- mousewheel, shortcut
end


function Is_Mousewheel(mode)
return val == math.abs(15) or mode == 1 -- mousewheel, when sctipt is run with a shortcut val is 63, mode is 1
end


function Is_Not_Relative_Mode()
-- exclude mouse clicks or absolute mode as script trigger
-- for scripts which need to be be run with mousewheel or MIDI message with relative scale
-- that is those whose functionality depends on the received value
local is_new_value, scr_name, sect_ID, cmd_ID, mode, resol, val, contextstr = r.get_action_context()
	if mode == 0 then
	Error_Tooltip('\n\n\tthe script must be \n\n    run with a mousewheel \n\n or MIDI CC in relative mode \n\n', 1, 1, -200, 20) -- caps, spaced true, x2 -200, y2 20 // placing the tooltip away from mouse cursor in case the script is run with a click otherwise tooltip blocks next mouse event
	return true
	end
end
-- USE:
--	if Is_Not_Relative_Mode() then return r.defer(no_undo) end


function format_time_given_in_sec(num_sec) -- same as reaper.format_timestr()
	local function add_lead_zero(num)
	return #(num..'') == 1 and '0'..num or num
	end
local hrs = math.modf(num_sec/3600) -- 3600 sec in an hour
local sec = num_sec%3600 -- remainder in sec
local mnt = math.modf(sec/60) -- 60 sec in a min
local sec_ms = sec%60 -- remainder in sec and ms as a decimal part
local dec_places = 10^3
local sec_ms = math.floor(sec_ms * dec_places + 0.5) / dec_places -- round ms down to 3 dec places
local col = ':'
return add_lead_zero(hrs)..col..add_lead_zero(mnt)..col..sec_ms
end


function Time_in_Sec_to_List(time_in_sec, sep) -- sep is a string of a character to be used as a separator, if ommitted comma will be used
local sep = sep or ','
local time_in_sec = r.format_timestr(time_in_sec, '')
local min, sec, ms = time_in_sec:match('(%d+):(%d+)%.(%d+)') -- min, sec and ms are always included in format_timestr() return value
local hr = time_in_sec:sub(1,-#(':'..min..':'..sec..'.'..ms)-1) or ''
-- OR
-- local hr = edit_curs_pos:match('(%d+):'..min..':'..sec..'.'..ms) or ''
--local sep = ';' -- since semicolon is used in the GetUserInputs() as fields separator to be able to catch decimal entries, which are invalid, and truncate
return hr..sep..min..sep..sec..sep..ms -- to autofill the dialogue
end



function Ad_Hoc_Setting()
-- used in Scroll horizontally and;or move loop and;or time selection by user defined interval.lua
local x, y = r.GetMousePosition()
	if x <= 100 and y <= 100 then
	local retval, output = r.GetUserInputs('AD-HOC INCREMENT SETTING, default: '..incr_default, 1, 'extrawidth=25,Type in value ( musical or sec )', (INCREMENT ~= incr_default and INCREMENT or '')) -- only autofill if the value is different from the default set in the USER SETTINGS
	local output = output:gsub('[%s%c]','')
		if #output > 0 then
			if output:match('^[Xx]+') then -- remove ad-hoc INCREMENT setting to go back to the one defined in the script
			r.DeleteExtState(cmdID, 'INCREMENT', true) -- persist true
			else
			output = output:match('^[1-9/]+') and output or '1/4' -- if 0 or non-numeric input use default which is 1 beat
				if output ~= INCREMENT then -- only store if different from the default or previously stored ad-hoc INCREMENT setting
				r.SetExtState(cmdID, 'INCREMENT', output, false) -- store ad-hoc increment setting // persist false
				end
			end
		end
	end
end
Ad_Hoc_Setting()
return r.defer(function() do return end end) end


function Get_Lock_Settings1() -- see Get_Lock_Settings2() below which doesn't rely on SWS extension
-- thanks to Mespotine https://mespotin.uber.space/Ultraschall/Reaper_Config_Variables.html
-- https://github.com/mespotine/ultraschall-and-reaper-docs/blob/master/Docs/Reaper-ConfigVariables-Documentation.txt

	if not r.APIExists('SNM_GetIntConfigVar') then return end -- no SWS extension

local bitfield = r.SNM_GetIntConfigVar('projsellock', -1)

local disabled = bitfield < 16384 -- OR 2^14, global lock is disabled, if no flag is set it cannot be enabled
local no_flags = bitfield == 16384 -- 'Enable locking' flag is set with no other flags checked, in this case lock (Options: Toggle locking) cannot be enabled; when at least one other flag is set 'Enable locking' flag is toggled with 'Options: Toggle locking' action

local t = {}
	for i = 0, 12 do
	t[#t+1] = bitfield & 2^i == 2^i
	end

-- 1 time selection, 2 items full, 4 track envelopes, 8 markers, 16 regions, 32 time sig markers
-- 64 items (left/right move), 128 items (up/down move), 256 item edges, 512 item fade/vol handles
-- 1024 loop points, 2048 take envelopes, 4096 item stretch markers

return disabled, no_flags, table.unpack(t) -- 15 return values

end
-- GETTING OUTPUT:
-- local disabled, no_flags, time_sel, itms_full, tr_env, proj_mrk, rgn, time_sig_mrk, itm_horiz_move, itm_vert_move, itm_edges, itm_fade_vol_hand, loop_pts, take_env, stretch_mrk = Get_Lock_Settings1()


function Get_Lock_Settings2()
local cmd_t = {
1135, -- Options: Toggle locking // always Off when there're no set flags
-- and cannot be set to On without at least one flag being set

-- 0, -- placeholder for no_flags var // USELESS because when lock (above action)
-- isn't enabled the following toggle actions don't report the state of their flags
-- so it's impossible to find which flags are set unless lock is enabled,
-- when no flag is set lock cannot be enabled

-- all following actions are On ONLY if 'Options: Toggle locking' is On
-- they don't report On state when their flag is set but the lock isn't enabled
-- when lock isn't enabled toggling them to On automatically enables lock
40573, -- Locking: Toggle time selection locking mode
40576, -- Locking: Toggle full item locking mode
40585, -- Locking: Toggle track envelope locking mode
40591, -- Locking: Toggle marker locking mode
40588, -- Locking: Toggle region locking mode
40594, -- Locking: Toggle time signature marker locking mode
40579, -- Locking: Toggle left/right item locking mode
40582, -- Locking: Toggle up/down item locking mode
40597, -- Locking: Toggle item edges locking mode
40600, -- Locking: Toggle item fade/volume handles locking mode
40629, -- Locking: Toggle loop points locking mode
41851, -- Locking: Toggle take envelope locking mode
41854 -- Locking: Toggle item stretch marker locking mode
}

	for i, cmd_ID in ipairs(cmd_t) do
	cmd_t[i] = r.GetToggleCommandStateEx(0, cmd_ID) == 1
	end

return table.unpack(cmd_t) -- 14 return values

end
-- GETTING OUTPUT:
-- local enabled, time_sel, itms_full, tr_env, proj_mrk, rgn, time_sig_mrk, itm_horiz_move, itm_vert_move, itm_edges, itm_fade_vol_hand, loop_pts, take_env, stretch_mrk = Get_Lock_Settings2()



function Get_Region_Marker_Mngr_Settings1()
-- https://forum.cockos.com/showthread.php?p=2822621
local sett_flags, sort_flag
	for line in io.lines(r.get_ini_file()) do
		if line == '[regmgr]' then found = 1
		elseif found then
		sett_flags = sett_flags or line:match('flags=(.+)')
		sort_flag = sort_flag or line:match('sort=(.+)')
			if sett_flags and sort_flag then break end
		end
	end
sett_flags = tonumber(sett_flags)
local t = {}
	-- the power values are arranged in the order of settings reflected in the list below
	for k,  power in ipairs({0,1,7,8,10,9,6,2,5}) do
	local bit = 2^power
	-- some flags are set when the setting is disabled
	-- therefore inequality must be evaluated rather than equality
		if power == 0 or power == 7 or power == 9 or power == 5 then
		t[k] = sett_flags&bit == bit
		else -- flags which are set when the setting is disabled
		-- but since we're collecting truth when a setting is enabled
		-- what's evaluated is inequality, which will be true when a setting is enabled
		t[k] = sett_flags&bit ~= bit
		end
	end
--[[ the order or the settings in the table, follows the order in Manager from top to bottom:
'flags' key
Markers: 1 - unchecked false, checked true
Regions: 2 - unchecked true, checked false
Take markers: 128 - unchecked false, checked true
List markers, regions and take markers separately: 256 - unchecked true, checked false
Only display visible take markers in active takes: 1024 - unchecked true, checked false
Add/remove child tracks to render list when adding/removing folder parent: 512 - unchecked false, checked true
Show track render dropdown list nested by folders: 64 - unchecked true, checked false
Seek playback when selecting a marker or region: 4 - unchecked true, checked false
Play region through then repeat or stop when selecting a region: 32 - unchecked false, checked true
'sort' key
sort flag
0 - color descending by HSV value https://forum.cockos.com/showthread.php?p=2822865
1 - index ascending
2 - name ascending
3 - start ascending
4 - end ascending
5 - length ascending
6 - render track list descending
7 - info descending
16 - color ascending by HSV value
17 - index descending
18 - name descending
19 - start descending
20 - end descending
21 - length descending
22 - render track list ascending
23 - info descending
]]
return t, sort_flag -- in the table the setting is true if enabled and false if disabled
end



function Get_Region_Marker_Mngr_Settings2()
-- https://forum.cockos.com/showthread.php?p=2822621
local found, flags, sorting
	for line in io.lines(r.get_ini_file()) do
		if line == '[regmgr]' then found = 1
		elseif found then
		flags = flags or line:match('flags=(%d+)')
		sorting = sorting or line:match('sort=(%d+)')
		elseif flags and sorting then break
		end	
	end
local flags_t = {
[1]=1, -- Markers
[2]=2, -- Regions
[3]=4, -- Seek playback when selecting a marker or region
[4]=32, -- Play region through then repeat or stop when selecting a region
[5]=64, -- Show track render dropdown list nested by folders
[6]=128, -- Take markers
[7]=256, -- List markers, regions and take markers separately
[8]=512, -- Add/remove child tracks to render list when adding/removing folder parent
[9]=1024 -- Only display visible take markers in active takes
}
	for k, bit in ipairs(flags_t) do
	-- bits 1, 32, 128, 512 are set when the setting is enabled
	-- the rest are set when the corresponding setting is disabled
	local exp = math.log(bit)/math.log(2)
	flags_t[k] = (exp == 0 or exp > 1 and exp%2 ~= 0) and (flags+0)&bit == bit -- exp 0,5,7,9
	or (exp==1 or exp > 0 and exp%2 == 0) and (flags+0)&bit ~= bit -- exp 1,2,6,8,10
	end
local sort_t = {[0]='col desc',[1]='index asc',[2]='name asc',[3]='start asc',
[4]='end asc',[5]='len asc',[6]='rend track list desc',[7]='info desc',
[16]='col asc',[17]='index desc',[18]='name desc',[19]='start desc',
[20]='end desc',[21]='len desc',[22]='rend track list asc',[23]='info asc'}
return flags_t, sort_t[sorting+0]
end



function Get_Media_Explorer_Show_Submenu_Options(bitfield)
-- bitfield stems from Check_reaper_ini() with section arg '[reaper_explorer]'
-- and key arg 'displayall'
-- evaluates whether option is enabled
-- so enabled true, disabled false

local bitfield = not bitfield and Check_reaper_ini('reaper_explorer', 'displayall')

	if bitfield+0 == 1228 then return end -- all are disabled

local opts = {
-- unused bits: &16, &512
-- values are logarithm for base 2
[1]=0, -- All files // &1
[2]=7, -- Folders // &128 disabled
[3]=6, -- File extension even when file type displayed // &64 disabled

-- next two options are mutually exclusive but both can be turned off
[4]=2, -- Leading path in databases and searches // &4 disabled
[5]=8, -- Full path in databases and searches // &256 disabled

[6]=3, -- Path drop-down box // &8 disabled
[7]=10, -- Scrollbars on preview waveform // &1024 disabled
[8]=11, -- Automatically expand shortcuts while browsing file list // &2048 disabled
[9]=12, -- Display preview position in beats for audio files, using embedded or estimated tempo // &4096 disabled
[10]=1, -- Display preview position in wholes seconds and beats // &2
}
	for k, exp in ipairs(opts) do
	local bit = 2^exp
	-- only for two options bits are set when they are enabled
	-- for the rest bits are set when they're disabled
	opts[k] = exp < 2 and bitfield+0&bit == bit or exp > 1 and bitfield+0&bit ~= bit
	end
return opts

-- view= 0 -- columns (Details), 1 -- List (file/folder names onky)

end



function Get_Media_Explorer_Column_Count()
-- as of build 7.22 default column count is 25
-- on top of which custom user columns may exist
-- when column is hidden its value in reaper.ini is 0
-- in the format colX=0 where X is a column 0-based index
-- whether default or user column
-- hidden columns are still accessible to window functions
-- so to find an item all must be traversed

local hidden_col_count, total_col_cnt, found = 0, 25
	for line in io.lines(r.get_ini_file()) do
		if line == '[reaper_explorer]' then found = 1
		elseif found then
			if line:match('col%d+=0') then
			hidden_col_count = hidden_col_count+1
			elseif line:match('user%d+_key=') then
			total_col_cnt = total_col_cnt+1 -- adding user colums to the total
			end
			if line:match('%[.-%]') then -- new section
			break end
		end
	end

return total_col_cnt, total_col_cnt - hidden_col_count -- total and visible

end



function MediaExplorer_OnCommand1(action_cmdID, close_when_done)
-- https://forum.cockos.com/showthread.php?p=2863268
-- if the MX is initially closed the triggered action 
-- is likely to not take effect after MX window opens
-- because it's slow to become active compared to the speed
-- of the script execution, therefore defer loop will
-- have to be employed to wait until it's fully active
-- see defer loop version below MediaExplorer_OnCommand2()

local action_cmdID = r.NamedCommandLookup(action_cmdID) -- works with numeric command IDs of native action as well
local MX = r.OpenMediaExplorer('', false) -- play false

	if MX then
		if r.BR_Win32_SendMessage then
		r.BR_Win32_SendMessage(MX, 0x0111, action_cmdID, 0) -- 0x0111 is 'WM_COMMAND'
		elseif r.JS_WindowMessage_Send then
		r.JS_WindowMessage_Send(MX, 'WM_COMMAND', action_cmdID, 0, 0, 0)
		end
		if close_when_done then -- Close
		r.Main_OnCommand(50124,0) -- 'Media explorer: Show/hide media explorer'
		end
	end

end



-- these must either be global variables to be recognized inside the defer loop
-- or passed as arguments if the function is run via Wrapper function 
-- (see in this U T I L I T Y section)
action_cmdID = ''
close_when_done = true
function MediaExplorer_OnCommand2()
-- https://forum.cockos.com/showthread.php?p=2863268

	if not time_init and r.GetToggleCommandState(50124) == 0 then -- Media explorer: Show/hide media explorer // Open
	r.Main_OnCommand(50124,0) -- 'Media explorer: Show/hide media explorer'
	time_init = r.time_precise()	
	elseif time_init and r.time_precise()-time_init >= 0.1 then
	local MX = r.OpenMediaExplorer('', false) -- play false
	local action_cmdID = r.NamedCommandLookup(action_cmdID) -- works with numeric command IDs of native actions as well
		if r.BR_Win32_SendMessage then
		r.BR_Win32_SendMessage(MX, 0x0111, action_cmdID, 0) -- 0x0111 is 'WM_COMMAND'
		elseif r.JS_WindowMessage_Send then
		r.JS_WindowMessage_Send(MX, 'WM_COMMAND', action_cmdID, 0, 0, 0)			
		end
		if close_when_done then -- Close
		r.Main_OnCommand(50124,0) -- 'Media explorer: Show/hide media explorer'
		end
	return
	end
	
r.defer(MediaExplorer_OnCommand2)

end




function trackselonmouse()
-- 'trackselonmouse' key of the preference at
-- Prefs -> Editing behavior -> Mouse -> Mouse click/edit in arrange view: Selects track... Sets target track for insert/paste...
-- 9 only 'Selects track' is enabled, both in reaper.ini and with get_config_var_string()
-- 0 only 'Sets target track for insert/paste' is enabled, both in reaper.ini and with get_config_var_string()
-- 8 none is enabled, both in reaper.ini and with get_config_var_string()
-- doesn't exist in reaper.ini if both 'Selects track' and 'Sets target track for insert/paste' are enabled
-- but is equal to 1 when retrieved with get_config_var_string()
local ret, int = reaper.get_config_var_string('trackselonmouse')
reaper.ShowConsoleMsg(tostring(ret)..'\n')
reaper.ShowConsoleMsg(int..'\n')
local respect = #RESPECT:gsub(' ','') > 0
return respect and (int == '1' or int == '9') or not respect
end



function generate_custom_action_ID()
-- the ID is a GUID, thanks to schwa https://forums.cockos.com/showthread.php?t=291057#12
-- https://stackoverflow.com/a/2867925/8883033 how GUID is constructed
return r.genGuid(''):lower():gsub('[%-{}]+','') -- convert to lower register and remove hyphens and curly brackets
end



function en_de_code_bitfield(t, bitfield)
-- only stores the max of 63 values on a 64 bit systems
-- and 52 on 32 bit systems
-- https://stackoverflow.com/questions/46442411/how-big-can-a-64-bit-unsigned-integer-be
-- https://stackoverflow.com/questions/6003492/how-big-can-a-64bit-signed-integer-be

local limit = math.maxinteger == 9223372036854775807 and 63 or 52 -- OR math.maxinteger == 2^63 // setting the limit depending on the system bit width, because a max signed integer Lua v5.3+ can handle on a 32 bit system is 9007199254740991 or 0x1fffffffffffff, i.e. 2^53-1, in practical terms of conversion into hex value with dec2hex() function it's 2^52 0xfffffffffffff which prevents loss of precision, so the function can store a max of first 52 boolean thruths, while on a 64 bit system it's 9223372036854775807 or 0x7fffffffffffffff, i.e. 2^63, and a max of first 63 boolean thruths // only a max of FIRST 63 or 52 boolean thruths respectively can be stored because the storage depends on the index of the truth in the sequence which corresponds to the bit position in the bitfield, and depending on the system the integer created by bit setting cannot exceed 2^63 or 2^52 respectively // using numbers here to avoid calculation of rasing to power

local s = ' '

	if not bitfield then -- encode
	local bitfield = 0
		for k, truth in ipairs(t) do
			if truth then
				-- must be placed before bit setting in case the limit has been reached while there're still unaccounted for disabled actions, if it were placed after the setting it wouldn't be possible to ascertain that there're unaccounted for disabled actions because that could have been the loop end, so a counter would have to be employed
				if k > limit then return
			-- OR
			--	if bitfield == 9223372036854775807 then return -- only valid for 64 bit system
				s:rep(7)..'The system doesn\'t support\n\n'..s:rep(8)..'storage of disabled actions'
				..'\n\n'..s:rep(9)..'at index greater than '..limit..'.'
				end
			bitfield = bitfield|2^(k-1)
			end
		end
	return bitfield
	else -- decode
		for k, truth in ipairs(t) do
		local bit = 2^(k-1)
			if bitfield&bit == bit then
			act_names_menu_t[k] = true
			end
		end
	return t
	end
end
-- USE:
-- local bitfield = en_de_code_bitfield(t) -- encode
-- local t = en_de_code_bitfield(t, bitfield) -- decode


function Action_list_sections()
-- consists of bits used in https://forum.cockos.com/showthread.php?p=2883303#post2883303

-- srore section IDs
local sectionIDs_t = {}
	for i=0,15 do -- Main and Main (alt)
	sectionIDs_t[#sectionIDs_t+1] = i
	end
	
local non_Main = {100, 32060, 32061, 32062, 32063, 32064}	
	for k, v in ipairs(non_Main) do
	sectionIDs_t[#sectionIDs_t+1] = v
	end

-- store section names
local sect_names = {}
	for i=0,16 do -- Main and Main (alt)
	sect_names[i] = i==0 and 'Main' or 'Main (alt-'..i..')'
	end

local sect_names_non_Main = {[100]='Main (alt recording)', [32060]='MIDI Editor', 
[32061]='MIDI Event List Editor', [32062]='MIDI Inline Editor', 
[32063]='Media Explorer', [32064]='Crossfade Editor'}

	for k, name in pairs(sect_names_non_Main) do
	table.insert(sect_names, k, name)
	-- OR
	-- sect_names[k] = name
	end

return sectionIDs_t, sect_names

end



function Generate_list_of_notes()

local notes_t = {}

	for i=65,71 do -- from A to G in ASCII codes
	notes_t[#notes_t+1] = string.char(i)
	end
	
	for i=1,#notes_t do -- move A and B to the end of the table
	table.insert(notes_t,notes_t[1])
	table.remove(notes_t,1)
		if i==2 then break end
	end	
	
	for i = #notes_t,1,-1 do -- add accidentals
	-- accidentals are added in two variations within the same entry
	-- separated by slash
		if i == 7 or i == 6 or i == 5 or i == 3 or i == 2 then
		local accidental = notes_t[i-1]..'#/'..notes_t[i]..'b'
		table.insert(notes_t, i, accidental)
		end
		if i == 2 then break end
	end

local octaves_t = {}
	for i=0,127,12 do -- associate notes with each octave, and note numbers with notes in each octave, iterating in steps of 12
	--[[ ONLY NEEDED IF ITERATING IN STEPS OF 1
	local octave
		if i%12 == 0 then -- 0%12 is also 0
		octave = i/12 - 1 -- -1 because the lowest octave is not 0 but -1
		octaves_t[octave] = {}
		end
	--]]
	local octave = i/12 - 1 -- -1 because the lowest octave is not 0 but -1, middle C(60) is C4
	octaves_t[octave] = {}
		for k, note in ipairs(notes_t) do -- associate notes with the octave
		octaves_t[octave][note] = i+k-1 -- associate note names with MIDI note number // i+k because i changes in steps of 12, -1 because note indexing is 0-based while notes_t indexing is 1-based
		octaves_t[octave][k] = i+k-1 -- associate note index within octave with MIDI note number, k is the note index within octave // i+k because i changes in steps of 12, -1 because note indexing is 0-based while notes_t indexing is 1-based
		end	
	end
	
return notes_t, octaves_t

end


function Run_Functions_From_Table(...)
-- this is an example of a syntax;
-- the functions are wrapped in an anonymous function
-- to prevent their execution at the time of table construction
-- which is inevitable;
-- the actions table can be constructed outside of the function
local index, take, fx_idx = table.unpack({...})
local actions = {function() return r.TakeFX_SetEnabled(take, fx_idx, false) end,
function() return r.TakeFX_SetOffline(take, fx_idx, true) end,
function() return r.TakeFX_Delete(take, fx_idx) end
--[[ -- OR
local t = {r.TakeFX_SetEnabled(take, fx_idx, false),
r.TakeFX_SetOffline(take, fx_idx, true),
r.TakeFX_Delete(take, fx_idx),
}
local actions = {}
	for k, v in ipairs(t) do
	actions[k] = function() return v end
	end
]]
return actions[index]()
end


function get_Lua_bitdepth()
-- Lua compiler bitdepth which isn't necessarily system bitdepth
-- https://stackoverflow.com/a/61326632/8883033
-- In 32 bit Lua 0xffffffff(8f) would be the max int number and 0xfffffffff(9f) would overflow
    if(0xfffffffff==0xffffffff) then return 32 else return 64 end
end


function get_system_bitdepth1()
-- https://stackoverflow.com/a/48094597/8883033
-- https://en.wikipedia.org/wiki/Environment_variable
local arch
	if (os.getenv'os' or ''):match'Windows' then
	arch = os.getenv'PROCESSOR_ARCHITECTURE'
	else -- Linux
	arch = io.popen'uname -m':read'*a'
	end
return (arch or ''):match'64' or '32'
end


function get_system_bitdepth2()
local _os = r.GetOS()
return _os:match'64' or _os:match'32' or 'Linux'
end


function gmem_write_read_str(index, str) -- cfillion
-- https://forum.cockos.com/showthread.php?t=214162 gmem discussion

	if str then -- write
		for c in value:gmatch('.') do
		r.gmem_write(index, string.byte(c))
		index = index + 1
		end
	r.gmem_write(index, 0) -- null terminate // not sure how necessary this is
	else -- read
	local chars = {}
		while true do
		local value = r.gmem_read(index)
			if value == 0 then break end
			table.insert(chars, string.char(value))
			index = index + 1
		end
	return table.concat(chars)
	end

end
--[[ Jesusonic equivalent

desc:Storing strings in global memory space
version:1.0
author:cfillion
options:gmem=some_namespace

@block
function gmem_write_string(index, value) local(offset) (
  offset = 0;

  loop(strlen(value),
    gmem[index] = str_getchar(value, offset);
    offset += 1;
    index += 1;
  );
  
  gmem[index] = 0;
);

trigger ? gmem_write_string(0, "foo");

@gfx

function gmem_read_string(index, output) local(offset, buf) (
  offset = 0;
  buf = #;

  while (
    gmem[index] ? (
      str_setchar(buf, offset, gmem[index]);
      offset += 1;
      index  += 1;
    ) : 0;
  );
  
  strcpy_substr(output, buf, 0, offset); // truncates the output
);

gfx_r = gfx_g = gfx_b = 1;
gfx_x = 0;

str = #;
gmem_read_string(0, str);
gfx_drawstr(str);

--]]

--[[

function split_string_at_new_line_charA(str)

/* 
IN JESUSONIC PROBABLY ONLY SUPPORTS ASCII, OR IT'S A GFX LIBRARY PROBLEM
this version ignores clusters of new line characters
only respecting a single new line character as a line separator
*/

(
  str_len = strlen(str); // store source string length
  count = 0;
  offset = 0;
  substr_len = 1;
  while(
    // Keep scanning and storing substring to memory address until \n comes along
    strcpy_substr(count, str, offset, substr_len);
    single_new_line_char = substr_len == 1 && match("\n", count);
    found = match("*\n", count); // operators + and +? work as well
      // If the substring sarts with a new line char
      // it immediately follows the preceding new line character
      // of the previous capture and will be included in the current capture
      // at its start, so skip it because it will throw off calculations
      single_new_line_char ? (
      offset += substr_len;
      substr_len = 0;
      ) :
      ( found || offset + substr_len == str_len) ? ( // \n is found in the substring or end of the source string
        // Strip trailing new line char from the substring if found, i.e. not if the end of the string,
        // resaving it at the same address
        trim = found ? substr_len-1 : substr_len;
        strcpy_substr(count, str, offset, trim);
        // Increment count to advance to next memory address for storage,
        // the value will also be used to iterate over them in a loop
        // to display the stored substrings
        count += 1;
        // Update offset to restart scanning from the last position
        offset += substr_len;
        // Reset to start the scanning from the 1st subtring byte,
        // will be incremented below
        substr_len = 0;
      );
    // Constantly increment by 1 to advance within the source string towards its end
    substr_len += 1;
    // Continue looping as long as this is true
    offset + substr_len <= str_len;
  );
  count; // only needed if the value is assigned to another var outside, i.e. x = split_string_at_new_line_charA(str)
);


function split_string_at_new_line_charB(str)

/* 
IN JESUSONIC PROBABLY ONLY SUPPORTS ASCII, OR IT'S A GFX LIBRARY PROBLEM
this version doesn't ignore clusters of new line characters
which results in extra instances being included in actual lines of text
which is a flaw
*/

(
  str_len = strlen(str); // store source string length
  count = 0;
  offset = 0;
  substr_len = 1;
  while(
	 // Keep scanning and storing substring to memory address until \n comes along
    strcpy_substr(count, str, offset, substr_len);
    found = match("*\n", count);
	 (found || offset + substr_len == str_len) ? ( // \n is found in the substring or end of the source string
     // Strip trailing new line char from the substring if found, i.e. not if the end of the string,
     // resaving it at the same address
		trim = found ? substr_len-1 : substr_len;
      strcpy_substr(count, str, offset, trim);
		// Increment count to advance to next memory address for storage,
		// the value will also be used to iterate over them in a loop
		// to display the stored substrings
      count += 1;
		// Update offset to restart scanning from the last position
      offset += substr_len;
		// Reset to start the scanning from the 1st subtring byte,
		// will be incremented below
      substr_len = 0;
    );
	 // Constantly increment by 1 to advance within the source string towards its end
    substr_len += 1;
	 // Continue looping as long as this is true
    offset + substr_len <= str_len;
  );
  count; // only needed if the value is assigned to another var outside, i.e. x = split_string_at_new_line_charB(str)
);


function get_longest_str_idx(array_st, array_end)

// array_st is index of the global array range start slot
// array_end is index of the global array range end slot
// i.e. if values where stored in slots 0 - 15, the args will be 0, 15

// Couldn't make it work with while() loop

(
// First find the greatest length value
range = array_end-array_st;
i = array_st;
	loop(range,
	a = strlen(i);
	mx = max(a, mx);
	i+=1;
	);
// Now find the index of memory address
// where the longest string is stored
i = array_st;
	loop(range,
	mx = strlen(i) == mx ? i : mx;
	i+=1;
	);
mx; // only needed if the value is assigned to another var outside, i.e. x = get_longest_str_idx(array_st, array_end)
);



--]]


-- SYSTEM ENVIRONMENT VARIABLES
-- https://en.wikipedia.org/wiki/Environment_variable
os.getenv(string) -- TMP/TEMP; USERNAME; PATH; HOMEDRIVE; HOMEPATH; USERPROFILE; APPDATA; LOCALAPPDATA; PROGRAMDATA = ALLUSERSPROFILE; OS; COMSPEC; PUBLIC; ProgramFiles = ProgramW6432; ProgramFiles(x86); SystemDrive; SystemRoot = windir; USERDOMAIN;
os.getenv('TEMP')

-- https://github.com/ReaTeam/ReaScripts/pull/1466#issuecomment-2500963241
local function CheckDependencies(func_name1, api_name1, func_name2, api_name2)
-- this function must be included in the library loaded via reguire
--https://github.com/ReaTeam/ReaScripts/blob/e6eeb7c9c6238657db4345d0e3a6c3e58e3f1136/View/talagan_Docking%20tools/docking_lib.lua
local err = ' is required to use this script.'
local err1 = not func_name1 and api_name1..err or ''
local err2 = not func_name2 and api_name2..err or ''
	if #err1 > 0 or #err2 > 0 then
	local lb = #err1 > 0 and #err2 > 0 and '\n\n' or ''
	r.MB(err1..lb..err2, 'ERROR', 0)
	return end
return true
end
function validate_dependency(lib_path)
-- this function must be included in the main script which loads the lib via require
-- https://github.com/ReaTeam/ReaScripts/blob/e6eeb7c9c6238657db4345d0e3a6c3e58e3f1136/View/talagan_Docking%20tools/actions/talagan_Maximize%20bottommost%20dock.lua
package.path = debug.getinfo(1,"S").source:match[[^@?(.*[\/])[^\/]-$]] .."?.lua;".. package.path
local ok, lib = pcall(require, lib_path)
	if not ok then
	r.MB('This script is not installed correctly.\n\nExternal library is missing', 'ERROR', 0)
	return
	end
	if not lib.CheckDependencies() then return end
return lib
end




-- amagalma breakpoint for debugging
function Break(msg) -- msg is a string
-- https://forum.cockos.com/showthread.php?t=262893
-- https://forum.cockos.com/showthread.php?p=2528121#post2528121
local line = "Breakpoint at line " .. debug.getinfo(2).currentline
local ln = "\n" .. string.rep("=", #line) .. "\n"
local trace = debug.traceback(ln .. line)
trace = trace:gsub("(stack traceback:\n).*\n", "%1")
reaper.ShowConsoleMsg(trace .. ln .. "\n" )
reaper.MB(tostring(msg) .. "\n\nContinue?", line, 0 )
end


function J_Reverb_randomizer()
-- https://forum.cockos.com/showthread.php?t=249923 + discussion
-- schwa: Any random number implementation is going to have some resolution so if you want a particular exact number to occur before the heat death of the universe, you need to reduce the resolution.
math.randomseed(reaper.time_precise()*os.time()/1e3) -- 1e3 = 10^3 = 1000
local rnd = math.random(11000)/10000
if rnd > 1 then return rnd = 1 else return rnd = math.random(10000)/10000 end
end


function Audio_Accessor_Noise_Gate()
-- https://forum.cockos.com/showthread.php?t=299094#17 amagalma

-- Noise Gate Parameters
local open_threshold_dB = -40
local close_threshold_diff_dB = -1 -- difference from open_threshold_dB 
local hold_ms = 20
local ng_floor_dB = 0
local preopen_ms = 15 -- open earlier than when the gate opens

-- Convert dB values to linear
local open_threshold = 10^(open_threshold_dB/20)
local close_threshold = 10^((open_threshold_dB+close_threshold_diff_dB)/20)
local hold_time = hold_ms/1000
local preopen = preopen_ms/1000
local ng_floor_linear = 10^(ng_floor_dB/20)

local ScalingMode = reaper.GetEnvelopeScalingMode( env )
ng_floor_linear = reaper.ScaleToEnvelopeMode( ScalingMode, ng_floor_linear )
  
-- Create audio accessor
local audio = reaper.CreateTakeAudioAccessor(take)

	if not audio then return end

local samplerate = reaper.GetMediaSourceSampleRate(PCM_source)
local aa_start = reaper.GetAudioAccessorStartTime(audio)
local aa_end = reaper.GetAudioAccessorEndTime(audio)
local n_channels = reaper.GetMediaSourceNumChannels(PCM_source) -- we will read only channel 1

-- Analysis parameters
local window_size = 0.010 -- 10ms analysis window
local samples_per_window = math.floor(samplerate * window_size)
local buffer = reaper.new_array(samples_per_window)

-- Noise gate state variables
local gate_open = false
local last_gate_open_pos = 0
local last_gate_close_pos = -1
  
-- Process audio in windows
local pos = aa_start

	while pos < aa_end do
	local ret = reaper.GetAudioAccessorSamples(audio, samplerate, 1, pos, samples_per_window, buffer)
	 
		if ret ~= 1 then break end

			-- Noise gate logic
		if peak_value > open_threshold then			
			if not gate_open and (pos - last_gate_close_pos) > hold_time then
			-- Open gate
			reaper.InsertEnvelopePoint(env, pos-0.01-preopen, ng_floor_linear, 5, 0, false, true)
			reaper.InsertEnvelopePoint(env, pos-preopen, reaper.ScaleToEnvelopeMode( ScalingMode, 1 ), 0, 0, false, true)
			gate_open = true
			last_gate_open_pos = pos
			end
		elseif peak_value < close_threshold and gate_open then
			if (pos - last_gate_open_pos) > hold_time then
			-- Close gate
			local release_end = pos + 0.005 -- 5ms release
			reaper.InsertEnvelopePoint(env, pos, reaper.ScaleToEnvelopeMode( ScalingMode, 1 ), 5, 0, false, true)
			reaper.InsertEnvelopePoint(env, release_end, ng_floor_linear, 0, 0, false, true)
			gate_open = false
			last_gate_close_pos = pos
			end
		end

	pos = pos + window_size
	end

reaper.DestroyAudioAccessor(audio)

end



--=================================== U T I L I T Y  E N D ======================================

--============================ C O N V E R S I O N S ==============================


function hex2dec(str)
-- https://stackoverflow.com/questions/27294310/convert-hexadecimal-to-decimal-number
return str:match('0x') and tonumber(str) or tonumber(str,16)
end


function dec2hex(dec_int)
-- input arg is a decimal integer
-- https://www.rapidtables.com/convert/number/decimal-to-hex.html algo
	
	if not dec_int then return end
		
local dec_int2

	if dec_int > 0xfffffffffffff then  -- 2^52
	-- math.maxinteger is supported from Lua 5.3
		if tonumber(_VERSION:match('[%.%d]+')) < 5.3 or math.maxinteger == 0x7fffffff then -- either Lua older than 5.3 or 32 bit system, 0x7fffffff == 2147483647
		return dec_int -- on a 32 bit system integers above 2^31 Lua encodes as double floating point numbers while in older Lua versions all integers are encoded as double floating point numbers; in all versions of Lua floating point precision limit is 2^53-1 (about 15 - 17 decimal places) after which rounding errors start to occur, so in these two cases no point to convert a number above 2^53-1 (in practical terms above 2^52, because in division and modulo operations employed for conversion into hex this is the limit of accuracy) because it will be fed in with rounding erros from the outset
		end
	-- the following assumes that integers up to 2^53-1 are represented natively rather than as floating point numbers, 
	-- which is good for REAPER since native integer representaion is supported in Lua 5.3+
	-- run by all REAPER versions with Lua support
	local diff = math.floor(math.log(dec_int)/math.log(2))-52 -- find by how much the input exponent exceeds the Lua max floating point number precision limit which is 53 bit i.e. ~15-17 decimal places, because numbers whose decimal places exceed this limit lose precision and cause wrong calculation result, this workround is needed because the employed conversion method to hex relies on division and modulo operaions which produce decimal numbers for which precision is important; using value 52 instead of 53 because in division and modulo operations the limit of accuracy is 52 bit; formula to calculate exponend of the value by specific base comes from  https://www.gammon.com.au/scripts/doc.php?lua=math.log
	dec_int, dec_int2 = dec_int >> diff, dec_int >> 52 -- shift the input value right by the difference to only leave bits whose total doesn't affect precision, then shift the input value right by 52 bits to isolate the remaining upper bits, those which have been discarded in shifting right by the difference // this is the correct splitting method for subsequent string concatenaton because it produces parts with different bit width just as would occur in splitting a string for example '256' into '56' and '2', because maintaining original width i.e. '056' and '200' would not allow accurate concatenation resulting in 200056
	end
	
local hex = ''
local t  = {[0]=0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e','f'}
	repeat	
	local quotient = math.modf(dec_int/16) -- OR math.floor(dec_int/16)
	hex = t[dec_int%16]..hex
-- OR 
-- hex = t[dec_int-16*quotient] and t[dec_int-16*quotient]..hex or hex
	dec_int = quotient
	until quotient == 0
	
	local hex2
	if dec_int2 then -- if the input number exponent exceeds the Lua floating point number max precision limit, convert the remaining upper bits, those which exceed 52 bits and concatenate the results placing the upper bits conversion result at the front as that's where they're placed in the bitfield
	hex2 = dec2hex(dec_int2)
	hex = hex2:sub(3)..hex
	end	
	
return '0x'..hex

end
-- for inverse operation: hex 2 dec
-- dec = tonumber(hex:match('0x(%x+)'), 16) -- OR hex:sub(3) // hex string sans 0x


function char_to_bytes(char)
-- returns a string of bytes which comprise a character
-- e.g. '\195\128' 'À', '\196\141' 'č'
local i = 1
local byte_code = ''
	repeat
	local byte = char:byte(i)
		if byte then
		byte_code = byte_code..'\\'..byte
		end
	i = i+1
	until not byte
return byte_code
end


local function unicode_to_utf8(code)
-- https://stackoverflow.com/questions/41855842/converting-utf-8-string-to-ascii-in-pure-lua/41859181#41859181
-- converts numeric UTF code (U+code) to UTF-8 string, i.e. actual character
-- code arg is a hex number, i.e. 0x0000 or integer in base 10
-- from the UTF-8 code page 2nd or 1st columns here https://www.charset.org/utf-8
local t, h = {}, 128
	while code >= h do
		t[#t+1] = 128 + code%64
		code = math.floor(code/64)
		h = h > 32 and 32 or h/2
	end
t[#t+1] = 256 - 2*h + code
return string.char(table.unpack(t)):reverse()
end


local function utf8_to_unicode(utf8str, pos)
-- https://stackoverflow.com/questions/41855842/converting-utf-8-string-to-ascii-in-pure-lua/41859181#41859181
-- pos = starting byte position inside input string (default 1)
pos = pos or 1
local code, size = utf8str:byte(pos), 1
	if code >= 0xC0 and code < 0xFE then
	local mask = 64
	code = code - 128
		repeat
		local next_byte = utf8str:byte(pos + size) or 0
			if next_byte >= 0x80 and next_byte < 0xC0 then
				code, size = (code - mask - 2) * 64 + next_byte, size + 1
			else
				code, size = utf8str:byte(pos), 1
			end
		mask = mask * 32
		until code < mask
	end
-- returns code, number of bytes in this utf8 char
return code, size
end

-----------ARABIC WIN-1256 TO UTF-8---------------------------------

-- https://stackoverflow.com/questions/16624036/how-to-convert-windows-1256-to-utf-8-in-lua#16627763
local win2utf_list = [[
0x00    0x0000  #NULL
0x01    0x0001  #START OF HEADING
0x02    0x0002  #START OF TEXT
-- Download full text from
-- http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1256.TXT
0xFD    0x200E  #LEFT-TO-RIGHT MARK
0xFE    0x200F  #RIGHT-TO-LEFT MARK
0xFF    0x06D2  #ARABIC LETTER YEH BARREE
]]

local win2utf = {}

	for w, u in win2utf_list:gmatch'0x(%x%x)%s+0x(%x+)' do
	local c, t, h = tonumber(u,16), {}, 128
		while c >= h do
			t[#t+1] = 128 + c%64
			c = math.floor(c/64)
			h = h > 32 and 32 or h/2
		end
	t[#t+1] = 256 - 2*h + c
	win2utf[w.char(tonumber(w,16))] =
	w.char((table.unpack or unpack)(t)):reverse()
	end

local function convert_to_utf8(win_string)
return win_string:gsub('.', win2utf)
end

--------------------------------------------

function convert_case_in_unicode(str, want_upper_case)
-- by default converts to lower case
-- want_upper_case is boolean to convert to upper case
-- if false/nil convertion into lower will be done
-- https://stackoverflow.com/questions/41855842/converting-utf-8-string-to-ascii-in-pure-lua/41859181#41859181
-- https://stackoverflow.com/questions/13235091/extract-the-first-letter-of-a-utf-8-string-with-lua
-- https://www.ibm.com/docs/en/i/7.3?topic=tables-unicode-lowercase-uppercase-conversion-mapping-table -- this is only a list of ordinal number correspondence within the table, such as at https://www.charset.org/utf-8, not actual code point values
-- https://stackoverflow.com/questions/29966782/how-to-embed-hex-values-in-a-lua-string-literal-i-e-x-equivalent

-- t table below contains Unicode code points, i.e. U+codepoint in base 10 rather than hex for brevity
-- code points reference table see at https://www.charset.org/utf-8
-- fields order: upper case, lower case
local t = {
-- the commented out code is basic latin code points which are supported by the stock lua string lib so redundant
-- {65,97}, {66,98}, {67,99}, {68,100}, {69,101}, {70,102}, {71,103}, {72,104}, {73,105}, {74,106}, {75,107}, {76,108}, {77,109}, {78,110}, {79,111}, {80,112},
{81,113},{82,114},{83,115},{84,116},{85,117},{86,118},{87,119},{88,120},{89,121},{90,122},{192,224},{193,225},{194,226},{195,227},{196,228},{197,229},{198,230},{199,231},{200,232},{201,233},{202,234},{203,235},{204,236},{205,237},{206,238},{207,239},{208,240},{209,241},{210,242},{211,243},{212,244},{213,245},{214,246},{216,248},{217,249},{218,250},{219,251},{220,252},{221,253},{222,254},{376,255},{256,257},{258,259},{260,261},{262,263},{264,265},{266,267},{268,269},{270,271},{272,273},{274,275},{276,277},{278,279},{280,281},{282,283},{284,285},{286,287},{288,289},{290,291},{292,293},{294,295},{296,297},{298,299},{300,301},{302,303},{73,305},{306,307},{308,309},{310,311},{313,314},{315,316},{317,318},{319,320},{321,322},{323,324},{325,326},{327,328},{330,331},{332,333},{334,335},{336,337},{338,339},{340,341},{342,343},{344,345},{346,347},{348,349},{350,351},{352,353},{354,355},{356,357},{358,359},{360,361},{362,363},{364,365},{366,367},{368,369},{370,371},{372,373},{374,375},{377,378},{379,380},{381,382},{386,387},{388,389},{391,392},{395,396},{401,402},{408,409},{416,417},{418,419},{420,421},{423,424},{428,429},{431,432},{435,436},{437,438},{440,441},{444,445},{452,454},{455,457},{458,460},{461,462},{463,464},{465,466},{467,468},{469,470},{471,472},{473,474},{475,476},{478,479},{480,481},{482,483},{484,485},{486,487},{488,489},{490,491},{492,493},{494,495},{497,499},{500,501},{506,507},{508,509},{510,511},{512,513},{514,515},{516,517},{518,519},{520,521},{522,523},{524,525},{526,527},{528,529},{530,531},{532,533},{534,535},{385,595},{390,596},{394,599},{398,600},{399,601},{400,603},{403,608},{404,611},{407,616},{406,617},{412,623},{413,626},{415,629},{425,643},{430,648},{433,650},{434,651},{439,658},{902,940},{904,941},{905,942},{906,943},{913,945},{914,946},{915,947},{916,948},{917,949},{918,950},{919,951},{920,952},{921,953},{922,954},{923,955},{924,956},{925,957},{926,958},{927,959},{928,960},{929,961},{931,963},{932,964},{933,965},{934,966},{935,967},{936,968},{937,969},{938,970},{939,971},{908,972},{910,973},{911,974},{994,995},{996,997},{998,999},{1000,1001},{1002,1003},{1004,1005},{1006,1007},{1040,1072},{1041,1073},{1042,1074},{1043,1075},{1044,1076},{1045,1077},{1046,1078},{1047,1079},{1048,1080},{1049,1081},{1050,1082},{1051,1083},{1052,1084},{1053,1085},{1054,1086},{1055,1087},{1056,1088},{1057,1089},{1058,1090},{1059,1091},{1060,1092},{1061,1093},{1062,1094},{1063,1095},{1064,1096},{1065,1097},{1066,1098},{1067,1099},{1068,1100},{1069,1101},{1070,1102},{1071,1103},{1025,1105},{1026,1106},{1027,1107},{1028,1108},{1029,1109},{1030,1110},{1031,1111},{1032,1112},{1033,1113},{1034,1114},{1035,1115},{1036,1116},{1038,1118},{1039,1119},{1120,1121},{1122,1123},{1124,1125},{1126,1127},{1128,1129},{1130,1131},{1132,1133},{1134,1135},{1136,1137},{1138,1139},{1140,1141},{1142,1143},{1144,1145},{1146,1147},{1148,1149},{1150,1151},{1152,1153},{1168,1169},{1170,1171},{1172,1173},{1174,1175},{1176,1177},{1178,1179},{1180,1181},{1182,1183},{1184,1185},{1186,1187},{1188,1189},{1190,1191},{1192,1193},{1194,1195},{1196,1197},{1198,1199},{1200,1201},{1202,1203},{1204,1205},{1206,1207},{1208,1209},{1210,1211},{1212,1213},{1214,1215},{1217,1218},{1219,1220},{1223,1224},{1227,1228},{1232,1233},{1234,1235},{1236,1237},{1238,1239},{1240,1241},{1242,1243},{1244,1245},{1246,1247},{1248,1249},{1250,1251},{1252,1253},{1254,1255},{1256,1257},{1258,1259},{1262,1263},{1264,1265},{1266,1267},{1268,1269},{1272,1273},{1329,1377},{1330,1378},{1331,1379},{1332,1380},{1333,1381},{1334,1382},{1335,1383},{1336,1384},{1337,1385},{1338,1386},{1339,1387},{1340,1388},{1341,1389},{1342,1390},{1343,1391},{1344,1392},{1345,1393},{1346,1394},{1347,1395},{1348,1396},{1349,1397},{1350,1398},{1351,1399},{1352,1400},{1353,1401},{1354,1402},{1355,1403},{1356,1404},{1357,1405},{1358,1406},{1359,1407},{1360,1408},{1361,1409},{1362,1410},{1363,1411},{1364,1412},{1365,1413},{1366,1414},{4256,4304},{4257,4305},{4258,4306},{4259,4307},{4260,4308},{4261,4309},{4262,4310},{4263,4311},{4264,4312},{4265,4313},{4266,4314},{4267,4315},{4268,4316},{4269,4317},{4270,4318},{4271,4319},{4272,4320},{4273,4321},{4274,4322},{4275,4323},{4276,4324},{4277,4325},{4278,4326},{4279,4327},{4280,4328},{4281,4329},{4282,4330},{4283,4331},{4284,4332},{4285,4333},{4286,4334},{4287,4335},{4288,4336},{4289,4337},{4290,4338},{4291,4339},{4292,4340},{4293,4341},{7680,7681},{7682,7683},{7684,7685},{7686,7687},{7688,7689},{7690,7691},{7692,7693},{7694,7695},{7696,7697},{7698,7699},{7700,7701},{7702,7703},{7704,7705},{7706,7707},{7708,7709},{7710,7711},{7712,7713},{7714,7715},{7716,7717},{7718,7719},{7720,7721},{7722,7723},{7724,7725},{7726,7727},{7728,7729},{7730,7731},{7732,7733},{7734,7735},{7736,7737},{7738,7739},{7740,7741},{7742,7743},{7744,7745},{7746,7747},{7748,7749},{7750,7751},{7752,7753},{7754,7755},{7756,7757},{7758,7759},{7760,7761},{7762,7763},{7764,7765},{7766,7767},{7768,7769},{7770,7771},{7772,7773},{7774,7775},{7776,7777},{7778,7779},{7780,7781},{7782,7783},{7784,7785},{7786,7787},{7788,7789},{7790,7791},{7792,7793},{7794,7795},{7796,7797},{7798,7799},{7800,7801},{7802,7803},{7804,7805},{7806,7807},{7808,7809},{7810,7811},{7812,7813},{7814,7815},{7816,7817},{7818,7819},{7820,7821},{7822,7823},{7824,7825},{7826,7827},{7828,7829},{7840,7841},{7842,7843},{7844,7845},{7846,7847},{7848,7849},{7850,7851},{7852,7853},{7854,7855},{7856,7857},{7858,7859},{7860,7861},{7862,7863},{7864,7865},{7866,7867},{7868,7869},{7870,7871},{7872,7873},{7874,7875},{7876,7877},{7878,7879},{7880,7881},{7882,7883},{7884,7885},{7886,7887},{7888,7889},{7890,7891},{7892,7893},{7894,7895},{7896,7897},{7898,7899},{7900,7901},{7902,7903},{7904,7905},{7906,7907},{7908,7909},{7910,7911},{7912,7913},{7914,7915},{7916,7917},{7918,7919},{7920,7921},{7922,7923},{7924,7925},{7926,7927},{7928,7929},{7944,7936},{7945,7937},{7946,7938},{7947,7939},{7948,7940},{7949,7941},{7950,7942},{7951,7943},{7960,7952},{7961,7953},{7962,7954},{7963,7955},{7964,7956},{7965,7957},{7976,7968},{7977,7969},{7978,7970},{7979,7971},{7980,7972},{7981,7973},{7982,7974},{7983,7975},{7992,7984},{7993,7985},{7994,7986},{7995,7987},{7996,7988},{7997,7989},{7998,7990},{7999,7991},{8008,8000},{8009,8001},{8010,8002},{8011,8003},{8012,8004},{8013,8005},{8025,8017},{8027,8019},{8029,8021},{8031,8023},{8040,8032},{8041,8033},{8042,8034},{8043,8035},{8044,8036},{8045,8037},{8046,8038},{8047,8039},{8072,8064},{8073,8065},{8074,8066},{8075,8067},{8076,8068},{8077,8069},{8078,8070},{8079,8071},{8088,8080},{8089,8081},{8090,8082},{8091,8083},{8092,8084},{8093,8085},{8094,8086},{8095,8087},{8104,8096},{8105,8097},{8106,8098},{8107,8099},{8108,8100},{8109,8101},{8110,8102},{8111,8103},{8120,8112},{8121,8113},{8152,8144},{8153,8145},{8168,8160},{8169,8161},{9398,9424},{9399,9425},{9400,9426},{9401,9427},{9402,9428},{9403,9429},{9404,9430},{9405,9431},{9406,9432},{9407,9433},{9408,9434},{9409,9435},{9410,9436},{9411,9437},{9412,9438},{9413,9439},{9414,9440},{9415,9441},{9416,9442},{9417,9443},{9418,9444},{9419,9445},{9420,9446},{9421,9447},{9422,9448},{9423,9449},{65313,65345},{65314,65346},{65315,65347},{65316,65348},{65317,65349},{65318,65350},{65319,65351},{65320,65352},{65321,65353},{65322,65354},{65323,65355},{65324,65356},{65325,65357},{65326,65358},{65327,65359},{65328,65360},{65329,65361},{65330,65362},{65331,65363},{65332,65364},{65333,65365},{65334,65366},{65335,65367},{65336,65368},{65337,65369},{65338,65370}
}

	local function unicode_to_utf8(code)
	-- credit belongs to Egor Skripunoff
	-- https://stackoverflow.com/questions/41855842/converting-utf-8-string-to-ascii-in-pure-lua/41859181#41859181
	-- converts numeric UTF code (U+code) to UTF-8 string, i.e. actual character
	-- code arg is a hex number, i.e. 0x0000 or integer in base 10
	-- from the UTF-8 code page 2nd or 1st columns here https://www.charset.org/utf-8
	local t, h = {}, 128
		while code >= h do
			t[#t+1] = 128 + code%64
			code = math.floor(code/64)
			h = h > 32 and 32 or h/2
		end
	t[#t+1] = 256 - 2*h + code
	return string.char(table.unpack(t)):reverse()
	end

	for _, pair in ipairs(t) do
	local cap, small = pair[1], pair[2]
	local what = want_upper_case and small or cap
	local with = want_upper_case and cap or small
	what = unicode_to_utf8(what)
		if str:match(what) then
		with = unicode_to_utf8(with)
		-- replace one case character instances with their other case instances
		-- doing that 1 by 1, one character per repeat loop cycle
		-- which is supposedly safer and more reliable
		local i, cnt = 1
			repeat
			str, cnt = str:gsub(what, with, 1) -- 1 instance only
			i = i+1
			until cnt == 0 -- until no more replacaments
		end
	end

return str

end


local function codepoint_to_utf8(n)
-- https://github.com/ReaTeam/ReaScripts/pull/1293/files
-- https://github.com/LostViking09/ReaScripts/blob/f1d25bf39701aedf0ebc286823c261e8e29ca92b/Tracks/dontcupthemic_Mixing%20Station%20track%20name%20import.lua
-- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end



-- BASE64 EN / DECODER

function Mespotine_Base64_Encoder(source_string, remove_newlines, remove_tabs)
--[[
https://forum.cockos.com/showthread.php?t=260054

Meo-Ada Mespotine - licensed under MIT-license

converts string into Base64-representation:

Parameters:
string source_string - the string that you want to convert into Base64
optional integer remove_newlines - 1, removes \n-newlines(including \r-carriage return) from the string
                                 - 2, replaces \n-newlines(including \r-carriage return) from the string with a single space
optional integer remove_tabs     - 1, removes \t-tabs from the string
                                 - 2, replaces \t-tabs from the string with a single space
--]]

  -- check parameters and prepare variables
  if type(source_string)~="string" then return nil end
  if remove_newlines~=nil and math.type(remove_newlines)~="integer" then return nil end
  if remove_tabs~=nil and math.type(remove_tabs)~="integer" then return nil end

  local tempstring={}
  local a=1
  local temp

  -- this is probably the future space for more base64-encoding-schemes
  local base64_string="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

  -- if source_string is multiline, get rid of \r and replace \t and \n with a single whitespace
  if remove_newlines==1 then
    source_string=string.gsub(source_string, "\n", "")
    source_string=string.gsub(source_string, "\r", "")
  elseif remove_newlines==2 then
    source_string=string.gsub(source_string, "\n", " ")
    source_string=string.gsub(source_string, "\r", "")
  end

  if remove_tabs==1 then
    source_string=string.gsub(source_string, "\t", "")
  elseif remove_tabs==2 then
    source_string=string.gsub(source_string, "\t", " ")
  end

  -- tear apart the source-string into bits
  -- bitorder of bytes will be reversed for the later parts of the conversion!
  for i=1, source_string:len() do
    temp=string.byte(source_string:sub(i,i))
    temp=temp
    if temp&1==0 then tempstring[a+7]=0 else tempstring[a+7]=1 end
    if temp&2==0 then tempstring[a+6]=0 else tempstring[a+6]=1 end
    if temp&4==0 then tempstring[a+5]=0 else tempstring[a+5]=1 end
    if temp&8==0 then tempstring[a+4]=0 else tempstring[a+4]=1 end
    if temp&16==0 then tempstring[a+3]=0 else tempstring[a+3]=1 end
    if temp&32==0 then tempstring[a+2]=0 else tempstring[a+2]=1 end
    if temp&64==0 then tempstring[a+1]=0 else tempstring[a+1]=1 end
    if temp&128==0 then tempstring[a]=0 else tempstring[a]=1 end
    a=a+8
  end

  -- now do the encoding
  local encoded_string=""
  local temp2=0

  -- take six bits and make a single integer-value off of it
  -- after that, use this integer to know, which place in the base64_string must
  -- be read and included into the final string "encoded_string"
  for i=0, a-2, 6 do
    temp2=0
    if tempstring[i+1]==1 then temp2=temp2+32 end
    if tempstring[i+2]==1 then temp2=temp2+16 end
    if tempstring[i+3]==1 then temp2=temp2+8 end
    if tempstring[i+4]==1 then temp2=temp2+4 end
    if tempstring[i+5]==1 then temp2=temp2+2 end
    if tempstring[i+6]==1 then temp2=temp2+1 end
    encoded_string=encoded_string..base64_string:sub(temp2+1,temp2+1)
  end

  -- if the number of characters in the encoded_string isn't exactly divideable
  -- by 3, add = to fill up missing bytes
  if encoded_string:len()%4==2 then encoded_string=encoded_string.."=="
  elseif encoded_string:len()%2==1 then encoded_string=encoded_string.."="
  end

  return encoded_string
end


function Mespotine_Base64_Decoder(source_string)
-- Meo-Ada Mespotine - licensed under MIT-license
-- decodes a Base-64-string into its original representation
-- https://forum.cockos.com/showthread.php?t=260054

  if type(source_string)~="string" then return nil end

  -- this is probably the place for other types of base64-decoding-stuff
  local base64_string="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

  -- remove =
  source_string=string.gsub(source_string,"=","")

  local L=source_string:match("[^"..base64_string.."]")
  if L~=nil then ultraschall.AddErrorMessage("Base64_Decoder", "source_string", "no valid Base64-string: invalid characters", -3) return nil end

  -- split the string into bits
  local bitarray={}
  local count=1
  local temp
  for i=1, source_string:len() do
    temp=base64_string:match(source_string:sub(i,i).."()")-2
    if temp&32~=0 then bitarray[count]=1 else bitarray[count]=0 end
    if temp&16~=0 then bitarray[count+1]=1 else bitarray[count+1]=0 end
    if temp&8~=0 then bitarray[count+2]=1 else bitarray[count+2]=0 end
    if temp&4~=0 then bitarray[count+3]=1 else bitarray[count+3]=0 end
    if temp&2~=0 then bitarray[count+4]=1 else bitarray[count+4]=0 end
    if temp&1~=0 then bitarray[count+5]=1 else bitarray[count+5]=0 end
    count=count+6
  end

  -- combine the bits into the original bytes and put them into decoded_string
  local decoded_string=""
  local temp2=0
  for i=0, count-1, 8 do
    temp2=0
    if bitarray[i+1]==1 then temp2=temp2+128 end
    if bitarray[i+2]==1 then temp2=temp2+64 end
    if bitarray[i+3]==1 then temp2=temp2+32 end
    if bitarray[i+4]==1 then temp2=temp2+16 end
    if bitarray[i+5]==1 then temp2=temp2+8 end
    if bitarray[i+6]==1 then temp2=temp2+4 end
    if bitarray[i+7]==1 then temp2=temp2+2 end
    if bitarray[i+8]==1 then temp2=temp2+1 end
    decoded_string=decoded_string..string.char(temp2)
  end
  if decoded_string:sub(-1,-1)=="\0" then decoded_string=decoded_string:sub(1,-2) end
  return decoded_string
end

-- BASE64 EN / DECODER END

-- UNICODE -- UTF-8  CONVERTER  START

function codepoint_to_utf8(n)
-- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
-- https://github.com/ReaTeam/ReaScripts/pull/1293/files#diff-78b0f4d3cbf90aca99f8ca3e5749513f115cf0c09f1d3b752c21dba771f73a76R208
local f = math.floor
	if n <= 0x7f then
	return string.char(n)
	elseif n <= 0x7ff then
	return string.char(f(n / 64) + 192, n % 64 + 128)
	elseif n <= 0xffff then
	return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
	elseif n <= 0x10ffff then
	return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128, f(n % 4096 / 64) + 128, n % 64 + 128)
	end
error( string.format("invalid unicode codepoint '%x'", n) )
end


-- functions from IvoDueblin's MC_CollabControl.lua
-- https://github.com/ReaTeam/ReaScripts/Various/ivodblin_MusiCollaboration/MC_CollabControl.lua
-- https://www.mucol.ch/
-- Conversion functions found here:
-- https://stackoverflow.com/questions/41855842/converting-utf-8-string-to-ascii-in-pure-lua

local char, byte, pairs, floor = string.char, string.byte, pairs, math.floor
local table_insert, table_concat = table.insert, table.concat
local unpack = table.unpack or unpack

local function unicode_to_utf8(code)
   -- converts numeric UTF code (U+code) to UTF-8 string
   local t, h = {}, 128
   while code >= h do
      t[#t+1] = 128 + code%64
      code = floor(code/64)
      h = h > 32 and 32 or h/2
   end
   t[#t+1] = 256 - 2*h + code
   return char(unpack(t)):reverse()
end

local function utf8_to_unicode(utf8str, pos)
   -- pos = starting byte position inside input string (default 1)
   pos = pos or 1
   local code, size = utf8str:byte(pos), 1
   if code >= 0xC0 and code < 0xFE then
      local mask = 64
      code = code - 128
      repeat
         local next_byte = utf8str:byte(pos + size) or 0
         if next_byte >= 0x80 and next_byte < 0xC0 then
            code, size = (code - mask - 2) * 64 + next_byte, size + 1
         else
            code, size = utf8str:byte(pos), 1
         end
         mask = mask * 32
      until code < mask
   end
   -- returns code, number of bytes in this utf8 char
   return code, size
end
local map_1252_to_unicode = {[0x80] = 0x20AC, [0x81] = 0x81, [0x82] = 0x201A, [0x83] = 0x0192, [0x84] = 0x201E, [0x85] = 0x2026, [0x86] = 0x2020, [0x87] = 0x2021, [0x88] = 0x02C6, [0x89] = 0x2030, [0x8A] = 0x0160, [0x8B] = 0x2039, [0x8C] = 0x0152, [0x8D] = 0x8D, [0x8E] = 0x017D, [0x8F] = 0x8F, [0x90] = 0x90, [0x91] = 0x2018, [0x92] = 0x2019, [0x93] = 0x201C, [0x94] = 0x201D, [0x95] = 0x2022, [0x96] = 0x2013, [0x97] = 0x2014, [0x98] = 0x02DC, [0x99] = 0x2122, [0x9A] = 0x0161, [0x9B] = 0x203A, [0x9C] = 0x0153, [0x9D] = 0x9D, [0x9E] = 0x017E, [0x9F] = 0x0178, [0xA0] = 0x00A0, [0xA1] = 0x00A1, [0xA2] = 0x00A2, [0xA3] = 0x00A3, [0xA4] = 0x00A4, [0xA5] = 0x00A5, [0xA6] = 0x00A6, [0xA7] = 0x00A7, [0xA8] = 0x00A8, [0xA9] = 0x00A9, [0xAA] = 0x00AA, [0xAB] = 0x00AB, [0xAC] = 0x00AC, [0xAD] = 0x00AD, [0xAE] = 0x00AE, [0xAF] = 0x00AF, [0xB0] = 0x00B0, [0xB1] = 0x00B1, [0xB2] = 0x00B2, [0xB3] = 0x00B3, [0xB4] = 0x00B4, [0xB5] = 0x00B5, [0xB6] = 0x00B6, [0xB7] = 0x00B7, [0xB8] = 0x00B8, [0xB9] = 0x00B9, [0xBA] = 0x00BA, [0xBB] = 0x00BB, [0xBC] = 0x00BC, [0xBD] = 0x00BD, [0xBE] = 0x00BE, [0xBF] = 0x00BF, [0xC0] = 0x00C0, [0xC1] = 0x00C1, [0xC2] = 0x00C2, [0xC3] = 0x00C3, [0xC4] = 0x00C4, [0xC5] = 0x00C5, [0xC6] = 0x00C6, [0xC7] = 0x00C7, [0xC8] = 0x00C8, [0xC9] = 0x00C9, [0xCA] = 0x00CA, [0xCB] = 0x00CB, [0xCC] = 0x00CC, [0xCD] = 0x00CD, [0xCE] = 0x00CE, [0xCF] = 0x00CF, [0xD0] = 0x00D0, [0xD1] = 0x00D1, [0xD2] = 0x00D2, [0xD3] = 0x00D3, [0xD4] = 0x00D4, [0xD5] = 0x00D5, [0xD6] = 0x00D6, [0xD7] = 0x00D7, [0xD8] = 0x00D8, [0xD9] = 0x00D9, [0xDA] = 0x00DA, [0xDB] = 0x00DB, [0xDC] = 0x00DC, [0xDD] = 0x00DD, [0xDE] = 0x00DE, [0xDF] = 0x00DF, [0xE0] = 0x00E0, [0xE1] = 0x00E1, [0xE2] = 0x00E2, [0xE3] = 0x00E3, [0xE4] = 0x00E4, [0xE5] = 0x00E5, [0xE6] = 0x00E6, [0xE7] = 0x00E7, [0xE8] = 0x00E8, [0xE9] = 0x00E9, [0xEA] = 0x00EA, [0xEB] = 0x00EB, [0xEC] = 0x00EC, [0xED] = 0x00ED, [0xEE] = 0x00EE, [0xEF] = 0x00EF, [0xF0] = 0x00F0, [0xF1] = 0x00F1, [0xF2] = 0x00F2, [0xF3] = 0x00F3, [0xF4] = 0x00F4, [0xF5] = 0x00F5, [0xF6] = 0x00F6, [0xF7] = 0x00F7, [0xF8] = 0x00F8, [0xF9] = 0x00F9, [0xFA] = 0x00FA, [0xFB] = 0x00FB, [0xFC] = 0x00FC, [0xFD] = 0x00FD, [0xFE] = 0x00FE, [0xFF] = 0x00FF,}

local map_unicode_to_1252 = {}
for code1252, code in pairs(map_1252_to_unicode) do
   map_unicode_to_1252[code] = code1252
end

function string.fromutf8(utf8str)
   local pos, result_1252 = 1, {}
   while pos <= #utf8str do
      local code, size = utf8_to_unicode(utf8str, pos)
      pos = pos + size
      code = code < 128 and code or map_unicode_to_1252[code] or ('?'):byte()
      table_insert(result_1252, char(code))
   end
   return table_concat(result_1252)
end

function string.toutf8(str1252)
   local result_utf8 = {}
   for pos = 1, #str1252 do
      local code = str1252:byte(pos)
      table_insert(result_utf8, unicode_to_utf8(map_1252_to_unicode[code] or code))
   end
   return table_concat(result_utf8)
end

------------------------------------------------------------------------

-- https://stackoverflow.com/questions/7983574/how-to-write-a-unicode-symbol-in-lua
-- encoder for Lua that takes a Unicode code point and produces a UTF-8 string for the corresponding character

do
  local bytemarkers = { {0x7FF,192}, {0xFFFF,224}, {0x1FFFFF,240} }
  function utf8(decimal)
    if decimal<128 then return string.char(decimal) end
    local charbytes = {}
    for bytes,vals in ipairs(bytemarkers) do
      if decimal<=vals[1] then
        for b=bytes+1,2,-1 do
          local mod = decimal%64
          decimal = (decimal-mod)/64
          charbytes[b] = string.char(128+mod)
        end
        charbytes[1] = string.char(vals[2]+decimal)
        break
      end
    end
    return table.concat(charbytes)
  end
end

c=utf8(0x24)    print(c.." is "..#c.." bytes.") --> $ is 1 bytes.
c=utf8(0xA2)    print(c.." is "..#c.." bytes.") --> ¢ is 2 bytes.
c=utf8(0x20AC)  print(c.." is "..#c.." bytes.") --> € is 3 bytes.
c=utf8(0x24B62) print(c.." is "..#c.." bytes.") --> 𤭢 is 4 bytes.

--------------------------------------------------

function FromUTF8(pos)
local mod = math.mod
local function charat(p)

local v = editor.CharAt[p]

	if v < 0 then v = v + 256 end; return v end

local v, c, n = 0, charat(pos), 1

	if c < 128 then v = c
	elseif c < 192 then
	error("Byte values between 0x80 to 0xBF cannot start a multibyte sequence")
	elseif c < 224 then v = mod(c, 32); n = 2
	elseif c < 240 then v = mod(c, 16); n = 3
	elseif c < 248 then v = mod(c,  8); n = 4
	elseif c < 252 then v = mod(c,  4); n = 5
	elseif c < 254 then v = mod(c,  2); n = 6
	else
	error("Byte values between 0xFE and OxFF cannot start a multibyte sequence")
	end

	for i = 2, n do
	pos = pos + 1; c = charat(pos)
		if c < 128 or c > 191 then
		  error("Following bytes must have values between 0x80 and 0xBF")
		end
	v = v * 64 + mod(c, 64)
	end

return v, pos, n

end

-- " Lua os. functions with Unicode. How?" https://forum.cockos.com/showthread.php?t=215773 -- more resources
-- http://lua-users.org/wiki/LuaUnicode


-- UNICODE -- UTF-8  CONVERTER  END

-- BASE64 to HEX
-- https://github.com/EUGEN27771/ReaScripts/blob/master/FX/gen_Save%20Preset%20for%20last%20touched%20FX.lua
-- https://gist.github.com/X-Raym/448e8afea7d91bce96b520ca12ddc698


--========================= C O N V E R S I O N S   E N D ===========================



--======== R E A S C R I P T  F U N C T I O N S  F O R  V A R I O U S  T A S K S =========


-- Get take source

r.GetMediaSourceFileName(r.GetMediaItemTake_Source(r.GetActiveTake(r.GetSelectedMediaItem(0,0))), '')

--===================================================================================

-- Functions to get number of tracks

reaper.CountTracks(0)

reaper.GetNumTracks()

reaper.CSurf_NumTracks(boolean mcpView)
-- when mcpView is false returns total in the project regardless of track visibility
-- when mcpView is true returns total in the project if none is visible in the Mixer
-- (disregarding the Master track), if at least one is visible only returns the visible count

--===================================================================================

-- Functions to get track name

retval, name = reaper.GetTrackName(tr)

retval, string = reaper.GetSetMediaTrackInfo_String(tr, 'P_NAME', '', false)

retval, flags = reaper.GetTrackState(track) -- retval returns name or empty string

--===================================================================================

-- Functions to find Master track

-- don't depend on the Master track visibility
reaper.CSurf_TrackToID(tr, true) == 0 -- mcpView true
reaper.CSurf_TrackToID(tr, false) == 0 -- mcpView false

select(2,reaper.GetTrackName(tr)) == 'MASTER'

select(2,reaper.GetSetMediaTrackInfo_String(tr, 'P_NAME', '', false)) == 'MASTER'

reaper.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER') == -1

tr == r.GetMasterTrack(0)


--===================================================================================

-- Functions to get track index


reaper.CSurf_TrackToID(track, boolean mcpView) -- if mcpView is true returns -1 if the track is inside a collapsed MCP folder or explicitly hidden in the Mixer, doesn't depend on the track state in Arrange

reaper.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER')


--===================================================================================

-- Functions to get track pointer from index


reaper.CSurf_TrackFromID(idx, boolean mcpView)

reaper.GetTrack(0, idx)


-- store selected track pointer irrespective of its selection

tr = reaper.CSurf_TrackToID(r.GetSelectedTrack(0,0), false) -- false is mcpView
tr = reaper.GetTrack(0, tr-1)


--===================================================================================

-- Functions to get track GUID

reaper.GetSetMediaTrackInfo_String(tr, 'GUID', '', false) -- setNewValue false

reaper.GetTrackGUID(tr)


--===================================================================================

-- Functions to get track folder state

reaper.GetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH')
-- 0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder,
-- -2=track is the last in the innermost and next-innermost folders, etc

reaper.GetParentTrack(track)

retval, number = reaper.GetTrackState(track)
number&1 = 1 -- folder

reaper.GetTrackDepth(tr) -- 0 = folder or regular, 1 = child under 1st folder, 2 = child under the 2nd etc

--===================================================================================

-- Functions to get track color

reaper.GetTrackColor(track)

reaper.GetMediaTrackInfo_Value(tr, 'I_CUSTOMCOLOR')

-- return value 0 means default track color is used, see GetThemeColor() 'col_seltrack', 'col_seltrack2'

--===================================================================================

-- Functions to set track color

reaper.SetMediaTrackInfo_Value(tr, 'I_CUSTOMCOLOR', r.ColorToNative(r,g,b)|0x100000)

reaper.SetTrackColor(tr, r.ColorToNative(r,g,b)|0x100000)

-- color arg 0 without |0x100000 resets track color to default, see GetThemeColor() 'col_seltrack', 'col_seltrack2'


--===================================================================================

-- Functions to get track visibility

local ret, flags = r.GetTrackState(tr)
local TCP_vis = flags&512 ~= 512 -- 512 is hidden from TCP
local MCP_vis = flags&1024 ~= 1024 -- 1024 is hidden from MCP

local TCP_vis = r.IsTrackVisible(tr, false) -- mixer false
local MCP_vis = r.IsTrackVisible(tr, true) -- mixer true

-- IsTrackVisible() doesn't work with the Master track, always returns truth

-- not for the Master track
local TCP_vis = r.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') -- returns 1 if true, 0 is false
local MCP_vis = r.GetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER') -- returns 1 if true, 0 is false

-- to change visiblity

-- not for the Master track
r.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', 1) -- show, 0 hide
r.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', 1) -- show, 0 hide


r.GetMasterTrackVisibility()&2 == 2 -- hidden in the Mixer (contrary to old versions of the API doc) hence in r.SetMasterTrackVisibility() 0 rather than &2 must be used to show the Master track and 2 to hide it
r.GetMasterTrackVisibility()&1 == 1 -- visible in Arrange

-- Toggle Master track visibility
local state = r.GetMasterTrackVisibility()
r.SetMasterTrackVisibility(state~1) -- in Arrange
r.SetMasterTrackVisibility(state~2) -- in the Mixer

--===================================================================================

-- Functions to query if track/item is selected

reaper.GetMediaTrackInfo_Value(track, "I_SELECTED") -- 0=unselected, 1=selected or false/true

reaper.IsTrackSelected(track)

string retval, flag = reaper.GetTrackState(track)
local is_sel = flag&2 == 2


reaper.GetMediaItemInfo_Value(item, "B_UISEL") -- 0=unselected, 1=selected or false/true

reaper.IsMediaItemSelected(item)

--===================================================================================

-- Functions to set track/item selected

reaper.SetMediaTrackInfo_Value(track, "I_SELECTED", 1) -- true/false or 1/0
reaper.SetTrackSelected(track, 1)
reaper.CSurf_OnTrackSelection(trackid)
reaper.CSurf_OnSelectedChange(trackid, 1) -- 1 or 0
reaper.SetOnlyTrackSelected(track)


reaper.SetMediaItemInfo_Value(item, "B_UISEL", 1) -- 1/0 or true/false
reaper.SetMediaItemSelected(item, 1)
reaper.SelectAllMediaItems(0, true)

--===================================================================================

-- Functions to get track parent track

r.GetParentTrack(tr)

local idx = r.GetMediaTrackInfo_Value(tr, 'P_PARTRACK') -- returns track index
local parent = r.CSurf_TrackFromID(idx, false) -- mpcview false

--===================================================================================

-- Functions to get item parent track

r.GetMediaItemTrack(item)

r.GetMediaItem_Track(item)

r.GetMediaItemInfo_Value(item, 'P_TRACK')

r.MediaItemDescendsFromTrack(item, track) -- Returns 1 if the track holds the item,
2 if the track is a folder containing the track that holds the item, etc


--===================================================================================

-- Functions to get take parent item

r.GetMediaItemTake_Item(take)

r.GetMediaItemTakeInfo_Value(take, 'P_ITEM')

--===================================================================================

-- Functions to get take parent track

r.GetMediaItemTake_Track(take)

r.GetMediaItemTakeInfo_Value(take, 'P_TRACK')

--===================================================================================

-- Functions to count item takes


reaper.GetMediaItemNumTakes(item)

reaper.CountTakes(item)

--==================================================================================

-- Functions to get item take

r.GetTake(item, take_idx)

r.GetMediaItemTake(item, take_idx)

-- empty take inserted with 'Item: Add an empty take after the active take' cannot be retrieved with GetActiveTake(item) or with GetTake(item, GetMediaItemInfo_Value(item, 'I_CURTAKE')), neither do they have GUID, but they're accounted for in the total take count

--==================================================================================

-- Functions to get take name


reaper.GetTakeName(take)

retval, string = reaper.GetSetMediaItemTakeInfo_String(take, 'P_NAME', '', false) -- false = get


--===================================================================================

-- Functions to get active take

r.GetTake(item, 0) -- of an item with 1 take only

r.GetActiveTake(item)

r.GetTake(r.GetMediaItemInfo_Value(item, 'I_CURTAKE'))

-- empty take inserted with 'Item: Add an empty take after the active take' cannot be retrieved with GetActiveTake(item) or with GetTake(item, GetMediaItemInfo_Value(item, 'I_CURTAKE')), neither do they have GUID, but they're accounted for in the total take count


--===================================================================================

-- Functions to get active take number

r.GetMediaItemInfo_Value(item, 'I_CURTAKE')

r.GetMediaItemTakeInfo_Value(r.GetActiveTake(item), 'IP_TAKENUMBER')


--===================================================================================

-- Functions to set active take

r.SetActiveTake(take)

-- by index

r.SetActiveTake(r.GetTake(item, take_idx))

r.SetMediaItemInfo_Value(item, 'I_CURTAKE', take_idx)


--===================================================================================

-- Functions to evaluate active take

take == r.GetActiveTake(item)

take_idx == r.GetMediaItemInfo_Value(item, 'I_CURTAKE')

take_idx == r.GetMediaItemTakeInfo_Value(r.GetActiveTake(item), 'IP_TAKENUMBER')


--===================================================================================

-- Functions to get take PCM source

reaper.GetMediaItemTake_Source(take)

reaper.GetMediaItemTakeInfo_Value(take, 'P_SOURCE') -- returns integer, not pointer

--===================================================================================

--Functions to open fx chain displaying specific fx UI or close FX chain altogether

-- TO OPEN

reaper.TrackFX_SetOpen(reaper.GetMasterTrack(), 0x1000000, true) -- 1st fx in Mon FX chain
reaper.TrackFX_SetOpen(reaper.GetMasterTrack(), 0, true) -- 1st fx in Master track FX chain
reaper.TrackFX_SetOpen(reaper.GetSelectedTrack(0,0), 0x1000000, true) -- 1st fx in track Input FX chain
reaper.TrackFX_SetOpen(reaper.GetSelectedTrack(0,0), 0, true) -- 1st fx in track main FX chain

--OR

reaper.TrackFX_Show(reaper.GetMasterTrack(), 0x1000000, 1)
reaper.TrackFX_Show(reaper.GetMasterTrack(), 0, 1)
reaper.TrackFX_Show(reaper.GetSelectedTrack(0,0), 0x1000000, 1)
reaper.TrackFX_Show(reaper.GetSelectedTrack(0,0), 0, 1)


-- TO CLOSE, fx index could be any

reaper.TrackFX_SetOpen(reaper.GetMasterTrack(), 0x1000000, false) - Mon FX chain
reaper.TrackFX_SetOpen(reaper.GetMasterTrack(), 0, true) -- Master track FX chain
reaper.TrackFX_SetOpen(reaper.GetSelectedTrack(0,0), 0x1000000, true) -- track Input FX chain
reaper.TrackFX_SetOpen(reaper.GetSelectedTrack(0,0), 0, true) -- track main FX chain

--OR

reaper.TrackFX_Show(reaper.GetMasterTrack(), 0x1000000, 0)
reaper.TrackFX_Show(reaper.GetMasterTrack(), 0, 0)
reaper.TrackFX_Show(reaper.GetSelectedTrack(0,0), 0x1000000, 0)
reaper.TrackFX_Show(reaper.GetSelectedTrack(0,0), 0, 0)

--===================================================================================

-- Functions to get active preset name and index

local ret, act_pres_name = r.TrackFX_GetPreset(tr, fx_idx, '') -- ret is always true https://forum.cockos.com/showthread.php?t=270988
local act_pres_idx, pres_cnt = r.TrackFX_GetPresetIndex(tr, fx_idx) -- if can't return act_pres_idx is -1, usually when no preset is selected

--===================================================================================

-- Functions to get project path/directory


reaper.GetProjectPath() -- returns primary record path and if not set returns project path,

in both cases without the last slash

reaper.EnumProjects(idx) -- returns full proj path a 2nd value

reaper.EnumProjects(-1) -- returns full path of the current proj as a 2nd value; returns empty string if project doesn't have a file and returns path even if the project file and possibly folder was deleted while the project is open

proj_full_path = select(2,r.EnumProjects(-1))

--===================================================================================

-- Functions to update the UI

reaper.TrackList_AdjustWindows(isMinor) -- isMinor true - only TCP, else both TCP tracklist and the Mixer; track height, Y/X coordinate, color, probably controls position, without update with the function the new data won't be available
reaper.TrackList_UpdateAllExternalSurfaces()
reaper.UpdateItemInProject(item)
reaper.UpdateArrange()
reaper.UpdateTimeline()
reaper.ThemeLayout_RefreshAll()

reaper.PreventUIRefresh(1)
-- STUFF
-- NOT RECOMMENDED when UI parameter change needs monitoring, because in this case it won't update
reaper.PreventUIRefresh(-1)

--===================================================================================

-- Get project media path

local proj_media_path = r.GetProjectPath('') -- for unsaved projects returns default recording path, i.e. '%USER%\Documents\REAPER Media', a dedicated ABSOLUTE path if configured in default Project Settings, or global path configured at Prefs -> General -> Paths -> Default recording path; for saved projects returns the project folder path unless a project dedicated media path is specified in the project settings
-- to find out whether the project is saved
-- local proj, proj_path = r.EnumProjects(-1)
-- #proj_path > 0
-- OR 
-- local proj_name = r.GetProjectName(0, '')

--===================================================================================

-- As yet undocumented track parameter P_BUFSTATS

reaper.GetSetMediaTrackInfo_String(tr,"P_BUFSTATS","",false)

-- https://forum.cockos.com/showthread.php?p=2795874#15

--===================================================================================

-- PreventUIRefresh correct syntax

-- Schwa: You should always call PreventUIRefresh(1) to initiate and PreventUIRefresh(-1) to end

-- https://forum.cockos.com/showthread.

--===================================================================================


-- Detect undo

--=============================== F U N C T I O N   L I S T =========================


--[[

U N D O

	no_undo
	undo_block
	Force_MIDI_Undo_Point1
	Force_MIDI_Undo_Point2
	Force_RS5k_Undo_With_Closed_Chain
	GetUndoSettings
	Toggle_Undo_Settings1
	Toggle_Undo_Settings2
	insert_get_delete_bckgrnd_track
	force_create_undo_point

M A T H

	is_integer
	is_decimal
	is_even1
	is_even2
	is_odd1
	is_odd2
	round1
	round2
	round3
	round4
	round
	truncate_decimal
	truncate
	trim_trail_zero
	math.randomseed
	Get_Closest_Prev_Whole_Multiple
	Get_Closest_Multiple_Of_Divisor1
	Get_Closest_Multiple_Of_Divisor2
	Get_Closest_Multiple_Of_Divisor3
	nmb
	split_integer_to_1s_and_10s
	range_to_sequence
	gener_numer_seq
	mod
	get_integral_1
	get_integral_2
	get_fractional_1
	get_fractional_2
	get_prev_multiple
	get_base2_log
	truncate_all_dec_places1
	truncate_all_dec_places2
	toBits1
	toBits2
	toBits3
	count_bits_in_number
	hex2dec
	dec2hex
	get_integer_length
	un_pack_integers
	calculate_median_value
	split_combine_64bit_integer
	floats_are_equal
	get_greatest_smallest_value1
	get_greatest_smallest_value2


S T R I N G S

	str
	space
	Rep
	Esc
	literalize
	replace
	remove_all_bar_some
	spaceout
	starts_with
	ends_with
	strip_spaces
	trunc_hanging_dec_zero
	split_into_lines
	split_into_multiple_lines
	split_line_by_capture_count
	split_lines_by_length
	Are_Multiple_Captures
	count_captures
	collect_captures
	insert_string_at_specific_position1
	insert_string_at_specific_position2
	count_specific_chars
	remove_Nth_capture
	replace_Nth_capture1
	remove_replace_Nth_capture
	replace_Nth_capture2
	replace_capture_by_capture_number1
	replace_capture_by_capture_number2
	replace_capture_by_capture_number3
	replace_captures_with_table_vals1
	replace_captures_with_table_vals2
	re_store_identical_captures
	list_2_table1
	list_2_table2
	get_index_from_range_or_list1
	get_index_from_range_or_list2
	validate_search_term1
	validate_search_term2
	Convert_Text_To_Menu
	multibyte_str_len
	utf8_len
	string.len
	utf8_len2
	string.reverse
	utf8_chars_to_bytes
	format_time
	format_timestr_alt
	magiclines
	parse_lines_in_reverse
	read_file_in_reverse
	hex
	is_utf8_1
	is_utf8_2
	selective_case_change
	convert_case_selectively
	remove_duplicate_words
	construct_table_from_2_lists
	embellish_string
	bytes2string
	add_zero_padding
	wrap_text
	numerate_instances
	sanitize_string_for_menu
	Construct_Roman_Numerals


T A B L E S

	copy_array1
	copy_array2
	copy_table
	reverse_indexed_table1
	reverse_indexed_table2
	reverse_indexed_table3
	reverse_indexed_table4
	James_Bradbury_reverse_table
	filter_table_vals
	filter_inplace1
	filter_inplace2	
	merge_2_arrays_at_index
	merge_tables1
	merge_tables2
	merge_args_into_array
	unpack_alt
	truncate_array1
	truncate_array2
	shuffle_array
	Randomize_Array
	sort_notes_by_name
	binary_search1
	binary_search2
	collect_numbers
	construct_char_array
	reuse_short_array_over_long
	reuse_short_array_over_long_reversed
	sort_tableA_by_tableB
	sort_table1
	sort_table2
	is_table_already_sorted1
	is_table_already_sorted2
	pack
	build_array_of_multiple_repeating_items
	deep_copy1
	deep_copy2
	embed_table_length1
	embed_table_length2


M I D I

	MIDIEditor_GetSetting_int
	MIDI_GetCC
	MIDI_GetTextSysexEvt
	MIDI_InsertTextSysexEvt
	Is_MIDI_Ed_Open
	MIDIEditor_GetActiveAndVisible
	Force_MIDI_Undo_Point1
	Force_MIDI_Undo_Point2
	Lane_Type_To_Event_Data
	MIDI_Take_Open_Close
	Clear_Restore_MIDI_Channel_Filter
	are_notes_selected
	Notes_Selected
	selected_notes_exist
	CC_Evts_Selected
	Notes_CCEvts_Selected
	Evts_Selected
	All_Sel_CCEvts_Belong_To_Visble_OR_Last_Clicked_Lane
	count_selected_notes
	Deselect_All_Notes
	count_selected_events
	notes_at_current_pitch_exist
	find_first_next_note
	Notes_Overlap_Ignored_Chords
	Notes_Overlap_Respected_Chords
	Correct_Overlapping_Notes1
	Correct_Overlapping_Notes2
	re_store_sel_MIDI_notes
	Mouse_Cursor_outside_painoroll_1
	Mouse_Cursor_outside_painoroll_2
	Re_Store_Edit_Cursor_Pos_In_MIDI_Ed
	Get_Mouse_Coordinates_MIDI
	Get_Note_Under_Mouse
	is_dotted
	round_note
	is_CC_Env_active
	Get_Currently_Active_Chan_And_Filter_State1
	Get_Currently_Active_Chan_And_Filter_State2
	Ch_Filter_Enabled1
	Ch_Filter_Enabled2
	Get_Ch_Selected_In_Ch_Filter
	Prompt_to_Enable_MIDI_Ch_Filter
	Re_Store_Selected_CCEvents1
	Re_Store_Selected_CCEvents2
	Re_Store_Selected_CCEvents3
	Get_Currently_Visible_CC_Lanes
	Only_ReSelect_Evnts_In_Visble_CC_Lanes
	Get_Visible_Lanes_With_Selected_Events
	Get_CC_Lanes_With_Selected_Events
	Delete_CC_Evts_From_Target_Lanes
	Selected_Evnts_In_Visible_CC_Lanes
	All_Sel_CCEvts_Belong_To_Visble_OR_Last_Clicked_Lane
	Delete_Notes_In_MIDI_Channel
	Delete_Notes
	CC_Evts_Exist
	Store_Insert_Notes_OR_Evts
	Get_MIDI_Ed_Grid
	Get_MIDI_Ed_Visible_Grid
	Re_Store_Note_Length_Setting
	Get_Track_MIDI_Note_Names
	Get_Note_Name_At_Current_Pitch
	Get_Default_MIDI_Chan
	Re_Store_MIDI_Editor_Mode
	Detect_Natural_Notes


(R E) S T O R E

	StoreSelectedObjects
	Restore_Saved_Selected_Objects
	Restore_Saved_Selected_Objects
	Re_Store_Selected_Objects
	re_store_sel_trks1
	re_store_sel_trks2
	ReStoreSelectedItems
	Re_Store_Selected_Items
	re_store_obj_selection


O B J E C T S

	Find_And_Get_New_Objects
	Get_Object_Under_Mouse_Curs
	GetObjInfo_Value
	SetObjInfo_Value
	GetSetObjInfo_String
	GetObjAllInfo_Values
	Get_Obj_By_GUID1
	Get_Obj_By_GUID2
	Cascade_To_Target_Object


T R A C K S

	Get_TCP_MCP_Under_Mouse
	Track_Visible_In_Arrange_Or_Mixer
	Get_Top_Left_most_Visible_Track
	Get_First_Visible_Track
	CountVisibleTracks
	Get_Track_At_Mouse_Cursor_Y
	collapse_TCP1
	collapse_TCP2
	Deselect_All_Tracks1
	Deselect_All_Tracks2
	Track_Controls_Locked1
	Track_Controls_Locked2
	Preserve_TCP_Heights_When_Bot_Dock_Open
	Re_Store_Track_Heights_Selection_x_Scroll
	Temp_Track_For_FX
	Insert_Temp_Track
	Insert_Delete_Temp_Track
	insert_get_delete_bckgrnd_track
	Get_Vis_TCP_Tracklist_Length_px_X_Topmost_Track
	Scroll_Track_To_Top1
	Scroll_Track_To_Top2
	Scroll_Track_To_Top3
	Scroll_Track_To_Bottom
	Scroll_Track_Into_View
	Scroll_Visible_Track_Into_View
	Un_Collapse_All_Tracks_Temporarily
	Create_Buss_Track
	Find_And_Get_New_Tracks
	Get_Track_Minimum_Height1
	Get_Track_Minimum_Height2
	Reverse_Track_Order
	Remove_Track_From_All_Groups
	Remove_Track_Roles_From_All_Groups
	Is_Track_Group_Disabled1
	Is_Track_Group_Disabled2
	Visible_Selected_Tracks_Exist
	Is_TrackList_Hidden
	Parse_Razor_Edit_Data
	Collect_Razor_Edit_Areas
	Update_Track_MIDI_Note_Names
	Get_Track_MIDI_Note_Names
	GetTrackState
	GetTrackTree
	Fixed_Lane_Comping_Enabled
	Get_Last_Sel_or_Last_Track
	In_Visible_Tracks_Exist1
	In_Visible_Tracks_Exist2
	Get_Last_Touched_Fixed_Item_Lane
	Get_Index_of_Fixed_Item_Lane_Under_Mouse
	


S E N D S / R E C E I V E S
	
	Is_Send_Dest_Track
	Is_Recv_Src_Track
	Remove_Track_Receives
	Get_Track_MIDI_Send_Recv_Channels
	Set_Track_MIDI_Send_Recv_Channels
	Insert_Track_With_One_Regular_And_One_HWOutput_Send
	Collect_Snd_Data
	GetSetTrackSendInfo_Value
	Get_Set_Track_Snd_Rec_Src_Dest_Channel
	Audio_Send_Exists



F O L D E R S

	Store_Children_And_Grandchildren
	get_track_children_and_grandchildren
	Store_Children
	Are_All_Children_Selected
	Count_And_Store_Siblings
	Are_All_Siblings_Selected
	Get_Folder_First_Track
	Get_Folder_Last_Track
	Get_All_Track_Parents1
	Get_All_Track_Parents2
	get_track_parents
	Get_Topmost_Uncollapsed_TCP_Parent
	get_last_uncollapsed_parent
	Find_Last_Uncollapsed_MCP_Parent
	Get_Parent_Of_MCP_First_Uncollapsed_Folder1
	Get_Parent_Of_MCP_First_Uncollapsed_Folder2
	Get_All_Descendants
	Get_All_Relatives
	Is_TCP_MCP_Collapsed
	Dismantle_FolderOrSubfolder
	Track_Is_Vis_And_Child_Of_Collapsed_MCP_Folder
	Track_Is_Vis_And_Child_Of_Collapsed_TCP_Folder
	Track_Is_Child_Of_Collapsed_Folder1
	Track_Is_Child_Of_Collapsed_Folder
	Track_Is_Vis_And_Child_Of_Collapsed_Folder
	All_Parent_Folders_Uncollapsed
	Create_Folder_For_Adjacent_Tracks
	Create_Folder_For_Selected_Tracks
	Move_Outside_Tracks_Into_Existing_Folder
	Sort_Tracks_Inside_Folder


E N V E L O P E S

	Is_Valid_Envelope
	Is_Env_Visible
	Set_Env_In_Visible
	Is_Env_Bypassed
	Get_Env_State
	Toggle_Env_State
	Get_Active_Envelopes
	Delete_Env
	Get_Env_GUID
	Get_Vis_Env_GUID
	Re_Store_Env_Selection
	Manipulate_Envelope_With_Actions
	Count_FX_Envelopes
	Get_Env_Point_At_Time
	Count_Sel_Points
	Get_FX_Env_Src_Parameter
	Get_Take_Pitch_Env_Snap
	Get_Vol_Env_Range
	Is_Track_FX_Envelope
	Is_Track_Or_Take_Env
	Is_Selected_Track_Or_Take_Env
	FX_Or_Native_Envelope
	Envelopes_Locked
	Deselect_All_Env_Points
	Get_Env_Segment_At_Cursor
	Get_Env_Custom_Colors
	Check_env_scaling
	Active_Track_Envelopes_Exist1
	Active_Track_Envelopes_Exist2


A U T O M A T I O N  I T E M S

	UnTrim_AutomItem_LeftEdge
	Trim_AutomItem_LeftEdge
	Insert_AI_with_Unique_Pool_ID
	Delete_AutomItem
	Split_AutomItem
	Re_Store_Sel_AIs1
	Re_Store_Sel_AIs2
	Deselect_Selected_AIs
	Get_Sel_AI_St_And_End
	Delete_Or_Unpool_Selected_AI
	RESOLVE_AI_OVERLAPS
	Get_AI_At_Mouse_Cursor
	Deselect_Points_In_Env_All_AIs1
	Deselect_Points_In_Env_All_AIs2
	Get_Props_Of_AI_Intersecting_Cur_Pos
	Get_Props_Of_AI_Overlapping_Env_Pt
	Get_AI_Env_Segment_At_Cursor


C H U N K

	GetObjChunk1
	GetObjChunk2
	Err_mess
	SetObjChunk1
	SetObjChunk2
	Replace_GUIDs_in_Chunk
	Remove_Track_Chunk_By_Criteria
	Remove_Chunks
	Get_Take_Chunk
	Replace_Take_Chunks
	Collect_Take_Chunks


R A Z O R  E D I T

	Re_Store_Razor_Edit_Areas
	Parse_Razor_Edit_Data
	Collect_Raz_Edit_Data
	Find_And_Remove_Raz_Edit_Overlaps


F X

	Summary of native FX selection functions
	GetMonFXProps
	GetFocusedFX1
	GetFocusedFX2
	GetOrigFXName
	Get_Focused_FX_Orig_Name
	Retrieve_Orig_Plugin_Names
	Get_FX_Chain_Chunk
	Get_FX_Chunk
	Collect_VideoProc_Instances
	Collect_VST3_Instances
	Collect_FX_Preset_Names
	Re_Store_Plugin_Settings
	Select_FX_UI_in_FXChain
	GetLastTouchedFX1
	GetLastTouchedFX2
	Collect_FX_Output_Data
	Is_TrackFX_Open
	Count_FX
	Get_FX_Env_Src_Parameter
	Get_FX_Type
	Check_FX_In_Focused_FX_Chain
	Check_If_FX_Selected_In_FX_Browser1
	Check_If_FX_Selected_In_FX_Browser2
	Check_Selected_FX
	Re_Store_Float_FX_Wnds
	Re_Store_FX_Windows_Visibility
	FX_Has_Envelopes
	TrackFX_GetRecChainVisible1
	TrackFX_GetRecChainVisible2
	FX_Exists
	Enum_RS5k_files
	Force_RS5k_Undo_With_Closed_Chain
	Get_FX_Selected_In_FX_Chain
	Set_FX_Selected_In_FX_Chain
	GetSet_FX_Selected_In_FX_Chain
	Apply_FX_Chain
	Process_FX_Incl_In_All_Containers
	Collect_All_Container_FX_Indices
	Loop_Over_FX_Container_Table
	Get_FX_All_Parent_Containers
	GetSetClear_FX_Parm_Mapping_Across_Containers
	Get_Container_Parm_Source_Props
	Get_FX_Parm_Orig_Name_s
	Get_FX_Parm_By_Name_Or_Ident
	Is_Same_Plugin
	Validate_FX_Identity
	Get_Open
	Apply_Video_Proc_Preset
	Insert_Video_Proc_With_Preset
	Get_Vid_Proc_Instance_Default_Name
	Find_Video_Proc_Instance


I T E M S

	Get_Item_By_Take_GUID
	Re_Store_Options_Togg_States
	Toggle_Item_Selection
	Display_Item_Name
	Rename_Item_Take_Src_File1
	Rename_Item_Take_Src_File2
	Re_Store_Active_Take_At_Index
	Re_Store_Active_Take_By_GUID
	Delete_Track_Items
	Count_Track_Sel_Items1
	Count_Track_Sel_Items2
	Get_Folder_Rightmost_Item_RightEdge
	Generate_Consistent_IID_Sequence
	Are_There_Overlapping_Itms
	Are_Itms_Overlapping
	Are_Two_Items_Overlapping
	Count_Selected_Overlapping_Itms
	Get_Outermost_Overlapping_Item
	Overlapping_Itms_Props
	Are_Itms_Overlapping_Selected_Collapsed
	Are_Overlapping_Itm_Lanes_Collapsed
	Shift_Overlapping_Items_Together
	Is_Overlapping_In_Lanes
	Count_Sel_Itms_Unique_Tracks
	Get_Item_Greatest_And_1st_Availab_Group_IDs1
	Get_Item_Greatest_And_1st_Availab_Group_IDs2
	get_same_group_items
	Insert_Empty_Item_To_Display_Text1
	Insert_Empty_Item_To_Display_Text2
	Insert_Image
	Insert_Temp_Item
	Insert_Item_On_Temp_Track
	Get_Item_Edge_At_Mouse
	Get_Sel_Items_St_And_End
	Is_Same_Items_Track
	REVERSE_TAKES_VIA_CHUNK
	Get_Arrange_and_Header_Heights1
	Get_Arrange_and_Header_Heights2
	Get_Item_Track_Segment_At_Mouse1
	Get_Item_Track_Segment_At_Mouse2
	AZpercussion_GetItemTopBottomHalf
	Proj_Time_2_Item_Time
	Item_Time_2_Proj_Time
	ApplyNudge scenarios
	Fades_Exist
	is_audio_src
	Delete_Take_Src
	Get_Take_Src_Props
	Select_Items_With_Same_Src_Media
	Audio_Or_MIDI_Takes
	Get_Src_Orig_Length
	Is_Take_Source_Trimmed
	Create_Take_Source_Section
	Get_Take_Polarity
	MPL_Set_Startoffs_With_Stretch_Mrkrs
	Re_Store_Apply_Stretch_Markers
	Find_And_Get_New_Items
	Is_Item_Looped_In_Arrange
	Import_Item_To_RS5k
	Is_Item_Under_Mouse
	Is_Item_Under_Mouse_Locked	
	Split_Item_Into_Takes_And_Reconstruct
	Item_Has_Top_Icon_Bar
	Get_Default_Take_Rank_Scale
	Get_Take_Rank
	Get_Set_Take_Marker_Length
	Media_Items_Exist1
	Media_Items_Exist2
	Audio_Take_Exists_In_Selected_Items
	Get_Item_Lane_Index
	Duplicate_Active_Take_Contiguously
	Move_Active_Take_Within_Item
	get_active_take_index_via_chunk
	Convert_Empty_Take_To_Valid_Take	



C O L O R

	Validate_HEX_Color_Setting1
	Validate_HEX_Color_Setting2
	hex2rgb
	FTC_HexToNormRGB
	rgb2hex
	RANDOM_RGB_COLOR
	Generate_Random_Color_Val
	zaibuyidao_RGBHexToDec
	randomize_color
	rgb2num
	num2rgb
	RGB_To_From_Integer1
	RGB_To_From_Integer2
	RGB_To_Normalized
	Split_Integer_To_RGB_And_Combine
	Extract_Object_Color
	close_gfx_wnd_and_store_coordinates
	mouse_click_within_gfx_wnd
	restore_gfx_wnd_focus
	RandomizeBackgroundColor


C L O S U R E S

	LoopOverSelectedItems
	return_captures
	gmatch_alt
	get_track_parents
	ReaIter._make_iterator


M A R K E R S  &  R E G I O N S

	is_region_within_time_sel
	get_region_at_edit_or_mouse_cursor
	GetRegionAtCursor
	Get_Marker_Reg_At_Mouse_Or_EditCursor
	Get_Marker_Reg_At_Time_OR_Mouse_Or_EditCursor
	Get_Marker_Region_At_Time
	Delete_Marker_Region_At_Time
	Get_Marker_Reg_In_Time_Sel
	Remove_All_Proj_Markers
	Store_Delete_Restore_Proj_Markers
	Store_Delete_Restore_Proj_Mark_Regions
	lexaproductions_Region_IsSelected
	Get_First_MarkerOrRgn_After_Time
	Find_Next_MrkrOrRgn_By_Name
	Monitor_MrkrsOrRgns
	Take_Marker_Exists
	Get_Mrkr_Region_Default_Color
	Get_Take_Mrkr_Default_Color
	Get_Action_Marker_Data
	Get_Last_Proj_Mrkr_Pos
	Fix_Overlapping_Regions
	Get_Mrkrs_Of_Takes_At_Mouse_Or_Edit_Curs
	Get_Rgn_Mrkr_Mngr_Settings
	Get_Selected_And_Hidden_Markers_And_Regions


G F X

	GFX_SETFONT_FLAGS
	Prevent_Floating_Window_Resize1
	Prevent_Floating_Window_Resize2
	gfx_drawstring
	Re_Store_GFX_Wnd_Dock_State
	Re_Store_GFX_Wnd_Coordinates
	close_gfx_wnd_and_store_coordinates
	monitor_window_properties
	mouse_click_within_gfx_wnd
	restore_gfx_wnd_focus
	RandomizeBackgroundColor


W I N D O W S

	Loka_Window_At_Mouse
	Loka_Window_At_Center
	SWS_wnd_open
	SWS_wnd_data
	Get_Mixer_Wnd_Dock_State
	Detect_Docker_Pane_Change
	Get_Mixer_Width
	GetTCP_Width
	Re_Store_Windows_Props_By_Names1
	Re_Store_Windows_Props_By_Names2
	Re_Store_Windows_Props_By_Names_And_Handles1
	Re_Store_Windows_Props_By_Names_And_Handles2	
	Is_Window_Visible1
	Is_Window_Visible2
	Exclude_Visible_Windows
	Move_Window_To_Another_Dock
	JS_Window_IsVisible
	Find_Window_SWS
	Get_Child_Windows_JS1
	Get_Child_Windows_JS2
	Get_Window_And_Children_JS
	Get_Child_Windows_SWS
	Get_All_Parent_Windows
	Get_Top_Parent_Window
	Is_Parent_Window
	Is_Window_Docked
	Traverse_List1
	Traverse_List2
	GetSet_SWS_Notes_Wnd_Scroll_Pos
	Scroll_SWS_Notes_Window
	Scroll_Window
	Scroll_Region_Mngr_JS
	Get_Focused_Item_In_List
	Insert_String_Into_Field_SWS
	Scroll_MX_File_List1
	Scroll_MX_File_List2
	Mouse_Click
	Is_Floating_FX_Window
	Is_FX_Chain_Window
	Is_Window_Fully_Minimized
	Activate_Context
	Set_Horiz_Zoom_Level
	Re_Store_Zoom
	get_gfx_scale 
	click_pad
	keep_click_pad_size
	gfx_mouse_click
	store_or_update_coordinates_after_quitting1
	store_or_update_coordinates_after_quitting2


F I L E S

	get_script_path
	get_package_path_for_require
	Get_Script
	set_script_instances_mode
	Parse_Script_Name1
	Parse_Script_Name2
	Parse_Script_Name3
	Invalid_Script_Name1
	Invalid_Script_Name2
	Invalid_Script_Name3
	Dir_Exists1
	Dir_Exists2
	File_Exists1
	File_Exists2
	File_Exists3
	file_exists_alt
	make_file_name_unique
	file_status
	move_file_to_another_folder
	Validate_Folder_Path
	print_or_write_to_file
	ScanPath1
	ScanPath2
	scandir
	Count_Files_In_Folder
	Remove_Peak_Files
	get_file_timestamp1
	get_file_timestamp2
	get_file_timestamp3
	get_file_timestamp4	
	open_dir_in_file_browser
	delete_string_from_file
	Read_Lines
	get_ini_file_path
	get_proj_path
	get_proj_title
	get_ini_cont
	Check_reaper_ini
	Extract_reaper_ini_val1
	Extract_reaper_ini_val2
	Get_File_Cont
	Get_Or_Create_Dummy_Project_File1
	Get_Or_Create_Dummy_Project_File2
	META_Spawn_Scripts
	GetActionCommandIDByFilename
	Get_CommID_By_Script_Name
	Get_Set_Script_Cont
	Get_File_Size1
	Get_File_Size2
	Get_File_Size3
	Get_File_Size4
	Script_Is_Installed
	(loadfile syntax)
	(require syntax)
	load_functions_from_file
	Parse_ReaBank_File	
	GetUserFileNameForRead_Alt
	sanitize_file_name1
	sanitize_file_name2
	sanitize_file_path
	Copy_Or_Move_File
	Get_Last_Accessed_Dir
	get_cwd()
	Get_Desktop_Path


M E A S U R E M E N T S / C A L C U L A T I O N S

	Get_Vis_Arrange_Len_In_Pixels
	Get_Arrange_Dims
	GetSet_Track_Zoom_100_Perc
	Get_Proj_Len_In_Px
	Beat_To_Pixels
	Grid_Div_Dur_In_Sec
	Get_Visible_Grid_Div_Length
	Get_Time_Of_Closest_Grid_Div
	Music_Div_To_Sec
	Music_Div_To_Pixels
	Scale_Time_By_Horiz_Zoom_Level
	frames2ms
	frames2sec
	time_pos_to_pixels
	pixel_to_sec
	Horiz_Scroll_Distance
	Get_Screen_Dims
	Calc_New_Vol_Value
	DbToVal
	ValToDb
	dBFromVal
	ValFromdB
	WDL_DB2VAL
	WDL_VAL2DB
	Adjust_Velocity_By_dB
	Measure_Note_In_Ms
	Offset_Shift_Value_To_Land_On_Natural_Keys1
	Offset_Shift_Value_To_Land_On_Natural_Keys2
	get_time_sel_or_loop_len


U T I L I T Y

	Msg
	Msg2
	printf
	DebugMsg
	execute_function_from_table
	Is_Project_Start
	ProjExtStates_2_Table
	Validate_Positive_Integer
	is_set
	validate_sett
	validate_multi_line_sett
	validate_settings1
	validate_settings2
	validate_settings3
	validate_global_var
	validate local variable (not a function)
	Validate_All_Global_Settings
	Settings_Management_Menu_And_Help
	Toggle_Settings_From_Menu
	Toggle_Setting_From_Menu
	Display_Script_Help_Txt
	Get_Main_Script_Settings
	validate_output1
	validate_output2
	Get_Action_ID
	do_in_X_mins
	ACT1
	ACT2
	ACT3
	ACT4
	get_tog_state
	capture_command
	Script_Not_Enabled
	Reminder_Off
	Show_Menu_Dialogue
	Reload_Menu_at_Same_Pos1
	Reload_Menu_at_Same_Pos2
	Reload_Menu_at_Same_Pos_gfx
	Get_Set_Menu_Toggle_Options
	Menu_With_Toggle_Options1
	Menu_With_Toggle_Options2
	Toggle_Option
	Create_Submenus_Dynamically
	Options_State_Readout
	ShowMessageBox_Menu
	Re_Store_Ext_State	
	Wrapper1
	Wrapper2
	Wrapper_multi_function
	EMERGENCY_TOGGLE
	Re_Set_Toggle_State
	Get_Option_Script_Toggle_State
	defer_store
	Count_Proj_Tabs
	Open_Close_Temp_Proj_Tab_Without_Save_Prompt1
	Open_Close_Temp_Proj_Tab_Without_Save_Prompt2
	Open_Close_Temp_Proj_Tab_Without_Save_Prompt3
	Validate_Proj_Tab
	Is_Win
	Get_OS
	All_Proj_Change_Cnt
	Bump_Proj_Change_Cnt
	PAUSE
	EvaluateTAG
	is_tbl_or_ptr_or_fnc
	GetUserInputs_Alt
	Get_Type_Of_Action
	Get_Armed_Action
	Condition_Action_By_Armed_State
	Validate_Command_ID
	Is_Non_Native_Action
	Get_Action_Name	
	timed_tooltip1
	timed_tooltip2
	Error_Tooltip1
	Error_Tooltip2
	Error_Tooltip3
	Center_Message_Text
	Get_Mouse_Pos_Sec
	Get_Mouse_Time_Pos
	Get_Mouse_Or_Edit_Curs_Pos
	Get_Mouse_TimeLine_Pos
	isMouseInArrangeView
	Get_Tooltip_Settings
	Keep_ExtState_For_X_Mins1
	Keep_ExtState_For_X_Mins2
	ExtState_Expiry_Timer
	Set_Get_Delete_ExtState_Series
	WAIT
	Archie_WAIT
	REAPER_Ver_Check1
	REAPER_Ver_Check2
	REAPER_Ver_Check3
	SWS_Version_Check
	how_recently_the_project_was_saved
	Time_Sel_Or_Loop_Exist
	Is_Ctrl_And_Shift
	GetPlayPosition3
	Is_Mouse_Over_Arrange1
	Is_Mouse_Over_Arrange2
	Is_Mouse_Over_Arrange3
	Get_Cursor_Contexts
	GetRulerTimeUnit
	GetTransportTimeUnit
	Un_Set_MW_Config_Flags
	Get_Mousewheel_Mode
	RUN1
	RUN2
	Link_To_New_Project
	monitor_defer_loop_update_rate
	Note_Format_Check
	Custom_Horiz_Scroll
	Mouse_Wheel_Direction
	Process_Mouse_Wheel_Direction1
	Process_Mouse_Wheel_Direction2
	Process_Mousewheel_Sensitivity
	Mousewheel_Or_Shortcut	
	Is_Mousewheel
	Is_Not_Relative_Mode
	format_time_given_in_sec
	Time_in_Sec_to_List
	Ad_Hoc_Setting
	Get_Lock_Settings1
	Get_Lock_Settings2
	Get_Region_Marker_Mngr_Settings1
	Get_Region_Marker_Mngr_Settings2
	Get_Media_Explorer_Show_Submenu_Options
	Get_Media_Explorer_Column_Count
	MediaExplorer_OnCommand1
	MediaExplorer_OnCommand2
	trackselonmouse
	generate_custom_action_ID
	en_de_code_bitfield
	Action_list_sections
	Generate_list_of_notes
	Run_Functions_From_Table
	get_Lua_bitdepth
	get_system_bitdepth1
	get_system_bitdepth2
	gmem_write_read_str + JSFX
	split_string_at_new_line_charA JSFX
	split_string_at_new_line_charB JSFX
	get_longest_str_idx JSFX
	os.getenv()
	CheckDependencies and validate_dependency
	Break
	J_Reverb_randomizer


C O N V E R S I O N S

	hex2dec
	dec2hex
	char_to_bytes
	unicode_to_utf8
	utf8_to_unicode
	convert_case_in_unicode
	Mespotine_Base64_Encoder
	Mespotine_Base64_Decoder
	codepoint_to_utf8
	map_unicode_to_1252
	string.fromutf8
	string.toutf8
	FromUTF8


]]
